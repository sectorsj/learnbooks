package ru.sectorsj.book.shild.javaguade._3_data_types_vars_arrays_79_109._3_4_3_0_auto_type_promotion_97;


/**
 * 3.4.3.0 - Автоматическое продвижение типов в выражениях
 *
 * Помимо операций присваивания, определенное преобразование
 * типов может выполняться и в выражениях.
 *
 * Это может происходить в тех случаях,
 * когда требующаяся точность
 * промежуточного значения выходит
 * за пределы допустимого диапазона значений
 * любого из операндов в выражении.
 *
 * Пример 1:
 * рассмотрим следующий фрагмент кода:
 *  byte a = 40;
 *  byte b = 50;
 *  byte c = 100;
 *  int d = a * b / c;
 *
 * Результат вычисления промежуточного члена a * b
 * вполне может выйти за пределы
 * диапазона допустимых значений его операндов типа byte.
 *
 * Для разрешения подобных затруднений
 * при вычислении выражений в Java
 * тип каждого операнда:
 *  - byte
 *  - short
 *  - char
 * автоматически продвигается к типу int.
 *
 * Вычисление промежуточного выражения a * b
 * выполняется с помощью целочисленных,
 * а не байтовых значений.
 *
 * Поэтому, результат:
 *  2000
 * вычисления промежуточного выражения:
 *  50 * 40
 * оказывается вполне допустимым,
 * несмотря на то, что оба операнда
 * (а и b)
 * объявлены как относящиеся к типу byte.
 *
 * Несмотря на все удобства автоматического продвижения типов,
 * оно может приводить к досадным ошибкам во время компиляции.
 *
 * Пример 1:
 * предпринимается попытка сохранить произведение
 *  50 * 2
 * (вполне допустимое значение типа byte)
 * в переменной типа byte.
 *
 * Поскольку во время вычисления этого выражения
 * тип операндов автоматически продвигается к типу int,
 * то и тип результата также продвигается к типу int.
 *
 * Результат вычисления данного выражения
 * относится к типу int
 * и не может быть присвоен
 * переменной типа byte без приведения типов.
 *
 * Пример 2:
 * благодаря приведению типов
 * переменной "b"
 * присваивается правильное значение "100".
 *
 * Когда присваиваемое значение
 * умещается в переменной целевого типа,
 * как в примере 2.
 *
 * Когда последствия переполнения очевидны,
 * следует использовать явное приведение типов.
 */
public class AutoPromoteTypes {
    public static void main(String[] args) {
        // Пример 1:
        byte b1 = 50;
        // ОШИБКА! Значение типа int не может быть
        // присвоено переменной типа byte!
        // b1 = b1 * 2;


        // Пример 2:
        byte b2 = 50;
        b2 = (byte)(b2 * 2);
    }
}