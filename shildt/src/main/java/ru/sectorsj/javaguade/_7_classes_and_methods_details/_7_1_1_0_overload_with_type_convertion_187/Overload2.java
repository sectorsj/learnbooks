package ru.sectorsj.book.shild.javaguade._7_classes_and_methods_details._7_1_1_0_overload_with_type_convertion_187;


/**
 * 7.1.0.1 - Автоматического преобразования типов при перегрузке методов
 *
 * При вызове перегружаемого метода в Java
 * обнаруживается соответствие аргументов,
 * использованных для вызова метода,
 * а также его параметров.
 *
 * Но это соответствие совсем не обязательно должно быть полным.
 * Иногда важную роль в разрешении перегрузки
 * может играть автоматическое преобразование типов в Java.
 *
 * Пример 1.1, 1.2:
 * Применить автоматическое преобразование типов к перегрузке.
 *
 * Результат выполнения программы:
 * Параметры отсутствуют
 * a и b = 10 20
 * Внутреннее преобразование при вызове  test(double) a = 88.0
 * Внутреннее преобразование при вызове  test(double) a = 123.2
 *
 * 1) В данной версии класса OverloadDemo
 *    перегружаемый вариант метода test(int) не определен.
 *
 *    Поэтому при вызове метода test() с целочисленным аргументом
 *    в классе Overload2 отсутствует соответствующий метод.
 *
 * 2) Может быть автоматически выполнено
 *    преобразование типа integer в тип double,
 *    чтобы разрешить вызов нужного варианта данного метода.
 *
 * 3) Если вариант метода test(int) не обнаружен,
 *    тип переменной i автоматически продвигается в Java к типу double,
 *    а затем вызывается вариант метода test(double).
 *
 * 4) Если бы вариант метода test(int) был определен,
 *    то был бы вызван именно он.
 *
 * 5) Автоматическое преобразование типов в Java
 *    выполняется только в том случае,
 *    если не обнаружено полное соответствие.
 *
 * 6) Перегрузка методов поддерживает полиморфизм,
 *    поскольку это один из способов реализации в Java
 *    принципа "один интерфейс, несколько методов".
 *
 * 7) В тех языках программирования,
 *    где перегрузка методов не поддерживается,
 *    каждому методу должно быть присвоено однозначное имя.
 *
 *    Но зачастую требуется реализовать,
 *    один и тот же метод для разных типов данных.
 *
 *
 * Пример 2:
 * Функция вычисляющая абсолютное значение.
 *
 * Обычно в тех языках программирования,
 * где перегрузка методов не поддерживается,
 * существуют 3 или больше варианта этой функции
 * с несколько отличающимися именами.
 *
 * язык С:
 * функция abs()  - возвращает абсолютное значение типа integer,
 * функция labs() - возвращает абсолютное значение типа long integer,
 * функция fabs() - возвращает абсолютное значение с плавающей точкой.
 *
 * В языке С перегрузка не поддерживается,
 * и поэтому у каждой из этих функций должно быть свое имя,
 * несмотря на то, что все 3 функции
 * выполняют одно и то же действие.
 *
 * В итоге ситуация становится более сложной,
 * чем могла быть:
 *
 * Несмотря на то, что каждая функция
 * построена по одному и тому же принципу,
 * программирующему на С приходится помнить
 * 3 разных имени одной и той же функции.
 *
 * В языке Java подобная ситуация не возникает,
 * поскольку все методы вычисления абсолютного значения
 * могут называться одинаково.
 *
 * В состав стандартной библиотеки классов Java входит метод abs(),
 * для вычисления абсолютного значения.
 *
 * Перегружаемые варианты этого метода
 * для обработки всех числовых типов данных
 * определены во встроенном в Java классе Math.
 *
 * И в зависимости от типа аргумента в Java
 * вызывается нужный вариант метода abs().
 *
 * ВАЖНО!
 * Перегрузка методов ценна тем,
 * что позволяет обращаться
 * к похожим методам по общему имени.
 *
 * Имя abs() представляет общее действие,
 * которое должно выполняться.
 *
 * Выбор подходящего варианта метода
 * для конкретной ситуации
 * входит в обязанности компилятора,
 * а программисту нужно лишь запомнить
 * общее выполняемое действие.
 *
 * Полиморфизм позволяет свести несколько имен к одному.
 *
 * Приведенный пример 1.1, 1.2 прост,
 * но если расширить продемонстрированный в нем принцип,
 * можно убедиться, что перегрузка
 * позволяет упростить решение более сложных задач.
 *
 * При перегрузке метода каждый его вариант
 * может выполнять любые требующиеся действия.
 *
 * Не существует правила, согласно которому
 * перегружаемые методы должны быть связаны друг с другом.
 *
 * Но со стилистической точки зрения
 * перегрузка методов предполагает определенную их связь.
 *
 * И хотя одно и то же имя можно было бы употребить
 * для перегрузки несвязанных методов,
 * делать этого все же не следует.
 *
 * Имя sqr можно было бы употребить
 * для создания методов возвращающих:
 *  - квадрат целочисленного значения;
 *  - квадратный корень числового значения с плавающей точкой.
 *
 * Но эти 2 операции принципиально различны.
 *
 * Такое применение перегрузки методов
 * противоречит ее первоначальному назначению.
 *
 * Поэтому на практике перегружать следует
 * только тесно связанные операции.
 */

// Пример 1.1:
class OverloadDemo {

    void test() {
        System.out.println("Параметры отсутствуют");
    }

    // Перегружаемый метод, проверяющий наличие
    // двух целочисленных параметров
    void test(int a, int b) {
        System.out.println("a и b = " + a + " "+ b);
    }

    // Перегружаемый метод, проверяющий наличие
    // параметра типа double
    void test(double a) {
        System.out.println("Внутреннее преобразование при вызове " +
                " test(double) a = " + a);
    }
}

// Пример 1.2:
class Overload2 {
    public static void main(String[] args) {
        OverloadDemo obj = new OverloadDemo();

        // Объявляем переменную типа int
        int i = 88;

        // здесь вызывается вариант
        // метода без параметров
        obj.test();

        // здесь вызывается вариант
        // метода test(int, int)
        obj.test(10, 20);

        // здесь вызывается вариант
        // метода test(double)
        obj.test(i);

        // и здесь вызывается вариант
        // метода test(double)
        obj.test(123.2);
    }
}