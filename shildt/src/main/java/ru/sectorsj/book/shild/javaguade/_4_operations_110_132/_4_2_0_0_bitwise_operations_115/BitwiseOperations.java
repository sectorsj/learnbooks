package ru.sectorsj.book.shild.javaguade._4_operations_110_132._4_2_0_0_bitwise_operations_115;

/**
 * 4.2.0.0 - Поразрядные операции
 *
 * В языке Java определяется несколько поразрядных операций (табл. 4.2),
 * которые можно выполнять над целочисленными типами данных:
 *  - long
 *  - int
 *  - short
 *  - char
 *  - byte
 * Эти операции воздействуют
 * на отдельные двоичные разряды операндов.
 * ___________________________________________________________________________________
 * |   Операция  |                 Описание                                          |
 * |-------------|------------------------------------------------------------------ |
 * |      ~      |   Поразрядная унарная операция НЕ                                 |
 * |      &      |   Поразрядная логическая операция И                               |
 * |      |      |   Поразрядная логическая операция ИЛИ                             |
 * |      ^      |   Поразрядная логическая операция исключающее ИЛИ                 |
 * |     >>      |   Сдвиг вправо                                                    |
 * |     >>>     |   Сдвиг вправо с заполнением нулями                               |
 * |     <<      |   Сдвиг влево                                                     |
 * |     &=      |   Поразрядная логическая операция И с присваиванием               |
 * |     |=      |   Поразрядная логическая операция ИЛИ с присваиванием             |
 * |     ^=      |   Поразрядная логическая операция исключающее ИЛИ с присваиванием |
 * |     >>=     |   Сдвиг вправо с присваиванием                                    |
 * |     >>>=    |   Сдвиг вправо с заполнением нулями и присваиванием               |
 * |     <<=     |   Сдвиг влево с присваиванием                                     |
 * |-------------|-------------------------------------------------------------------|
 *
 * Поразрядные операции
 * манипулируют двоичными разрядами (битами)
 * в целочисленном значении.
 *
 * Какое влияние подобные манипуляции
 * могут оказывать на целочисленное значение?
 *
 * ВАЖНО!
 * 1) Каким образом целочисленные значения
 *    хранятся в исполняющей среде Java?
 * 2) Как в ней представляются отрицательные числа.
 *
 * 2 важных вопроса:
 * 1) Все целочисленные типы данных
 *    представлены двоичными числами разной длины.
 *    Пример 1:
 *    десятичное значение 42 типа byte
 *    в двоичном представлении имеет вид:
 *      00101010
 *    Позиция каждого двоичного разрядного
 *    представляет степень числа 2:
 *    а) начиная с 2⁰ в крайнем справа разряде.
 *    б) двоичный разряд на следующей позиции
 *       представляет степень числа 2¹ = 2.
 *    в) следующий 2² = 4,
 *    г) затем 8, 16, 32 и т.д.
 *
 *    Двоичное представление числа 42
 *    содержит единичные двоичные разряды
 *    на позициях 1, 3 и 5,
 *    начиная с О на крайней справа позиции.
 *
 *     0  0  1  0  1  0  1  0 => 42
 *    -----------------------
 *    2⁰ 2⁰ 2⁵ 2⁰ 2³ 2⁰ 2¹ 2⁰ => 42
 *
 *    42 => 2¹ + 2³ + 2⁵ => 2 + 8 + 32 => 42
 *
 * 2) Все целочисленные типы данных
 *    (за исключением char)
 *    представлены со знаком.
 *
 * Они могут представлять:
 *  - положительные
 *  - отрицательные
 * целочисленные значения.
 *
 * Отрицательные числа В Java:
 * представлены в дополнительном коде, путем:
 *
 * а) инвертирования
 *    (изменения 1 на О, и наоборот)
 *    всех двоичных разрядов
 *    исходного значения
 * б) с последующим добавлением 1 к результату.
 *
 * Пример 2:
 * получение числа -42 из числа 42
 * а) выбор значения = 42
 * б) инвертирования всех двоичных разрядов числа 42,
 * в) это дает двоичное значение 1101 0101,
 * г) к результату добавляется 1 (0000 0001),
 * д) это дает двоичное значение 1101 0110, или -42 в десятичной форме.
 *
 * а) 0010 1010 = 42
 * в) 1101 0101 = результат инверсии
 * д) 1101 0110 = -42
 *
 * Получение положительного числа из отрицательного:
 * 1) инвертировать все его двоичные разряды,
 * 2) добавить 1 (0000 0001) к результату.
 *
 * Пример:
 * а) инвертирование числа -42,
 *    или 1101 0110 в двоичной форме,
 * б) это дает двоичное значение 0010 1001,
 *    или 41 в десятичной форме,
 * в) после добавления к нему 1 (0001)
 *
 * г) получается число 42.
 *
 * Процесс перехода через нуль:
 *
 * 1) Если значение типа byte, то "0" (ноль)
 *    представлен значением 0000 0000.
 *
 * 2) Для получения его обратного кода
 *    нужно инвертировать все его двоичные разряды
 *
 * 3) Получается двоичное значение 1111 1111,
 *    которое представляет отрицательный ноль.
 *
 * 4) Отрицательный нуль недопустим
 *    в целочисленной математике.
 *
 * Выходом из этого затруднения служит
 * дополнительный код
 * для представления отрицательных чисел.
 *
 * 5) К обратному коду
 *    нулевого значения добавляется 1
 *    (0000 0001)
 *
 * 6) Получается двоичное значение 0001 0000 0000.
 *
 * 7) Старший единичный разряд
 *    оказывается сдвинутым влево слишком далеко,
 *    чтобы уместиться в значении типа byte.
 *    (0000 0000)
 *
 * 8) Тем самым достигается требуемое поведение,
 *    когда значения:
 *    -0 и 0 равнозначны,
 *    а 11111111 - двоичный код значения -1.
 *
 * ВАЖНО!!
 * В данном случае используется значение типа byte,
 * но тот же самый принцип можно применить
 * ко всем целочисленным типам данных в Java.
 *
 * 1) Для хранения отрицательных значений
 *    в Java используется дополнительный код,
 *
 * 2) Все целочисленные значения представлены со знаком,
 *
 * 3) Выполнение поразрядных операций
 *    может легко привести к неожиданным результатам.
 *
 * 4) установка 1 в самом старшем двоичном разряде
 *    может привести к тому,
 *    что получающееся в итоге значение
 *    будет интерпретироваться как отрицательное число,
 *    независимо от того,
 *    какого именно результата предполагалось добиться.
 *
 * ВАЖНО!!!
 * Старший двоичный разряд
 * определяет знак целого числа
 * независимо от того,
 * как он был установлен.
 */
public class BitwiseOperations {
}




/**
 * "~" - Поразрядная унарная операция НЕ
 *       или "поразрядное отрицание",
 *       инвертируя все двоичные разряды своего операнда.
 *       Например, число 42, представленное
 *       в следующей двоичной форме: 00101010
 *       преобразуется в результате выполнения поразрядной
 *       унарной операция НЕ
 *       в следующую форму: 11010101
 *
 * "&" - Поразрядная логическая операция И
 *       При выполнении поразрядной логической операции И, обозначаемой знаком
 *       &:, в двоичном разряде результата устанавливается 1 лишь в том случае,
 *       если соответствующие двоичные разряды в операндах также равны 1.
 *       Во всех остальных случаях в двоичном разряде результата устанавливается О,
 *            00101010    42
 *       &    00001111    15
 *       __________________
 *            00001010    10
 *
 * "|" - Поразрядная логическая операция ИЛИ
 *       При выполнении поразрядной логической операции ИЛИ, обозначаемой знаком 1,
 *       в двоичном разряде результата устанавливается 1,
 *       если соответствующий двоичный разряд в любом из операндов равен 1,
 *            00101010    42
 *       |    00001111    15
 *       -------------------
 *            00101111    47
 *
 * "^" - Поразрядная логическая операция исключающее ИЛИ
 *       При выполнении поразрядной логической операции исключающее ИЛИ,
 *       обозначаемой знаком ^, в двоичном разряде результата устанавливается 1,
 *       если двоичный разряд только в одном из операндов равен 1,
 *       а иначе в двоичном разряде результата устанавливается О.
 *            00101010    42
 *       ^    00001111    15
 *       -------------------
 *            00100101    37
 *
 *       Пример:
 *       особенность поразрядной логической операции исключающее ИЛИ.
 *
 *       1) Когда в двоичном разряде 2го операнда установлена "1".
 *          происходит инвертирование последовательности
 *          двоичных разрядов числа 42.
 *
 *       2) Когда в двоичном разряде 2го операнда установлен "0",
 *          двоичный разряд 1го операнда остается без изменения.
 *
 *       Этим свойством удобно пользоваться
 *       при манипулировании отдельными битами
 *       числовых значений.
 */
class BitWise{

}