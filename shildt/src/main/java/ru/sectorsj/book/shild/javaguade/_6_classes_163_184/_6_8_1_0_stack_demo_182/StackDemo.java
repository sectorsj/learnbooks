package ru.sectorsj.book.shild.javaguade._6_classes_163_184._6_8_1_0_stack_demo_182;


/**
 * 6.8.1.0 - Пример использования Stack.
 *
 * Пример 1.1:
 * Класс Stack, реализует стек емкостью
 * до 10 целочисленных значений.
 *
 * Результат выполнения программы:
 * Содержимое стека myStack1:
 * 9
 * 8
 * 7
 * 6
 * 5
 * 4
 * 3
 * 2
 * 1
 * 0
 * Содержимое стека myStack2:
 * 19
 * 18
 * 17
 * 16
 * 15
 * 14
 * 13
 * 12
 * 11
 * 10
 *
 *
 * 1) В классе Stack определены:
 *     - 2 элемента данных
 *     - 3 метода
 *
 * 2) Стек целочисленных значений хранится
 *    в переменной массива:
 *     stck[]
 *
 * 3) Массив stck[] индексируется по переменной "tos",
 *    которая всегда содержит индекс вершины стека.
 *
 * 4) В конструкторе Stack()
 *    переменная "tos" инициализируется значением -1,
 *    обозначающим "пустой" стек.
 *
 * 5) Доступ к стеку осуществляется
 *    с помощью методов:
 *    - push()
 *    - рор()
 *
 * 6) push() - метод для размещения элемент в стеке.
 *
 * 7) рор() - метод для извлечения элемента из стека,
 *
 * Т.к. доступ к стеку осуществляется с помощью методов push() и рор()
 * для обращения со стеком не имеет никакого значения,
 * что стек хранится в массиве.
 *
 * Стек можно хранить и в более сложной структуре данных
 * вроде связного списка,
 * но интерфейс, определяемый методами push() и рор(),
 * оставался бы без изменения.
 *
 * Пример 1.2:
 * Демонстрация применение класса Stack
 *
 * 1) Организуются 2 целочисленных стека,
 *    в каждом из которых сначала размещаются,
 *    а затем извлекаются некоторые значения.
 *
 * 2) Содержимое 2х стеков отличается.
 *
 * ВАЖНО!
 * Замечание по поводу класса Stack (пример 1.1).
 *
 * В том виде, в каком он здесь реализован,
 * массив stck, содержащий стек,
 * может быть изменен из кода,
 * определенного за пределами класса Stack.
 *
 * Это делает класс Stack уязвимым к
 *  - злоупотреблениям
 *  - повреждениям
 *
 * В дальнейшем необходимо исправить этот недостаток.
 */

// Пример 1.1:
class Stack {

    // Создаем массив с именем stck и размерностью 10.
    int stck[] = new int[30];
    int tos;
    int overflow;

    // Инициализируем вершину стека
    Stack() {
        tos = -1;
    }

    // Разместить элемент в стеке
    void push(int item) {
        overflow = stck.length;
        if (tos == overflow)
            System.out.println("Стек переполнен");
        else
            stck[++tos] = item;
    }

    // Извлечь элемент из стека
    int pop() {
        if(tos < 0) {
            System.out.println("Стек не загружен.");
            return 0;
        }
        else
            return stck[tos--];
    }
}

// Пример 1.2:
class StackDemo {
    public static void main(String[] args) {

        Stack myStack1 = new Stack();
        Stack myStack2 = new Stack();

        // Разместить числа в стеке
        for (int i = 0; i < 10; i++) {
            myStack1.push(i);
        }
        for (int i = 10; i < 20; i++) {
            myStack2.push(i);
        }

        // Извлечение размещенных чисел из стека
        System.out.println("Содержимое стека myStack1: ");
        for (int i = 0; i < 10; i++) {
            System.out.println(myStack1.pop());
        }

        System.out.println("Содержимое стека myStack2: ");
        for (int i = 0; i < 10; i++) {
            System.out.println(myStack2.pop());
        }
    }
}