package ru.sectorsj.book.shild.javaguade._3_data_types_vars_arrays_79_109._3_2_1_0_int_literals_87;

/**
 * 3.2.1.0 - Целочисленные литералы
 *
 * Целочисленный тип чаще всего употребляется в обычных программах.
 *
 * Любое целочисленное значение является числовым литералом.
 *
 * В целочисленных литералах могут употребляться
 * числа по следующим основаниям:
 *
 * 1) восьмеричные (по основанию 8)
 *    эти числа в Java обозначаются начальным нулем
 *    Вполне допустимое, значение 09
 *    приводит к ошибке компиляции,
 *    поскольку значение 9 выходит за пределы
 *    допустимых восьмеричных значений от 0 до 7.
 *
 * 2) десятичные (по основанию 10)
 *    эти числа не могут содержать начальный нуль.
 *
 *    Примером десятичных литералов могут служить значения:
 *      1, 2, 3 и 42.
 *    т.к. они описывают числа по основанию 10.
 *
 * 3) шестнадцатеричные (по основанию 16)
 *    Программисты часто пользуются
 *    шестнадцатеричным представлением чисел,
 *    которое соответствует словам,
 *    равным по длине:
 *       8, 16, 32 и 64 бит
 *    и состоящим из 8-разрядных блоков.
 *    Значения шестнадцатеричных констант
 *    обозначают начальным нулем и символом х (0x или 0X).
 *
 *    Шестнадцатеричные цифры должны
 *    указываться в пределах
 *      от 0 до 15,
 *    эти цифры заменяют буквами
 *      от А до F (или от a до f).
 *
 * Целочисленные литералы создают значение типа int,
 * которое в Java является 32-битовым целочисленным значением.
 *
 * Язык Java строго типизированный,
 * и в связи с этим может возникнуть вопрос:
 *
 * Каким образом присвоить целочисленный литерал
 * одному из других целочисленных типов данных,
 * например byte или long,
 * не приводя к ошибке несоответствия типов?
 *
 * Ответ:
 * 1) Когда значение литерала присваивается
 *    переменной типа byte или short,
 *    ошибки не происходит, если значение литерала
 *    находится в диапазоне допустимых значений данного типа.
 *
 * 2) Целочисленный литерал всегда
 *    можно присвоить переменной типа long.
 *
 * 3) Чтобы обозначить литерал типа long,
 *    придется явно указать компилятору,
 *    что значение литерала имеет этот тип.
 *
 *    С этой целью литерал дополняется
 *    строчной или прописной буквой L.
 *
 *    Пример 1:
 *    Значения:
 *      - 0x7ffffffffffffffL
 *                или
 *      - 9223372036854775807L
 *    является наибольшим литералом типа long.
 *
 * Целочисленное значение типа long
 * можно также присвоить переменной типа char,
 * если оно находится в пределах
 * допустимых значений данного типа.
 *
 * Начиная с версии JDK 7:
 * 1) целочисленные литералы можно
 *    определить и в двоичной форме.
 *
 *    Для этого перед присваиваемым значением
 *    указывается префикс:
 *     0b или 0B.
 *
 *    Пример 2:
 *    в следующей строке кода
 *    десятичное значение 10
 *    определяется с помощью двоичного литерала:
 *    int х = 0b1010;
 *
 *    Наличие двоичных литералов
 *    облегчает также ввод значений,
 *    употребляемых в качестве битовых масок.
 *
 *    В таком случае десятичное (или шестнадцатеричное)
 *    представление значения внешне не передает его назначение,
 *    тогда как двоичный литерал передает его.
 *
 * 2) в обозначении целочисленных литералов
 *    можно также указывать один или несколько
 *    знаков подчеркивания.
 *
 *    Это облегчает чтение крупных целочисленных литералов.
 *
 *    При компиляции знаки подчеркивания
 *    в литерале игнорируются.
 *
 *    Пример 3:
 *      int х = 123_456_789;
 *    переменной х присваивается значение 123456789,
 *    а знаки подчеркивания игнорируются.
 *
 *    Эти знаки могут употребляться только для разделения цифр.
 *
 *    Их нельзя указывать в начале или в конце литерала,
 *    но вполне допускается между двумя цифрами,
 *    причем не один, а несколько.
 *
 *    Пример 4:
 *    следующая строка кода считается вполне допустимой:
 *      int х = 123__456__789;
 *    Пользоваться знаками подчеркивания
 *    в целочисленных литералах особенно удобно
 *    при указании в прикладном коде таких элементов,как :
 *    - номера телефонов,
 *    - идентификационные номера клиентов,
 *    - номера деталей узлов и т.д.
 *    Они также полезны для визуальных группировок
 *    при определении двоичных литералов.
 *
 *    Пример 5:
 *    двоичные значения зачастую визуально группируются
 *    в блоки по четыре цифры:
 *      int х = 0b1101_0101_0001_1010;
 */
public class IntLiterals {
    // Пример 2:
    int х1 = 0b1010;

    // Пример 3:
    int х2 = 123_456_789;

    // Пример 4:
    int х3 = 123__456__789;

    // Пример 5:
    int х4 = 0b1101_0101_0001_1010;
}
