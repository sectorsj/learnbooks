package ru.sectorsj.book.shild.javaguade._4_operations_110_132._4_2_4_1_byte_u_shift_121;

/**
 * Пример 1:
 * В результате беззнакового сдвига вправо двоичных разрядов
 * значения типа byte можно было бы ожидать заполнения нулями,
 * начиная с 7-й позиции,
 * но на самом деле этого не происходит,
 * поскольку сдвиг вправо
 * выполняется в 32-разрядном значении.
 *
 * Результат выполнения программы:
 * b               = Oxf1
 * b >> 4          = 0xff
 * b >>> 4         = 0xff
 * (b & 0xff) >> 4 = 0x0f
 * Как следует из результата выполнения данной программы,
 * операция >>> не оказывает никакого воздействия на значения типа byte.
 *
 * 1) переменной "b" присваивается
 *    произвольное отрицательное значение типа byte.
 * 2) переменной "c" присваивается значение
 *    переменной "b" типа byte,
 *    сдвинутое на четыре позиции вправо и равное "0хff"
 *    вследствие расширения знака.
 * 3) переменной "d" присваивается значение
 *    переменной "b" типа byte,
 *    сдвинутое на четыре позиции вправо без знака.
 *
 *    Это значение должно было бы быть равно 0х0f,
 *    но оно оказывается равным 0xff из-за расширения знака,
 *    которое произошло при продвижении типа переменной "b"
 *    к типу int перед сдвигом.
 * 4) переменной "е" присваивается значение
 *    переменной "b" типа byte,
 *    сначала замаскированное до 8 двоичных разрядов
 *    с помощью поразрядной логической операции И,
 *    а затем сдвинутое вправо на четыре позиции.
 *
 *    Получается предполагаемое значение 0х0f.
 *
 *    Операция беззнакового сдвига вправо
 *    не применяется к значению переменной "d",
 *    поскольку состояние знакового двоичного разряда
 *    известно после выполнения поразрядной логической операции И.
 */
public class ByteUShift {
    public static void main(String[] args) {
        // Пример 1:
        char hex [] = {
                '0', '1', '2', '3', '4', '5', '6', '7',
                '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'
        };
        byte b = (byte) 0xf1;
        byte c = (byte) (b >> 4);
        byte d = (byte) (b >> 4);
        byte e = (byte) ((b & 0xff) >> 4);

        System.out.println("b = 0x"                 + hex[(b >> 4) & 0x0f] + hex[b & 0x0f]);
        System.out.println("b >> 4 = 0x"            + hex[(c >> 4) & 0x0f] + hex[c & 0x0f]);
        System.out.println("b >>> 4 = 0x"           + hex[(d >> 4) & 0x0f] + hex[d & 0x0f]);
        System.out.println("(b & 0xff) >> 4 = 0x"   + hex[(e >> 4) & 0x0f] + hex[e & 0x0f]);
    }
}