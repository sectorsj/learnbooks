надстрочный (⁰, ¹, ², ³, ⁴, ⁵, ⁶, ⁷, ⁸, ⁹, ⁱ)
подстрочные (₀, ₁, ₂, ₃, ₄, ₅, ₆, ₇, ₈, ₉, ₙ, ₐ, ₓ)


    Часть 1. Язык Java
        Глава 1. История и развитие языка Java
            1.1 Происхождение Java
                1.1.1 Зарождение современного программирования: язык С
                1.1.2 Следующий этап: язык С++
                1.1.3 Предпосылки к созданию Java
            1.2 Создание языка Java
                1.2.1 Связь с языком С#
            1.3 Каким образом язык Java повлиял на Интернет
                1.3.1 Аплеты на Java
                1.3.2 Безопасность
                1.3.3 Переносимость
            1.4 Чудо Java: байт-код
            1.5 Выход за пределы аплетов
            1.6 Сервлеты: серверные программы на Java
            1.7 Терминология Java
                1.7.1 Простота
                1.7.2 Объектная ориентированность
                1.7.3 Надежность
                1.7.4 Многопоточность
                1.7.5 Архитектурная нейтральность
                1.7.6 Интерпретируемость и высокая производительность
                1.7.7 Распределенность
                1.7.8 Динамичность
            1.8 Эволюция языка Java
            1.9 Версия Java SE 9
            1.10 Культура нововведений

        Глава 2. Краткий обзор Java
            2.1 Объектно-ориентированное программирование
                2.1.1 Две парадигмы
                2.1.2 Абстракция
                2.1.3 Три принципа ООП
            2.2 Первый пример простой программы
                2.2.1 Ввод кода программы
                2.2.2 Компиляция программы
                2.2.3 Подробный анализ первого примера программы
            2.3 Второй пример короткой программы
            2.4 Два управляющих оператора
                2.4.1 Условный оператор if
                2.4.2 Оператор цикла for
            2.5 Применение блоков кода
            2.6 Вопросы лексики
                2.6.1 Пробелы
                2.6.2 Идентификаторы
                2.6.3 Литералы
                2.6.4 Комментарии
                2.6.5 Разделители
                2.6.6 Ключевые слова Java
            2.7 Библиотеки классов Java

        Глава 3. Типы данных, переменные и массивы
            3.1 Java - строго типизированный язык
            3.2 Примитивные типы
            3.3 Целые числа
                3.3.1 Тип byte
                3.3.2 Тип short
                3.3.3 Тип int
                3.3.4 Тип long
            3.4 Числа с плавающей точкой
               3.4.1 Тип float
               3.4.2 Тип double
            3.5 Символы
            3.6 Логические значения
            3.7 Подробнее о литералах
                3.7.1 Целочисленные литералы
                3.7.2 Литералы с плавающей точкой
                3.7.3 Логические литералы
                3.7.4 Символьные литералы
                3.7.5 Строковые литералы
            3.8 Переменные
                3.8.1 Объявление переменной
                3.8.2 Динамическая инициализация
                3.8.3 Область видимости и срок действия переменных
            3.9 Преобразование и приведение типов
                3.9.1 Автоматическое преобразование типов в Java
                3.9.2 Приведение несовместимых типов
            3.10 Автоматическое продвижение типов в выражениях
                3.10.1 Правила продвижения типов
            3.11 Массивы
                3.11.1 Одномерные массивы
                3.11.2 Многомерные массивы
                3.11.3 Альтернативный синтаксис объявления массивов
            3.12 Введение в символьные строки
    
        Глава 4. Операции
            4.1 Арифметические операции
                4.1.1 Основные арифметические операции
                4.1.2 Операция деления по модулю
                4.1.3 Составные арифметические операции с присваиванием
                4.1.4 Операции инкремента и декремента
            4.2. Поразрядные операции
                4.2.1 Поразрядные логические операции
                4.2.2 Сдвиг влево
                4.2.3 Сдвиг вправо
                4.2.4 Беззнаковый сдвиг вправо
                4.2.5 Поразрядные составные операции с присваиванием
            4.3 Операции отношения
            4.4 Логические операции
                4.4.1 Укороченные логические операции
            4.5 Операция присваивания
                4.5.1 Тернарная операция ?
            4.6 Предшествование операций
            4.7 Применение круглых скобок
    
        Глава 5.
            5.1 Управляющие операторы
                5.1.1 Операторы выбора
                5.1.2 Условный оператор if
            5.2 Оператор switch
                5.2.1 Операторы цикла Цикл while
                5.2.2 Цикл do-while
                5.2.3 Цикл for
                5.2.4 Вложенные циклы
            5.3 Операторы перехода
                5.3.1 Применение оператора break
                    5.3.1.1
                    5.3.1.2
                    5.3.1.3
                    5.3.1.4
                    5.3.1.5
                    5.3.1.6
                5.3.2 Применение оператора continue
                5.3.3 Оператор return
    
        Глава 6. Введение в классы
            6.1 Основы классов
                6.1.1 Общая форма класса
                6.1.2 Простой класс
            6.2 Объявление объектов
                6.2.1 Подробное рассмотрение операции new
            6.3 Присваивание переменным ссылок на объекты
            6.4 Введение в методы
                6.4.1 Ввод метода в класс Вох
                6.4.2 Возврат значений
                6.4.3 Ввод метода, принимающего параметры
            6.5 Конструкторы
                6.5.1 Пример использования конструктора
                6.5.2 Параметризированные конструкторы
            6.6 Ключевое слово this
                6.6.1 Сокрытие переменных экземпляра
            6.7 Сборка "мусора"
            6.8 Класс Stack
                6.8.1.0 Пример использования Stack
    
        Глава 7. Подробное рассмотрение классов и методов
            7.1 Перегрузка методов
                7.1.1 Автоматического преобразования типов при перегрузке методов
                7.1.2 Перегрузка конструкторов
            7.2 Применение объектов в качестве параметров
                7.2.1
            7.3 Подробное рассмотрение особенностей передачи аргументов
                7.3.1 Передача объекта при вызове по значению
                7.3.2 Передача объекта при вызове по ссылке
            7.4 Возврат объектов
            7.5 Рекурсия
                7.5.1 Вычисление факториала числа
                    7.5.1.1 Пример организации рекурсии
            7.6 Введение в управление доступом
                7.6.1 Управление доступом к отдельному классу
                    7.6.1.1 Влияние организации открытого и закрытого доступа
            7.7 Ключевое слово static
            7.8 Ключевое слово final
            7.9 Еще раз о массивах
            7.10 Вложенные и внутренние классы
            7.11 Краткий обзор класса String
            7.12 Применение аргументов командной строки
            7.13 Аргументы переменной длины
                7.13.1 Перегрузка методов с аргументами переменной длины
                7.13.2 Аргументы переменной длины и неоднозначность
    
        Глава 8. Наследование
            8.1 Основы наследования
                8.1.1 Доступ к членам класса и наследование
                8.1.2 Практический пример наследования
                8.1.3 Переменная из суперкласса может ссылаться на объект подкласса
            8.2 Ключевое слово super
                8.2.1 Вызов конструкторов суперкласса с помощью ключевого слова super
                8.2.2 Другое применение ключевого слова super
            8.3 Создание многоуровневой иерархии
            8.4 Порядок вызова конструкторов
            8.5 Переопределение методов
            8.6 Динамическая диспетчеризация методов
                8.6.1 Назначение переопределенных методов
                8.6.2 Применение переопределения методов
            8.7 Применение абстрактных классов
            8.8 Ключевое слово final в сочетании с наследованием
                8.8.1 Предотвращение переопределения с помощью ключевого слова final
                8.8.2 Предотвращение наследования с помощью ключевого слова final
            8.9 Класс Object
    
        Глава 9. Пакеты и интерфейсы
            9.1 Пакеты
                9.1.1 Определение пакета
                9.1.2 Поиск пакетов и переменная окружения CLASSPATH
                9.1.3 Краткий пример пакета
            9.2 Доступ к пакетам и его компонентам
                9.2.1 Пример доступа к пакетам
            9.3 Импорт пакетов Интерфейсы
                9.3.1 Объявление интерфейса
                9.3.2 Реализация интерфейсов
                9.3.3 Вложенные интерфейсы
                9.3.4 Применение интерфейсов
                9.3.5 Переменные в интерфейсах
                9.3.6 Расширение интерфейсов
            9.4 Методы с реализацией по умолчанию
               9.4.1 Основы применения методов с реализацией по умолчанию
               9.4.2 Прикладной пример
               9.4.3 Вопросы множественного наследования
            9.5 Применение статических методов в интерфейсе
            9.6 Закрытые методы интерфейсов
            9.7 Заключительные соображения по поводу пакетов и интерфейсов
    
        Глава 10. Обработка исключений
            10.1 Основы обработки исключений
            10.2 Типы исключений
            10.3 Необрабатываемые исключения
            10.4 Применение блоков операторов try и catch
                10.4.1 Вывод описания исключения
            10.5 Применение нескольких операторов catch
            10.6 Вложенные операторы try
            10.7 Оператор throw
            10.8 Оператор throws
            10.9 Оператор finally
            10.10 Встроенные в Java исключения
            10.11 Создание собственных подклассов исключений
            10.12 Цепочки исключений
            10.13 Дополнительные средства для обработки исключений
            10.14 Применение исключений
    
        Глава 11. Многопоточное программирование
            11.1 Модель потоков исполнения в Java
                11.1.1 Приоритеты потоков
                11.1.2 Синхронизация
                11.1.3 Обмен сообщениями
                11.1.4 Класс Thread и интерфейс Runnable
            11.2 Главный поток исполнения
            11.3 Создание потока исполнения
                11.3.1 Реализация интерфейса Runnable
                11.3.2 Расширение класса Thread
                11.3.3 Выбор способа создания потоков исполнения
            11.4 Создание многих потоков исполнения
            11.5 Применение методов isAlive() и join()
            11.6 Приоритеты потоков исполнения
            11.7 Синхронизация
                11.7.1 Применение синхронизированных методов
                11.7.2 Оператор synchronized
            11.8 Взаимодействие потоков исполнения
                11.8.1 Взаимная блокировка
            11.9 Приостановка, возобновление и остановка потоков исполнения
            11.10 Получение состояния потока исполнения
            11.11 Одновременное создание и запуск потоков исполнения фабричными методами
            11.12 Применение многопоточности
    
        Глава 12. Перечисления, автоупаковка и аннотации
            12.1 Перечисления
                12.1.1 Основные положения о перечислениях
                12.1.2 Методы values () и valueOf ()
                12.1.3 Перечисления в Java относятся к типам классов
                12.1.4 Перечисления наследуются от класса Enum
                12.1.5 Еще один пример перечисления
            12.2 Оболочки типов
                12.2.1 Класс Character
                12.2.2 Класс Boolean
                12.2.3 Оболочки числовых типов
            12.3 Автоупаковка
                12.3.1 Автоупаковка и методы
                12.3.2 Автоупаковка и автораспаковка в выражениях
                12.3.3 Автоупаковка и распаковка значений из классов Boolean и Character
                12.3.4 Автоупаковка и автораспаковка помогает предотвратить ошибки
                12.3.5 Предупреждение
            12.4 Аннотации
                12.4.1 Основы аннотирования программ
                12.4.2 Правила удержания аннотаций
                12.4.3 Получение аннотаций во время выполнения с помощью рефлексии
                12.4.4 Второй пример применения рефлексии
                12.4.5 Получение всех аннотаций
                12.4.6 Интерфейс AnnotatedElement
                12.4.7 Использование значений по умолчанию
                12.4.8 Маркерные аннотации
                12.4.9 Одночленные аннотации
                12.4.10 Встроенные аннотации
            12.5 Типовые аннотации
            12.6 Повторяющиеся аннотации
                12.6.1Некоторые ограничения на аннотации
    
        Глава 13. Ввод-вывод, оператор try с ресурсами и прочие вопросы
            13.1 Основы ввода-вывода
                13.1.1 Потоки ввода-вывода
                13.1.2 Потоки ввода-вывода байтов и символов
                13.1.3 Предопределенные потоки ввода-вывода
            13.2 Чтение данных, вводимых с консоли
                13.2.1 Чтение символов
                13.2.2 Чтение символьных строк
            13.3 Запись данных, выводимых на консоль
            13.4 Класс PrintWriter
            13.5 Чтение и запись данных в файлы
            13.6 Автоматическое закрытие файла
            13.7 Модификаторы доступа transient и volatile
            13.8 Применение операции instanceof
            13.9 Модификатор доступа strictfp
            13.10 Платформенно-ориентированные методы
            13.11 Применение ключевого слова assert
                13.11.1 Параметры включения и отключения режима проверки утверждений
            13.12 Статический импорт
            13.13 Вызов перегружаемых конструкторов по ссылке this()
            13.14 Компактные профили Java API
    
        Глава 14. Обобщения
            14.1 Что такое обобщения
            14.2 Простой пример обобщения
                14.2.1 Обобщения оперируют только ссылочными типами
                14.2.2 Обобщенные типы различаются по аргументам типа
                14.2.3 Каким образом обобщения повышают типовую безопасность
            14.3 Обобщенный класс с двумя параметрами типа
            14.4 Общая форма обобщенного класса
            14.5 Ограниченные типы
            14.6 Применение метасимвольных аргументов
                14.6.1 Ограниченные метасимвольные аргументы
            14.7 Создание обобщенного метода
                14.7.1 Обобщенные конструкторы
            14.8 Обобщенные интерфейсы
            14.9 Базовые типы и унаследованный код
            14.10 Иерархии обобщенных классов
                14.10.1 Применение обобщенного суперкласса
                14.10.2 Обобщенный подкласс
                14.10.3 Сравнение типов в обобщенной иерархии во время выполнения
                14.10.4 Приведение типов
                14.10.5 Переопределение методов в обобщенном классе
            14.11 Выведение типов и обобщения
            14.12 Стирание
                14.12.1 Мостовые методы
            14.13 Ошибки неоднозначности
            14.14 Некоторые ограничения, присущие обобщениям
                14.14.1 Получить экземпляр по параметру типа нельзя
                14.14.2 Ограничения на статические члены
                14.14.3 Ограничения на обобщенные массивы
                14.14.4 Ограничения на обобщенные исключения
    
        Глава 15. Лямбда-выражения
            15.1 Введение в лямбда-выражения
                15.1.1 Основные положения о лямбда-выражениях
                15.1.2 Функциональные интерфейсы
                15.1.3 Некоторые примеры лямбда-выражений
            15.2 Блочные лямбда-выражения
            15.3 Обобщенные функциональные интерфейсы
            15.4 Передача лямбда-выражений в качестве аргументов
            15.5 Лямбда-выражения и исключения
            15.6 Лямбда-выражения и захват переменных
            15.7 Ссылки на методы
                15.7.1 Ссылки на статические методы
                15.7.2 Ссылки на методы экземпляра
                15.7.3 Ссылки на обобщенные методы
            15.8 Ссылки на конструкторы
            15.9 Предопределенные функциональные интерфейсы
    
        Глава 16. Модули
            16.1 Основные положения о модулях
                16.1.1 Простой пример модуля
                16.1.2 Компиляция и выполнение первого примера модульного приложения
                16.1.3 Подробное рассмотрение операторов requires и exports
            16.2 Модуль java.base и платформенные модули
            16.3 Унаследованный код и безымянные модули
            16.4 Экспорт в конкретный модуль
            16.5 Применение оператора requires transitive
            16.6 Применение служб
                16.6.1 Основные положения о службах и поставщиках их услуг
                16.6.2 Ключевые слова для поддержки служб
                16.6.3 Пример модульной службы
            16.7 Графы модулей
            16.8 Специальные средства модулей
                16.8.1 Открытые модули
                16.8.2 Оператор opens
                16.8.3 Оператор requires static
            16.9 Утилита jlink и модульные архивные JАR-файлы
               16.9.1 Связывание файлов в развернутом каталоге
               16.9.2 Связывание модульных архивных JАR-файлов
               16.9.3 Файлы формата JMOD
            16.10 Об уровнях и автоматических модулях
            16.11 Заключительные соображения по поводу модулей

    Часть 2. Библиотека Java
        Глава 17. Обработка символьных строк
            17.1 Конструкторы символьных строк
            17.2 Длина символьной строки
            17.3 Специальные строковые операции
                17.3.1 Строковые литералы
                17.3.2 Сцепление строк
                17.3.3 Сцепление символьных строк с другими типами данных
                17.3.4 Преобразование символьных строк и метод toString ()
            17.4 Извлечение символов
                17.4.1 Метод charAt()
                17.4.2 Метод getChars()
                17.4.3 Метод getBytes()
                17.4.4 Метод toCharArray()
            17.5 Сравнение символьных строк
                17.5.1 Методы
                    17.5.1.1 equals()
                    17.5.1.2 equalsignoreCase()
                17.5.2 Метод regionMatches()
                17.5.3 Методы
                    17.5.3.1 startsWith()
                    17.5.3.2 endsWith()
                17.5.4 Метод equals() в сравнении с операцией "=="
                17.5.5 Метод compareTo()
            17.6 Поиск в символьных строках
            17.7 Видоизменение символьных строк
                17.7.1 Метод substring()
                17.7.2 Метод concat()
                17.7.3 Метод replace()
                17.7.4 Метод trim()
            17.8 Преобразование данных методом valueОf()
            17.9 Смена регистра букв в строке
            17.10 Соединение символьных строк
            17.11 Дополнительные методы из класса String
            17.12 Класс StringBuffer
                17.12.1 Методы
                    17.12.1.1 length()
                    17.12.1.2 capacity()
                17.12.2 Метод ensureCapacity()
                17.12.3 Метод setLength()
                17.12.4 Методы
                    17.12.4.1 charAt()
                    17.12.4.2 setCharAt()
                17.12.5 Метод getChars()
                17.12.6 Метод append()
                17.12.7 Метод insert()
                17.12.8 Метод reverse()
                17.12.9 Методы
                    17.12.9.1 delete()
                    17.12.9.2 deleteCharAt()
                17.12.10 Метод replace()
                17.12.11 Метод substring()
                17.12.12 Дополнительные методы из класса StringBuffer
            17.13 Класс StringBuilder
    
        Глава 18. Пакет java. lang
            18.1 Оболочки примитивных типов
                18.1.1 Класс Number
                18.1.2 Классы
                    18.1.2.1 Double
                    18.1.2.2 Float
                18.1.3 Методы
                    18.1.3.1 isInfinite()
                    18.1.3.2 isNaN()
                18.1.4 Классы
                    18.1.4.1 Byte
                    18.1.4.2 Short
                    18.1.4.3 Integer
                    18.1.4.4 Long
                18.1.5 Класс Character
                18.1.6 Дополнения класса Character для поддержки кодовых точек в Юникоде
                18.1.7 Класс Boolean
            18.2 Класс Void
            18.3 Класс Process
            18.4 Класс Runtime
                18.4.1 Управление памятью
                18.4.2 Выполнение других программ
            18.5 Класс Runtime.Version
            18.6 Класс ProcessBuilder
            18.7 Класс System
                18.7.1 Измерение времени выполнения программы
                18.7.2 методом currentTimeMills()
                18.7.3 Применение метода arraycopy()
                18.7.4 Свойства окружения
            18.8 Интерфейс System.Logger и класс System.LoggerFinder
            18.9 Класс Object
            18.10 Применение
                18.10.1 метода clone()
                18.10.2 интерфейса Cloneable
            18.11 Класс Class
            18.12 Класс ClassLoader
            18.13 Класс Math
                18.13.1 Тригонометрические функции
                18.13.2 Экспоненциальные функции
                18.13.3 Функции округления
                18.13.4 Прочие методы из класса Math
            18.14 Класс StrictMath
            18.15 Класс Compiler
            18.16 Классы Thread, ThreadGroup, интерфейс Runnable
                18.16.1 Интерфейс Runnable
                18.16.2 Класс Thread
                18.16.3 Класс ThreadGroup
            18.17 Классы
                18.17.1 ThreadLocal
                18.17.2 InheritableThreadLocal
            18.18 Класс Package
            18.19 Класс Module
            18.20 Класс ModuleLayer
            18.21 Класс RuntimePermission
            18.22 Класс Throwable
            18.23 Класс SecurityManager
            18.24 Класс StackTraceElement
            18.25 Класс StackWalker и интерфейс StackWalker. StackFrame
            18.26 Класс Enum
    
        Глава 19. Пакет java.util (часть 1. Collections Framework)
            19.1 Краткий обзор коллекций
            19.2 Интерфейсы коллекций
                19.2.1 Интерфейс Collection
                19.2.2 Интерфейс List
                19.2.3 Интерфейс Set
                19.2.4 Интерфейс SortedSet
                19.2.5 Интерфейс NavigableSet
                19.2.6 Интерфейс Queue
                19.2.7 Интерфейс Dequeue
            19.3 Классы коллекций
                19.3.1 Класс ArrayList
                19.3.2 Класс LinkedList
                19.3.3 Класс HashSet
                19.3.4 Класс LinkedHashSet
                19.3.5 Класс TreeSet
                19.3.6 Класс PriorityQueue
                19.3.7 Класс ArrayDeque
                19.3.8 Класс EnumSet
            19.4 Доступ к коллекциям через итератор
                19.4.1 Применение интерфейса Iterator
                19.4.2 Цикл for в стиле for each как альтернатива итераторам
            19.5 Итераторы-разделители
            19.6 Сохранение объектов пользовательских классов в коллекциях
            19.7 Интерфейс RandomAccess
            19.8 Манипулирование отображениями
                19.8.1 Интерфейсы отображений
                19.8.2 Классы отображений
            19.9 Компараторы
                19.9.1 Применение компараторов
            19.10 Алгоритмы коллекций
            19.11 Массивы
            19.12 Унаследованные классы и интерфейсы
                19.12.1 Интерфейс Enumeration
                19.12.2 Класс Vector
                19.12.3 Класс Stack
                19.12.4 Класс Dictionary
                19.12.5 Класс Hashtable
                19.12.6 Класс Properties
                19.12.7 Применение методов
                        19.12.7.1 store()
                        19.12.7.2 load()
            19.13 Заключительные соображения по поводу коллекций

    Глава 20. Пакет java.util (часть 2. Прочие служебные классы)
        20.1 Класс StringTokenizer
        20.2 Класс BitSet
        20.3 Классы
            20.3.1 Optional
            20.3.2 OptionalDouЬle
            20.3.3 Optionalint
            20.3.4 OptionalLong
        20.4 Класс Date
        20.5 Класс Calendar
        20.6 Класс GregorianCalendar
        20.7 Класс TimeZone
        20.8 Класс SimpleTimeZone
        20.9 Класс Locale
        20.10 Класс Random
        20.11 Классы Timer и TimerTask
        20.12 Класс Currency
        20.13 Класс Formatter
            20.13.1 Конструкторы класса Formatter
            20.13.2 Методы из класса Formatter
            20.13.3 Основы форматирования
            20.13.4 Форматирование строк и символов
            20.13.5 Форматирование чисел
            20.13.6 Форматирование времени и даты
            20.13.7 Спецификаторы формата %n и%%
            20.13.8 Указание минимальной ширины поля
            20.13.9 Указание точности
            20.13.10 Применение признаков формата
            20.13.11 Выравнивание выводимых данных
            20.13.12 Признаки пробела, +, О и (
            20.13.13 Признак запятой
            20.13.14 Признак #
            20.13.15 Прописные формы спецификаторов формата
            20.13.16 Применение индекса аргумента
            20.13.17 Закрытие объекта типа Formatter
            20.13.18 Аналог функции printf() в Java
        20.14 Класс Scanner
            20.14.1 Конструкторы класса Scanner
            20.14.2 Основы сканирования
            20.14.3 Некоторые примеры применения класса Scanner
            20.14.4 Установка разделителей
            20.14.5 Прочие средства класса Scanner
        20.15 Классы
            20.15.1 ResourceBundle
            20.15.2 ListResourceBundle
            20.15.3 PropertyResourceBundle
        20.16 Прочие служебные классы и интерфейсы
        20.17 Подпакеты, входящие в состав пакета java.util
            20.17.1. Пакеты java.util.concurrent
                   20.17.1.1 java.util.concurrent.atomic
                   20.17.1.2 java.util.concurrent.locks
            20.17.2 Пакет java.util.function
            20.17.3 Пакет java.util.jar
            20.17.4 Пакет java.util.logging
            20.17.5 Пакет java.util.prefs
            20.17.6 Пакет java.util.regex
            20.17.7 Пакет java.util.spi
            20.17.8 Пакет java. util.stream
            20.17.9 Пакет java.util.zip

    Глава 21. Пакет java.io для ввода-вывода
        21.1 Классы и интерфейсы ввода-вывода
        21.2 Класс File
            21.2.1 Каталоги
            21.2.2 Применение интерфейса FilenameFilter
            21.2.3 Альтернативный метод ListFiles()
            21.2.4 Создание каталогов
        21.3 Интерфейсы AutoCloseable, Closeable и Flushable
        21.4 Исключения ввода-вывода
        21.5 Два способа закрытия потоков ввода-вывода
        21.6 Классы потоков ввода-вывода
        21.7 Потоки ввода-вывода байтов
            21.7.1 Класс InputStream
            21.7.2 Класс OutputStream
            21.7.3 Класс FileInputStream
            21.7.4 Класс FileOutputStream
            21.7.5 Класс ByteArrayInputStream
            21.7.6 Класс ByteArrayOutputStream
            21.7.7 Фильтруемые потоки ввода-вывода байтов
            21.7.8 Буферизованные потоки ввода-вывода байтов
            21.7.9 Класс SequenceInputStream
            21.7.10 Класс PrintStream
            21.7.11 Классы DataOutputStream и DataInputStream
            21.7.12 Класс RandomAccessFile
        21.8 Потоки ввода-вывода символов
            21.8.1 Класс Reader
            21.8.2 Класс Writer
            21.8.3 Класс FileReader
            21.8.4 Класс FileWriter
            21.8.5 Класс CharArrayReader
            21.8.6 Класс CharArrayWriter
            21.8.7 Класс BufferedReader
            21.8.8 Класс BufferedWriter
            21.8.9 Класс PushbackReader
            21.8.10 Класс PrintWriter
        21.9 Класс Console
        21.10 Сериализация
            21.10.1 Интерфейс Serializable
            21.10.2 Интерфейс Externalizable
            21.10.3 Интерфейс Obj ectOutput
            21.10.4 Класс ObjectOutputStream
            21.10.5 Интерфейс ObjectInput
            21.10.6 Класс ObjectInputStream
            21.10.7 Пример сериализации
        21.11 Преимущества потоков ввода-вывода

    Глава 22. Система ввода-вывода NIO
        22.1 Классы системы ввода-вывода NIO
        22.2 Основные положения о системе ввода-вывода NIO
            22.2.1 Буферы
            22.2.2 Каналы
            22.2.3 Наборы символов и селекторы
        22.3 Усовершенствования в системе NIO.2
            22.3.1 Интерфейс Path
            22.3.2 Класс Files
            22.3.3 Класс Paths
            22.3.4 Интерфейсы атрибутов файлов
            22.3.1 Классы FileSystem, FileSystems и FileStore
        22.4 Применение системы ввода-вывода NIO
            22.4.1 Применение системы NIO для канального ввода-вывода
            22.4.2 Применение системы NIO для потокового ввода-вывода
            22.4.3 Применение системы ввода-вывода NIO для операций в файловой системе

    Глава 23. Работа в сети
        23.1 Основы работы в сети
        23.2 Сетевые классы и интерфейсы
        23.3 Класс InetAddress
            23.3.1 Фабричные методы
            23.3.2 Методы экземпляра
        23.4 Классы Inet4Address и Inet6Address
        23.5 Клиентские сокеты по протоколу TCP/IP
        23.6 Класс URL
        23.7 Класс URLConnection
        23.8 Класс Ht tpURLConnection
        23.9 Класс URI
        23.10 Сооkiе-файлы
        23.11 Серверные сокеты по протоколу TCP/IP
        23.12 Дейтаграммы
            23.12.1 Класс DatagramSocket
            23.12.2 Класс DatagramPacket

    Глава 24. Обработка событий
        24.1 Два подхода к обработке событий
        24.2 Модель делегирования событий
            24.2.1 События
            24.2.2 Источники событий
            24.2.3 Приемники событий
        24.3 Классы событий
            24.3.1 Класс Act ionEvent
            24.3.2 Класс AdjustmentEvent
            24.3.3 Класс ComponentEvent
            24.3.4 Класс ContainerEvent
            24.3.5 Класс FocusEvent
            24.3.6 Класс ItemEvent
            24.3.7 Класс KeyEvent
            24.3.8 Класс MouseEvent
            24.3.9 Класс MouseWheelEvent
            24.3.10 Класс TextEvent
            24.3.11 Класс WindowEvent
        24.4 Источники событий
        24.5 Интерфейсы приемников событий
            24.5.1 Интерфейс ActionListener
            24.5.2 Интерфейс AdjustmentListener
            24.5.3 Интерфейс ComponentListener
            24.5.4 Интерфейс ContainerListener
            24.5.5 Интерфейс FocusListener
            24.5.6 Интерфейс ItemListener
            24.5.7 Интерфейс KeyListener
            24.5.8 Интерфейс MouseListener
            24.5.9 Интерфейс MouseMot ionListener
            24.5.10 Интерфейс MouseWheelListener
            24.5.11 Интерфейс TextListener
            24.5.12 Интерфейс WindowFocusListener
            24.5.13 Интерфейс WindowListener
        24.6 Применение модели делегирования событий
            24.6.1 Основные принципы обработки событий в ГПИ средствами АWT
            24.6.2 Обработка событий от мыши
            24.6.3 Обработка событий от клавиатуры
        24.7 Классы адаптеров
        24.8 Внутренние классы
            24.8.1 Анонимные внутренние классы

    Глава 25. Введение в библиотеку AWT: работа с окнами, графикой и текстом
        25.1 Классы библиотеки А WT
        25.2 Основные положения об окнах
            25.2.1 Класс Component
            25.2.2 Класс Container
            25.2.3 Класс Panel
            25.2.4 Класс Window
            25.2.5 Класс Frame
            25.2.6 Класс Canvas
        25.3 Работа с обрамляющими окнами
            25.3.1 Установка размеров окна
            25.3.2 Сокрытие и отображение окна
            25.3.3 Установка заголовка окна
            25.3.4 Закрытие обрамляющего окна
            25.3.5 Метод paint()
            25.3.6 Отображение символьной строки
            25.3.7 Установка цвета переднего и заднего плана
            25.3.8 Запрос на повторное воспроизведение
            25.3.9 Создание прикладной программы на основе класса Frame
        25.4 Поддержка графики
            25.4.1 Рисование линий
            25.4.2 Рисование прямоугольников
            25.4.3 Рисование эллипсов и окружностей
            25.4.4 Рисование дуг
            25.4.5 Рисование многоугольников
            25.4.6 Демонстрация методов рисования
            25.4.7 Изменение размеров графики
        25.5 Работа с цветом
            25.5.1 Методы из класса Color
            25.5.2 Установка текущего цвета графики
            25.5.3 Пример программы, демонстрирующий работу с цветом
        25.6 Установка режима рисования
        25.7 Работа со шрифтами
            25.7.1 Определение доступных шрифтов
            25.7.2 Создание и выбор шрифта
            25.7.3 Получение сведений о шрифте
        25.8 Управление форматированием выводимого текста

    Глава 26. Применение элементов управления, диспетчеров компоновки и меню из библиотеки AWT
        26.1 Основные положения об элементах управления
            26.1.1 Ввод и удаление элементов управления
            26.1.2 Реагирование на элементы управления
            26.1.3 Исключение типа HeadlessException
        26.2 Метки
        26.3 Экранные кнопки
            26.3.1 Обработка событий от кнопок
        26.4 Флажки
            26.4.1 Обработка событий от флажков
        26.5 Кнопки-переключатели
        26.6 Элементы управления выбором
            26.6.1 Обработка событий от раскрывающихся списков
        26.7 Использование списков
           26.7.1 Обработка событий от списков
        26.8 Управление полосами прокрутки
            26.8.1 Обработка событий от полос прокрутки
        26.9 Текстовые поля
            26.9.1 Обработка событий в текстовых полях
        26.10 Текстовые области
        26.11 Диспетчеры компоновки
            26.11.1 Класс FlowLayout
            26.11.2 Класс BorderLayout
            26.11.3 Вставки
            26.11.4 Класс GridLayout
            26.11.5 Класс CardLayout
            26.11.6 Класс GridBagLayout
        26.12 Меню и строки меню
        26.13 Диалоговые окна
        26.14 О переопределении метода paint()

    Глава 27. Изображения
        27.1 Форматы файлов изображений
        27.2 Основы работы с изображениями: создание, загрузка и отображение
            27.2.1 Создание объекта класса Image
            27.2.2 Загрузка изображения
            27.2.3 Воспроизведение изображения
        27.3 Двойная буферизация
        27.4 Интерфейс ImageProducer
            27.4.1 Класс MemoryImageSource
        27.5 Интерфейс ImageConsumer
            27.5.1 Класс PixelGrabber
        27.6 Класс ImageFilter
            27.6.1 Фильтр класса CropImageFilter
            27.6.2 Фильтр класса RGBImageFilter
        27.7 Дополнительные классы для формирования изображений

    Глава 28. Служебные средства параллелизма
        28.1 Пакеты параллельного прикладного интерфейса API
            28.1.1 Пакет java.util.concurrent.atomic
            28.1.2 Пакет java.util.concurrent.locks
        28.2 Применение объектов синхронизации
            28.2.1 Класс Semaphore
            28.2.2 Класс CountDownLatch
            28.2.3 Класс CyclicBarrier
            28.2.4 Класс Exchanger
            28.2.5 Класс Phaser
        28.3 Применение исполнителя
            28.3.1 Простой пример исполнителя
            28.3.2 Применение интерфейсов Callable и Future
        28.4 Перечисление TimeUnit
        28.5 Параллельные коллекции
        28.6 Блокировки
        28.7 Атомарные операции
        28.8 Параллельное программирование средствами Fork/Join Framework
            28.8.1 Основные классы Fork/Join Framework
            28.8.2 Стратегия "разделяй и властвуй"
            28.8.3 Первый простой пример вилочного соединения
            28.8.4 Влияние уровня параллелизма
            28.8.5 Пример применения класса RecursiveTask<V>
            28.8.6 Асинхронное выполнение задач
            28.8.7 Отмена задачи
            28.8.8 Определение состояния завершения задачи
            28.8.9 Перезапуск задачи
            28.8.10 Предмет дальнейшего изучения
            28.8.11 Рекомендации относительно вилочного соединения
        28.9 Служебные средства параллелизма в сравнении с традиционным подходом к многозадачности в Java

    Глава 29. Потоковый прикладной интерфейс API
        29.1 Основные положения о потоках данных
           29.1.1 Потоковые интерфейсы
           29.1.2 Получение потока данных
           29.1.3 Простой пример потока данных
        29.2 Операции сведения
        29.3 Параллельные потоки данных
        29.4 Отображение
        29.5 Накопление
        29.6 Итераторы и потоки данных
            29.6.1 Применение итератора в потоке данных
            29.6.2 Применение итератора-разделителя
        29.7 Дальнейшее изучение потокового прикладного интерфейса API

    Глава 30. Регулярные выражения и другие пакеты
        30.1 Обработка регулярных выражений
            30.1.1 Класс Pattern
            30.1.2 Класс Matcher
            30.1.3 Синтаксис регулярных выражений
            30.1.4 Примеры, демонстрирующие совпадение с шаблоном
            30.1.5 Два варианта сопоставления с шаблоном
            30.1.6 Дальнейшее изучение регулярных выражений
        30.2 Рефлексия
        30.3 Удаленный вызов методов
            30.3.1 Простое приложение "клиент-сервер'; использующее механизм RMI
        30.4 Форматирование даты и времени средствами пакета j ava. text
            30.4.1 Класс DateFormat
            30.4.2 Класс SimpledateFormat
        30.5 Пакеты из прикладного интерфейса API даты и времени
            30.5.1 Основные классы даты и времени
            30.5.2 Форматирование даты и времени
            30.5.3 Синтаксический анализ символьных строк даты и времени
            30.5.4 Дальнейшее изучение пакета java.time

    Часть 3. Введение в программирование ГПИ средствами Swing

        Глава 31. Введение в библиотеку Swing
            31.1 Происхождение библиотеки Swing
            31.2 Построение библиотеки Swing на основе библиотеки А WT
            31.3 Главные особенности библиотеки Swing
                31.3.1 Легковесные компоненты Swing
                31.3.2 Подключаемый стиль оформления
            31.4 Связь с архитектурой MVC
            31.5 Компоненты и контейнеры
                31.5.1 Компоненты
                31.5.2 Контейнеры
                31.5.3 Панели контейнеров верхнего уровня
            31.6 Пакеты библиотеки Swing
            31.7 Простое Swing-приложение
            31.8 Обработка событий
            31.9 Рисование средствами Swing
                31.9.1 Основы рисования
                31.9.2 Вычисление области рисования
                31.9.3 Пример рисования
    
        Глава 32. Исследование библиотеки Swing
            32.1 Классы JLabel и ImageIcon
            32.2 Класс JTextField
            32.3 Кнопки из библиотеки Swing
                32.3.1 Класс JButton
                32.3.2 Класс JToggleButton
                32.3.3 Флажки
                32.3.4 Кнопки-переключатели
            32.4 Класс JTabbedPane
            32.5 Класс JScrollPane
            32.6 Класс JList
            32.7 Класс JComboBox
            32.8 Деревья
            32.9 Класс JTable
    
        Глава 33. Введение в меню Swing
            33.1 Основные положения о меню
            33.2 Краткий обзор классов JMenuBar, JMenu и JMenuitem
                33.2.1 Класс JMenuBar
                33.2.2 Класс JMenu
                33.2.3 Класс JMenuitem
            33.3 Создание главного меню
            33.4 Ввод мнемоники и оперативных клавиш в меню
            33.5 Ввод изображений и всплывающих подсказок в пункты меню
            33.6 Классы JRadioBut tonMenuitem и JCheckBoxMenuitem
            33.7 Создание всплывающего меню
            33.8 Создание панели инструментов
            33.9 Действия
            33.10 Составление окончательного варианта программы MenuDemo
            33.11 Дальнейшее изучение библиотеки Swing

    Часть 4. Введение в программирование ГПИ средствами JavaFX
        
        Глава 34. Введение в JavaFX
            34.1 Основные понятия JavaFX
                34.1.1 Пакеты JavaFX
                34.1.2 Классы подмостков и сцены
                34.1.3 Узлы и графы сцены
                34.1.4 Компоновки
                34.1.5 Класс приложения и методы ero жизненного цикла
                34.1.6 Запуск JаvаFХ-приложения
            34.2 Скелет JаvаFХ-приложения
            34.3 Компиляция и выполнение JаvаFХ-приложения
            34.4 Поток исполнения приложения
            34.5 Метка - простейший элемент управления в JavaFX
            34.6 Применение кнопок и событий
                34.6.1 Основы обработки событий в JavaFX
                34.6.2 Элемент управления экранной кнопкой
                34.6.3 Демонстрация обработки событий на примере экранных кнопок
            34.7 Рисование непосредственно на холсте
    
        Глава 35. Элементы управления JavaFX
            35.1 Классы Image и ImageView
                35.1.1 Ввод изображения в метку
                35.1.2 Ввод изображения в экранную кнопку
            35.2 Класс ToggleButton
            35.3 Класс RadioButton
                35.3.1 Обработка событий изменения в группе кнопок-переключателей
                35.3.2 Другой способ управления кнопками-переключателями
            35.4 Класс CheckBox
            35.5 Класс ListView
                35.5.1 Представление списка с полосами прокрутки
                35.5.2 Активизация режима одновременного выбора нескольких элементов из списка
            35.6 Класс ComboBox
            35.7 Класс TextField
            35.8 Класс ScrollPane
            35.9 Класс TreeView
            35.10 Эффекты и преобразования
                35.10.1 Эффекты
                35.10.2 Преобразования
                35.10.3 Демонстрация эффектов и преобразований
            35.11 Ввод всплывающих подсказок
            35.12 Отключение элементов управления
    
        Глава 36. Введение в меню JavaFX
            36.1 Основные положения о меню
            36.2 Краткий обзор классов MenuBar, Menu и Menuitem
                36.2.1 Класс MenuBar
                36.2.2 Класс Menu
                36.2.3 Класс Menuitem
            36.3 Создание главного меню
            36.4 Ввод мнемоники и оперативных клавиш в меню
            36.5 Ввод изображений в пункты меню
            36.6 Классы RadioMenuitem и CheckMenuitem
            36.7 Создание контекстного меню
            36.8 Создание панели инструментов
            36.9 Составление окончательного варианта приложения MenuDemo
            36.10 Дальнейшее изучение JavaFX

    Часть 5. Применение Java
    
        Глава 37. Компоненты Java Beans
            37.1 Общее представление о компонентах Java Beans
            37.2 Преимущества компонентов Java Beans
            37.3 Самоанализ
                37.3.1 Проектные шаблоны для свойств компонентов Java Beans
                37.3.2 Проектные шаблоны для событий
                37.3.3 Методы и проектные шаблоны
                37.3.4 Применение интерфейса BeanInfo
            37.4 Привязанные и ограниченные свойства
            37.5 Сохраняемость компонентов Java Beans
            37.6 Настройщики
            37.7 Прикладной интерфейс Java Beans API
                37.8.1 Класс Introspector
                37.8.2 Класс PropertyDescriptor
                37.8.3 Класс EventSetDescriptor
                37.8.4 Класс MethodDescriptor
            37.8 Пример компонента Java Bean
    
    
        Глава 38. Введение в сервлеты
            38.1 Предпосылки для разработки сервлетов
            38.2 Жизненный цикл сервлета
            38.3 Варианты разработки сервлетов
            38.4 Применение контейнера сервлетов Tomcat
            38.5 Простой пример сервлета
                38.5.1 Создание и компиляция исходного кода сервлета
                38.5.2 Запуск контейнера сервлетов Tomcat на выполнение
                38.5.3 Запуск веб-браузера и запрос сервлета
            38.6 Прикладной интерфейс Servlet API
            38.7 Пакет javax.servlet
                38.7.1 Интерфейс Servlet
                38.7.2 Интерфейс ServletConfig
                38.7.3 Интерфейс ServletContext
                38.7.4 Интерфейс ServletRequest
                38.7.5 Интерфейс ServletResponse
                38.7.6 Класс GenericServlet
                38.7.7 Класс ServletInputStream
                38.7.8 Класс ServletOutputStream
                38.7.9 Класс ServletException
            38.8 Ввод параметров сервлета
            38.9 Пакет javax.servlet.http
                38.9.1 Интерфейс HttpServletRequest
                38.9.2 Интерфейс HttpServletResponse
                38.9.3 Интерфейс HttpSession
                38.9.4 Класс Cookie
                38.9.5 Класс HttpServlet
            38.10 Обработка НТТР-запросов и ответов
                38.10.1 Обработка НТТР-запросов типа GET
                38.10.2 Обработка НТТР-запросов типа POST
            38.11 Применение сооkiе-файлов
            38.12 Отслеживание сеансов связи
    
    Часть 6. Приложения
    
        Глава 39. Приложение А. Применение документирующих комментариев в Java
            39.1 Дескрипторы утилиты javadoc
                39.1.1 Дескриптор @author
                39.1.2 Дескриптор {@code}
                39.1.3 Дескриптор @deprecated
                39.1.4 Дескриптор {@docRoot}
                39.1.5 Дескриптор @except ion
                39.1.6 Дескриптор @hidden
                39.1.7 Дескриптор {@index}
                39.1.8 Дескриптор {@inheritDoc}
                39.1.9 Дескриптор {@link}
                39.1.10 Дескриптор {@linkplain}
                39.1.11 Дескриптор {@literal}
                39.1.12 Дескриптор @param
                39.1.13 Дескриптор @provides
                39.1.14 Дескриптор @return
                39.1.15 Дескриптор @see Дескриптор @serial
                39.1.16 Дескриптор @serialData
                39.1.17 Дескриптор @serialField
                39.1.18 Дескриптор @since
                39.1.19 Дескриптор @throws
                39.1.20 Дескриптор @uses
                39.1.21 Дескриптор {@value}
                39.1.22 Дескриптор @version
            39.2 Общая форма документирующих комментариев
            39.3 Результаты, выводимые утилитой javadoc
            39.4 Пример применения документирующих комментариев
    
        Глава 40. Приложение Б. Краткий обзор Java Web Start
            40.1 Назначение Java Web Start
            40.2 Главные элементы Java Web Start
                40.2.1 Упаковка приложений Java Web Start в архивный JАR-файл
                40.2.2 Подписание приложений Java Web Start
                40.2.3 Запуск приложений Java Web Start с помощью JNLР-файла
                40.2.4 Связывание приложения Java Web Start с JNLР-файлом
            40.3 Экспериментирование с Java Web Start в локальной файловой системе
                40.3.1 Создание архивного JАR-файла для приложения ToggleButtonDemo
                40.3.2 Создание хранилища ключей и подписание архивного JАR-файла
                40.3.3 Создание JNLР-файла для запуска приложения ToggleButtonDemo
                40.3.4 Создание краткого НТМL-файла StartTBD.html
                40.3.5 Ввод JNLР-файла в список Exception Site List на панели управления Java
                40.3.6 Выполнение приложения ToggleButtonDemo из браузера
            40.4 Выполнение приложений Java Web Start с помощью утилиты javaws
            40.5 Выполнение аплетов средствами Java Web Start
    
        Глава 41. Приложение В. Утилита JShell
            41.1 Основные положения об утилите JShell
            41.2 Перечисление, редактирование и повторное выполнение кода
            41.3 Ввод метода
            41.4 Создание класса
            41.5 Применение интерфейса
            41.6 Вычисление выражений и встроенных переменных
            41.7 Импорт пакетов
            41.8 Исключения
            41.9 Другие команды JShell
            41.10 Дальнейшее изучение JShell
    
        Глава 42. Приложение Г. Аплеты
            42.1 Два типа аплетов
            42.2 Основы разработки аплетов
                42.2.1 Класс Applet
            42.3 Архитектура аплетов
            42.4 Скелет аплета
                42.4.1 Инициализация и прекращение работы аплета
            42.5 Аплеты на основе библиотеки Swing