// For notes
https://horstmann.com/corejava/index.html


// page 194
// 5 глава: Наследование
// - Классы, суперклассы и подклассы
// - Глобальный суперкласс Object
// - Обобщенные списочные массивы
// - Объектные оболочки и автоупаковка
// - Методы с переменным числом параметров
// - Классы перечислений
// - Рефлексия
// - Рекомендации по применению наследования

//...

// page 239
var list = new ArrayList<Integer>();
list.add(3);            ->      list.add(Integer.valueOf(3));       // автоупаковка
int n = list.get(i);    ->      int n = list.get(i).intValue();     // автораспаковка

// метод, изменяющий свои числовые параметры,
// с использованием контейнерного типа - intHolder
public static void triple (intHolder x) {
    x.value++;      // успешная модификация локальной переменной
}

// page 242
// методы с переменным числом параметров

public class PrintStream {
    public PrintStream printf(String fmt, Object ... args) {       // Object ...   ->   Object[]
        return format(fmt, args);
    }

    System.out.printf("%d %s", n, "widgets");   ->  System.out.printf("%d %s", new Object[] { new Integer(n), "widgets"} );
}

public static double max (double... values) {
    double largest = Double.MIN_VALUE;
    for (double v : values){
        if (v > largest) {
            largest = v;
        }
    }
    return largest;
}

double m = mах(З.1, 40.4, -5);   ->  new double[] { 3.1, 40.4, -5 }

// page 243
// Классы перечислений

public enum Size {
    SMALL,
    MEDIUM,
    LARGE,
    EXTRA_LARGE
};
// В классы Enum можно добавить конструкторы, методы и поля


public enum Size{
    SMALL("S"),
    MEDIUM("M"),
    LARGE("L"),
    EXTRA_LARGE("XL"),

    private String abbreviation;

    private Size(String abbreviation){
        this.abbreviation = abbreviation;
    }

    public String getAbbreviation() {
        return abbreviation;
    }
}
Size s = (Size) Enum.valueOf(Size.class, "SMALL");  // s будет присвоено значение Size.SМALL
Size[] values = Size.values();  // Size.SMALL, Size.MEDIUM, Size.LARGE,Size.EXTRA_LARGE

// page 245
// 5.7 Рефлексия
задачи для рефлексии:
    • анализировать возможности классов в процессе выполнения программы;
    • проверять объекты при выполнении программы;
      например, с помощью рефлексии можно реализовать метод toString(),
      совместимый со всеми классами;
    • реализовывать обобщенный код для работы с массивами;
    • применять объекты типа Method, которые работают аналогично указателям на функции в языках, подобных С++.

// Класс Class
Employee e;
Class cl = e.getClass();
System.out.println(e.getClass().getName() + ": " + e.getName()); -> Employee: Harry Hacker

var generator = new Random();
Class cl = generator.getClass();
String name = cl.getName(); // в переменной name устанавливает строковое значение "java.util.Date"

String className = "java.util.Date";
Class cl = Class.forName(className);

Class cl1 = Date.class; // если произведен импорт пакета java.util.*;
Class cl2 = int.class;  // тип int - это не класс, но, несмотря на это, int.class - это объект типа Class.
Class сlЗ = Double[].class;

Employee.class => Class<Employee>

var className = "java.util.Random"; // или любое другое имя класса с конструктором без аргументов
Class cl = Class.forName(className);
Object obj = cl.getConstructor().newInstance(); // получение экземпляра класса "Random"

// page 249
// 5.7.2 Обработка исключений
public static void doSomethingWithClass(String name) throws ReflectiveOperationException {
    Class cl = Class.forName(name); // может сгенерировать исключение сделать что-нибудь с переменной cl
}

// 5.7.3 Ресурсы
// Примеры:
• Файлы изображения и звука
• Текстовые файлы, содержащие строки сообщений и метки экранных кнопок.

Для компиляции листинга 5.13 (ResourceTest)
1. нужно создать архивный JАR-файл
2. запустить его на выполнение, выполнив следующие команды:
    javac resource/ResourceTest.java
    jar cvfe ResourceTest.jar resources.ResourceTest\ resources/*.class resources/*.qif resources/data/*.txt corejava/*.txt
    java -jar ResourceTest.jar

В итоге получилось так:

Структура JAR-файла:
\ResourceTest.jar
    \corejava
        \title.txt
    \META-INF
        \MANIFEST.MF
    \data
        \about.txt
    \ru
        \sectorsj
            \_251_res
                \ResourceTest.class
    \about.gif

package ru.sectorsj._251_res;

import javax.swing.*;
import java.io.*;
import java.net.*;
import java.nio.charset.*;

public class ResTest {
    public static void main(String[] args) throws IOException {
        Class cl = ResTest.class;
        URL aboutURL = cl.getResource("/about.gif");
        var icon = new ImageIcon(aboutURL);

        InputStream stream = cl.getResourceAsStream("/data/about.txt");
        var about = new String(stream.readAllBytes(), "UTF-8");

        InputStream stream2 = cl.getResourceAsStream("/corejava/title.txt");
        var title = new String(stream2.readAllBytes(), StandardCharsets.UTF_8).trim();

        JOptionPane.showMessageDialog(null,
                about,
                title,
                JOptionPane.INFORMATION_MESSAGE,
                icon);
    }
}

jar cvfe .\ru\sectorsj\_251_res\ResourceTest.jar ru.sectorsj._251_res.ResTest
ru/sectorsj/_251_res/ResTest.class
-C D:\filesEvgeniy\projects\mycoding\java\learnbooks\hortsmann_vol1\src\main\resources\_251 corejava
-C D:\filesEvgeniy\projects\mycoding\java\learnbooks\hortsmann_vol1\src\main\resources\_251 about.gif
-C D:\filesEvgeniy\projects\mycoding\java\learnbooks\hortsmann_vol1\src\main\resources\_251 data

*добавил папки, а не конечные файлы.

// page 263
// 5.7.6.

var а= new Employee[100];
...
// массив заполнен
a = Arrays.copyOf(a, 2 * a.length);

// бесполезно!!!
public static Object[] badCopyOf(Object[J а, int newLength) {
    var newArray = new Object[newLength];
    System.arraycopy(a, 0, newArray, 0, Math.min(a.length, newLength));
    return newArray;
}

Для этого потребуются методы класса Array из пакета java.lang.reflect
и особенно метод newInstance()

// так можно
Object newArray = Array.newInstance(componentType, newLength);

Для того чтобы определить тип элементов нового массива, необходимо:
1. Определить, какому именно классу принадлежит объект "а".
2. Убедиться в том, что он действительно является массивом.
3. Воспользоваться методом getComponentType() из класса Class
    (определен лишь для объектов типа Class, представляющих массивы),
    чтобы получить требуемый тип массива.

public static Object goodCopyOf(Object а, int newLength) {
    Class cl = a.getClass();
    if (!cl.isArray()) return null;
    Class componentType = cl.getComponentType();
    int length = Array.getLength(a);
    Object newArray = Array.newInstance(componentType, newLength);
    System.arraycopy(a, 0, newArray, 0, Math.min(length, newLength) );
    return newArray;
}

// page 266
// 5.7.7 Вызов произвольных методов и конструкторов

Object invoke(Object obj, Object ... args)

String n = (String) m1.invoke(harry);
double s = (Double) m2.invoke(harry);

// Как получить объект типа Method?
Method getMethod(String name, Class ... parameterTypes)

Method m1 = Employee.class.getMethod("getName");
Method m2 = Employee.class.getMethod("raiseSalary", double.class);

// для конструкторов
Class cl = Random.class;    // или любой другой класс с конструктором, принимающим параметр типа long
Constructor cons = cl.getConstructor(long.class);
Object obj = cons.newInstance(45L);

public static native double java.lang.Math.sqrt(double)
 1.0000  |       1.0000
 2.0000  |       1.4142
 3.0000  |       1.7321
 4.0000  |       2.0000
 5.0000  |       2.2361
 6.0000  |       2.4495
 7.0000  |       2.6458
 8.0000  |       2.8284
 9.0000  |       3.0000
10.0000  |       3.1623

double dx = (to - from) / (n - 1);
for (double x = from; x <= to; x +=dx) {
    double y = (Double) f.invoke(null, x);          // т.к. вызывается статический метод, 1й параметр - null
    System.out.printf("%10.4f | %10.4f%n", x, y);   // где f - это объект типа Method/
}
Math.class.getMethod("sqrt", double.class)

// page 270
// 5.8 Рекомендации по применению наследования


Резюме
1. размещайте общие операции и поля в суперклассе
2. Стараться не пользоваться защищенными (protected) полями
3. Использовать наследование для моделирования отношений - "является"
4. Не пользоваться наследованием, если не все методы имеет смысл сделать наследуемыми
5. Не изменять предполагаемое поведение метода при его переопределении
6. Пользоваться принципом полиморфизма, а не данными о типе
7. Не злоупотреблять механизмом рефлексии

// 273
// 6 глава:
// interfaces | lambdas | inner classes | service loaders | proxies
~ Интерфейсы
~ Лямбда-выражения
~ Внутренние классы
~ Загрузчики служб
~ Прокси-классы


// 6.1 Интерфейсы
// 6.1.1 Понятие интерфейса

// до java 5
public interface Comparable {
    int compareTo(Object other);
}
// после java 5
public interface Comparable<T> {
    int compareTo(T other); //этот параметр относится к обобщенному типу Т
}

Итак, если Comparable<Employee> ->  int compareTo(Employee other);


class Employee implements ComparaЫe<Employee> {
    public int compareTo(Employee other) {
        return DouЫe.compare(salary, other.salary);
    }
    ...
}

// page 289
// 6.1.8 Интерфейс Comparable

public interface Comparator<T> {
    int compare(T first, Т second);
}

// создаем компаратор для сравнения строк по их длине
class LengthComparator implements Comparator<String>{
    public int compare(String first, String second) {
        return first.length() - second.length();
    }
}

var comp = new LengthComparator();
if (comp.compare(words[i], words(j]) > 0) ...

String[] friends = { "Peter", "Paul", "Mary" };
Arrays.sort(friends, new LengthComparator());

// page 290
// 6.1.9 Клонирование объектов

var original = new Employee("Невил Долгопупс", 50000);
Employee copy = original;
copy.raiseSalary(10);   // упс, оригинал тоже изменился!

Employee copy = original.clone();
copy.raiseSalary(10);   // хорошо, теперь оригинал не изменился!

Метод clone() - является защищенным (protected)

Чтобы применить метод clone(), нужно принять следующее решение:
Вариант 1. Достаточно ли метода clone(), предоставляемого по умолчанию?
Вариант 2. Можно ли доработать предоставляемый по умолчанию метод clone() таким образом,
   чтобы вызывать его для изменяемых объектов?
Вариант 3. Следует ли вообще отказаться от применения метода clone()?

Если хотите использовать Вариант 1 или Вариант2, то нужно:
1. Реализовать интерфейс Cloneable.
2. Переопределить метод clone() с модификатором доступа public.

Интерфейс Cloneable - маркерный интерфейс, т.е. не имеет ни одного метода.
Его задача, разрешить выполнение операции instanceof
для проверки типа следующим образом:

if (obj instanceof Cloneable) ...

Для реализации метода clone() по умолчанию(неполное копирование), нужно:
1. реализовать интерфейс Cloneable,
2. переопределить метод clone() как открытый (public)
3. сделать вызов super.clone()

class Employee implements Cloneable {
    // сделать метод открытым, изменить возвращаемый тип
    public Employee clone() throws CloneNotSupportedException {
        return (Employee) super.clone();
    }
    ...
}

// пример реализации метода clone(), выполняющего полное копирование
class Employee implements Cloneable{
    ...

    public Employee clone() throws CloneNotSupportedException{
        // вызов метода Object.clone()
        Employee cloned = (Employee) super.clone();

        // клонировать изменяемые поля
        cloned.hireDay = (Date) hireDay.clone();

        return cloned
    }
}

// пример метода clone() в массивах,
// но он открытый (public), а не защищенный (protected)
int[] luckyNumbers = {2, 3, 5, 7, 11, 13};
int[] cloned = (int[]) luckyNumbers.clone();
cloned[5] = 12;     // не изменяет элемент массива luckyNumbers[5]

// page 296
// 6.2 Лямбда выражения
// 6.2.1 Причины для употребления лямбда-выражений

class Worker implements ActionListener {
    public void actionPerformed(ActionEvent event){
        // сделать что-то
    }
}

class LengthComparator implements Comparator<String> {
    public int compare(String first, String second) {
        return first.length() - second.length();
    }
}
...
Arrays.sort(strings, new LengthComparator());



// 6.2.2 Синтаксис лямбда-выражений
first.length() - second.length()
->
(String first, String second) -> first.length() - second.length()

// -> λfirst.λsecond.first.length() - second.length()

// если есть параметры:
(String first, String second) -> {
    if (first.length() < second.length()) return -1;
    else if (first.length() > second.length()) return 1;
    else return 0;
}

// при отсутствии параметров:
() -> {
    for (int i = 100; i >= 0; i--)
        System.out.println(i);
}

// Можно опустить типы параметров лямбда выражений, т.к.
// результат вычисления лямбда-выражения присваивается компаратору символьных строк.
// (first, second) тоже самое, что и "(String first, String second)"

Comparator<String> comp = (first, second) ->
    first.length() - second.length();

// Если у метода имеется единственный параметр выводимого типа,
// то можно опустить круглые скобки
// вместо (event) -> ...
// или (ActionListener event) -> ...

ActionListener listener = event ->
    System.out.println("Время " + Instant.ofEpochMilli(event.getWhen()));

// Результат вычисления лямбда-выражений вообще не указывается.
// Данное выражение может быть использовано там,
// где ожидается результат типа int
(String first, String second) ->
    first.length() - second.length()


// Недопустимо, чтобы значение возвращалось в одних ветвях лямбда-выражения,
// но не возвращалось в других его ветвях.
(int х) -> (if (х >= 0) return 1;)      // Ошибка!


// page 300
// 6.2.3 Функциональные интерфейсы


Чтобы продемонстрировать преобразование в функциональный интерфейс,
рассмотрим снова метод Arrays.sort().
В качестве второго параметра ему требуется экземпляр типа Comparator - интерфейса с единственным методом.

Вместо него достаточно предоставить лямбда-выражение следующим образом:
Arrays.sort(words, (first, second) -> first.length() - second.length() );
Подспудно метод Arrays.sort() принимает объект некоторого класса,
реализующего интерфейс Comparator.
В результате вызова метода compare() для этого объекта выполняется тело лямбда-выражения.
Управление такими объектами и классами полностью зависит от конкретной реализации
и может быть намного более эффективным, чем применение традиционных внутренних классов.
Поэтому лямбда-выражение лучше всего рассматривать как функцию, а не объект,
приняв к сведению, что оно может быть передано функциональному интерфейсу.

В стандартной библиотеке Java предоставляется целый ряд
весьма универсальных функциональных интерфейсов,
входящих в пакет java.util.function

BiFunction<String, String, Integer> comp
    = (first, second) -> first.length() - second.length();

public interface Predicate<T> {
    boolean test(T t);
    // Дополнительные методы по умолчанию и статические методы
}

// removeIf() - из класса ArrayList, с параметром типа Predicate
list.removeIf(e -> e == null);

// Supplier<T>
public interface Supplier<T>{
    T get();
}

LocalDate hireDay = Objects.requireNonNullOrElse(day, new LocalDate(1970, 1, 1));
->
LocalDate hireDay = Objects.requireNonNullOrElseGet(day,
    () -> new LocalDate(1970, 1, 1));


// page 302
// 6.2.4 Ссылки на методы

var timer = new Timer(1000, event -> System.out.println(event));
->
var timer = new Timer(1000, System.out::println);

Arrays.sort(strings, String::compareToignoreCase)

Разновидности ссылок на методы в лямбда выражениях:
1 Объект:: МетодЭкземпляра
2  Класс:: МетодЭкземпляра
3  Класс:: СтатическийМетод

|       Ссылка на метод        |    Равнозначное лямбда-выражение      |                       Примечания                      |
|------------------------------|---------------------------------------|-------------------------------------------------------|
| System.out::println          |   x -> System.out.println(x)          |   ссылка на метод равнозначна лямбда выражению,       |
|                              |                                       |   параметры которого передаются методу                |
| String::compareToignoreCase  |  (х, у) -> х.compareToignoreCase (у)  |   первый параметр ссылки на метод становится          |
|                              |                                       |   неявным параметром метода                           |
| separator::equals            |   x -> separator.equals(x)            |   Это выражение-метод с заданным объектом             |
|                              |                                       |   экземпляра. Параметр лямбда-выражения               |
|                              |                                       |   передается как явный параметр метода                |
| String::trim                 |   x -> x.trim()                       |   Это выражение-метод с заданным классом и методом    |
|                              |                                       |   экземпляра. Параметр лямбда-выражения становится    |
|                              |                                       |   неявным параметром                                  |
| String::concat               |   (x, y) -> x.concat(y)               |   Здесь вызывается метод экземпляра, но на этот раз   |
|                              |                                       |   с явным параметром. Как и прежде, первый параметр   |
|                              |                                       |   лямбда-выражения становится неявным параметром, а   |
|                              |                                       |   остальные параметры передаются методу               |
| Integer::valueOf             |   x -> Integer::valueOf(x)            |   Это выражение-метод с заданным статическим методом. |
|                              |                                       |   Параметр лямбда-выражения передается этому          |
|                              |                                       |   статическому методу                                 |
| Integer::sum                 |   (x, y) -> Integer::sum(x, y)        |   Это еще один пример вызова статического метода,     |
|                              |                                       |   но на этот раз с двумя параметрами. Оба параметра   |
|                              |                                       |   лямбда-выражения передаются статическому методу.    |
|                              |                                       |   В частости, метод Integer.sun() создается, чтобы    |
|                              |                                       |   служить в качестве ссылки на метод. В качестве      |
|                              |                                       |   альтернативы можно было бы просто составить         |
|                              |                                       |   лямбда-выражение (x, y) -> x + y                    |
| Integer:new                  |   x -> new Integer(x)                 |   Это ссылка на конструктор (6.2.5). Параметры        |
|                              |                                       |   лямбда-выражения передаются конструктору            |
| Integer[]::new               |   n -> new Integer[n]                 |   Это ссылка на конструктор массива (6.2.5) Параметр  |
|                              |                                       |   лямбда-выражения определяет длину массива           |
|------------------------------|---------------------------------------|-------------------------------------------------------|

Objects.isNull(obj) => Predicate =>
list.removeIf(Objects::isNull);     // эту строку легче читать
list.removeIf(e -> e == null);      // чем эту

this::equals        x -> this.equals(x);
super::equals       x -> super.equals(x);

 Ссылка super является целевой и вызывает вариант заданного метода экземпляра из суперкласса.

// Пример
class Greeter {
    public void greet(ActionEvent event) {
        System.out.println("Hello, the time is" + Instant.ofEpochMilli(event.getWhen()))
    }
}

class RepeatedGreeter extends Greeter {
    public void greet(ActionEvent event) {
        var timer = new Timer(1000, super::greet);
        timer.start();
    }
}

// page 305
// 6.2.5 Ссылки на конструкторы

Ссылки на конструкторы действуют таким же образом, как и ссылки на методы,
за исключением того, что вместо имени метода указывается операция new.

ArrayList<String> names = ...;
Stream<Person> stream = names.stream().map(Person::new);
List<Person> people = stream.collect(Collectors.toList());

int[]::new  => x -> new int[x]

Object[] people = steam.toArray();      // допустим требуется создать массив из объектов типа Person
->
Object[] people = steam.toArray(Person[]::new);

// page 306
// 6.2.6 Область видимости переменных

public static void repeatMessage(String text, int delay) {
    ActionListener listener = event -> {
        System.out,println(text);
        Toolkit.getDefaultToolkit().beep();
    };
    new Timer(delay, listener).start();
}

// Следующий вызов:
repeatMessage("Hello", 1000);   // выводит слово - Hello 1000 раз в отдельном потоке исполнения

Переменная - text, весьма необычна.

Лямбда-выражение имеет следующие составляющие:
1. Блок кода
2. Параметры
3. Значения свободных переменных, т.е. таких переменных,
   которые не являются параметрами и не определены в коде
-> text - это свободная переменная (строка "Hello")
// значение переменной text захвачено лямбда-выражением.

// Блок кода вместе со значениями свободных переменных называется - замыканием.
// Лямбда-выражения служат в качестве замыканий
// В лямбда-выражении можно ссылаться только на те переменные, значения которых не изменяются.

public static void countDown(int start, int delay){
    ActionListener listener = event -> {
        start--;    // ОШИБКА! изменить захваченную переменную нельзя!
        System.out.println(start);
    };
    new Timer(delay, listener).start();
}

// В лямбда-выражении не допускается ссылаться на переменную, которая изменяется извне.
public static void repeat(String text, int count) {
    for (int i = 1; i <= count; i++) {
        ActionListener listener = event -> {
            System.out.println(i + ": " + text);    // Ошибка! Нельзя ссылаться на изменяемую переменную "i"
        };
        new Timer(1000, listener).start();
    }
}

// Правило гласит: любая захваченная переменная в лямбда-выражении должна
// быть действительно конечной, т.е. такой переменной,
// которой вообще не присваивается новое значение после ее инициализации.

// Не допускается объявлять параметр или переменную в лямбда-выражении
// с таким же именем как и у локальной переменной:

Path first = Path.get("/usr/bin");
Comparator<String> comp = (first, second) -> first.length() - second.length(); // ОШИБКА! переменная first уже определена!

public class Application() {
    public void init() {
        ActionListener listener = event -> {
            System.out.println(this.toString());
            ...
        }
        ...
    }
}

// page 308
// 6.2.7 Обработка лямбда-выражений

// Причины для отложенного выполнения кода:
1. Выполнение кода в отдельном потоке.
2. Неоднократное выполнение кода.
3. Выполнение кода в нужный момент по ходу алгоритма (например, выполнение операции сравнения при сортировке).
4. Выполнение кода при наступлении какого-нибудь события (щелчка на экранной кнопке, поступления данных и т.д.).
5. Выполнение кода только по мере надобности.

// Пример:
repeat(10, () -> System.out.println("Hello, World!"));

public static void repeat(int n, Runnable action) {
    for (int i = 0; i < n; i++){
        action.run();
    }
}

public interface IntConsumer {
    void accept(int value);
}

// Обновленный метод repeat():
public static void repeat(int n, IntConsumer action) {
    for (int i = 0; i < n; i++) {
        action.accept(i);
    }
}

// вызов нового метода repeat():
repeat(10, i -> System.out.println("Countdown: " + (9 - i)));

// таблица 6.2 наиболее употребляемые функциональные интерфейсы:
|----------------------|------------ |--------------|------------------|-----------------------|-----------------------|
|    Функциональный    |    Типы     | Возвращаемый | Имя абстрактного |        Описание       |         Другие        |
|       интерфейс      | параметров  |     тип      |      метода      |                       |         методы        |
| -------------------- |------------ |--------------|------------------|-----------------------|-----------------------|
| Runnable             | отсутствует |     void     |        run       | Выполняет действие без|                       |
|                      |             |              |                  | аргументов или возвра-|                       |
|                      |             |              |                  | щаемого значения      |                       |
|----------------------|-------------|--------------|------------------|-----------------------|-----------------------|
| Supplier<T>          | отсутствует |       T      |        get       | Предоставляет значение|                       |
|                      |             |              |                  | типа T                |                       |
|----------------------|-------------|--------------|------------------|-----------------------|-----------------------|
| Consumer<T>          |      T      |     void     |      accept      | Употребляет значение  |        andThen        |
|                      |             |              |                  | типа T                |                       |
|----------------------|-------------|--------------|------------------|-----------------------|-----------------------|
| BiConsumer<T, U>     |     T, U    |     void     |      accept      | Употребляет значение  |        andThen        |
|                      |             |              |                  | типа T и U            |                       |
|----------------------|-------------|--------------|------------------|-----------------------|-----------------------|
| Function<T, R>       |      T      |      R       |       apply      | Функция с аргументом  |   compose, andThen,   |
|                      |             |              |                  | T                     |   identity            |
|----------------------|-------------|--------------|------------------|-----------------------|-----------------------|
| BiFunction<T, U, R>  |     T, U    |      R       |      apply       | Функция с аргументами |        andThen        |
|                      |             |              |                  | T и U                 |                       |
|----------------------|-------------|--------------|------------------|-----------------------|-----------------------|
| UnaryOperator<T>     |      T      |      T       |      apply       | Унарная операция над  |   compose, andThen,   |
|                      |             |              |                  | типом T               |   identity            |
|----------------------|-------------|--------------|------------------|-----------------------|-----------------------|
| BinaryOperator<T>    |     T, T    |      T       |      apply       |Двоичная операция над  | andThen,maxBy, minBy  |
|                      |             |              |                  |типом T                |                       |
|----------------------|-------------|--------------|------------------|-----------------------|-----------------------|
| Predicate<T>         |      T      |    boolean   |       test       | Булевозначная функция |   and, or, negate,    |
|                      |             |              |                  |                       |        isEqual        |
|----------------------|-------------|--------------|------------------|-----------------------|-----------------------|
| BiPredicate<T, U>    |     T, U    |    boolean   |       test       | Булевозначная функция |    and, or, negate    |
|                      |             |              |                  | с аргументами         |                       |
|----------------------|-------------|--------------|------------------|-----------------------|-----------------------|

// Пример: PConsumer -> IntConsumer
// По этому был использован IntConsumer вместо Consumer<Integer>

// таблица 6.3 : Функциональные интерфейсы для примитивных типов,
где обозначения:
1. р, q относятся к типам: int, long, double
2. Р, Q относятся к типам: Int, Long, Double
|----------------------|------------ |--------------|------------------|
|    Функциональный    |    Типы     | Возвращаемый | Имя абстрактного |
|       интерфейс      | параметров  |     тип      |      метода      |
| -------------------- |------------ |--------------|------------------|
| BooleanSupplier      | отсутствует |    boolean   |   getAsBoolean   |
| PSupplier            | отсутствует |      p       |      getAsP      |
| PConsumer            |      p      |     void     |      accept      |
| ObjPConsumer<T>      |     T, p    |     void     |      accept      |
| PFunction<T>         |      p      |      T       |      apply       |
| PToQFunction         |      T      |      q       |     applyAsQ     |
| ToPFunction<T>       |      T      |      T       |     applyAsQ     |
| ToPBiFunction<T, U>  |     T, U    |      p       |     applyAsQ     |
| PUnaryOperator       |      p      |      p       |     applyAsQ     |
| PBinaryOperator      |     p, p    |      p       |     applyAsQ     |
| PPredicate           |      p      |    boolean   |       test       |
|----------------------|-------------|--------------|------------------|

// Функциональные интерфейсы из таблиц 6.2 и 6.3 рекомендованы к употреблению!!!
// Если вы разрабатываете собственный интерфейс с единственным абстрактным методом,
// его можно пометить аннотацией @Functionalinterface. Это не обязательно,
// но дает ряд преимуществ.

// page 311
// 6.2.8 Еще о компараторах

// Comparator -> comparing () (статический метод)
// Имеется массив объектов типа Person. Сортировка его элементов по имени.
Arrays.sort(people, Comparator.comparing(Person::getName));

// Компараторы можно связывать в цепочку с помощью метода thenComparing().
Если у двух людей оказываются одинаковые фамилии, то применяется второй компаратор.
Arrays.sort(people, Comparator
    .comparing(Person::getLastName)
    .thenComparing(Person::getFirstName));

// люди сортируются по длине их имен:
Arrays.sort(people, Comparator.comparing(Person::getName,
    (s, t) -> Integer.compare(s.length(), t.length())));
->
Arrays.sort(people, Comparator.comparingInt(
    p -> p.getName().length()));

// методы nullFirst() и nullLast() принимающие имеющийся компаратор,
// чтобы он не генерировал исключение при появлении пустых значений - null.
Comparator.comparing(Person::getMiddleName(),
    Comparator.nullFirst(...))
->
// производится статический импорт по директиве java.util.Comparator.*
Arrays.sort(people, comparing(Person::getMiddleName, nullsFirst(naturalOrder())));

// статический метод reverseOrder() производит сортировку в порядке,
// обратном естественному (naturalOrder()).
// naturalOrder().reversed() = reverseOrder()


// page 312
// 6.З Внутренние классы

// Зачем нужны внутренние классы?
1. Внутренний класс можно скрыть от других классов того же пакета.
2. Объект внутреннего класса имеет доступ к данным объекта,
   в котором он определен, включая закрытые данные.

// 6.3.1 Доступ к состоянию объекта с помощью внутреннего класса

//
public class TalkingClock {
    private int interval;
    private boolean beep;

    public TalkingClock(int interval, boolean beep) {...}
    public void start() {...}

    // внутренний класс
    public class TimerPrinter implements ActionListener {
        ...
    }
}

// подробнее класс TimerPrinter
public class TimerPrinter implements ActionListener {
    public void actionPerformed(ActionEvent event) {
        System.out.println("Сигнал прозвучал в " + Instant.ofEpochMilli(event.getWhen()));
        if (beep) Toolkit.getDefaultToolkit().beep();

    }
}
// в классе TimePrinter отсутствует поле beep.
// Вместо этого метод actionPerformed() обращается к соответствующему полю объекта типа TalkingClock.
// Добавим в код ссылку на объект внешнего класса - other.
->
public class TimerPrinter implements ActionListener {
    public void actionPerformed(ActionEvent event) {
        System.out.println("Сигнал прозвучал в " + Instant.ofEpochMilli(event.getWhen()));
        if (other.beep) Toolkit.getDefaultToolkit().beep();
    }
}
 -> public TimerPrinter(TalkingClock){
    // автоматически генерируется код
    other = clock;
 }

 var = new TimePrinter(this); //параметр добавляется автоматически


// page 316
// 6.3.2 Специальные синтаксические правила для внутренних классов

// ВнешнийКласс.this    - ссылка на внешний класс из внутреннего
// Пример такой ссылки в классе TimerPrinter
public void actionPerformed(ActionEvent event) {
    ...
    if (TalkingClock.this.beep) Toolkit.getDefaultToolkit().beep();
}

ОбъектВнешнегоКласса.new ВнутреннийКласс(параметры конструктора)

// Пример:
ActionListener listener = this.new TimePrinter();

TalkingClock jabberer = new TalkingClock(1000, true);
TalkingClock.TimePrinter listener = jabberer.new TimePrinter();

// Если ссылка на внутренний класс делается
// за пределами области действия внешнего класса,
ВнешнийКласс.ВнутреннийКласс


// page 317
// 6.3.3 О пользе, необходимости и безопасности внутренних классов

// Обращение с внутренними классами происходит на уровне компилятора, а не виртуальной машины.
// Для обозначения внутренних классов используется знак $, разделяющий имена внешних и внутренних классов.
// -> для виртуальной машины внутренние классы неотличимы от внешних.

// ВнутреннийКласс TimePrinter входящий в состав ВнешнегоКласса TalkingClock преобразуется компилятором в
// -> TalkingClock$TimePrinter

// javap -private ИмяКласса

// Для UNIX:
java reflection.ReflectionTest ВнутреннийКласс.TalkingClock\$TimePrinter
или же так:
javap -private ВнутреннийКласс.TalkingClock\$TimePrinter
->
public class innerClass.TalkingClock$TimePrinter implements java.awt.event.ActionListener {
    final innerClass.TalkingClock this$0;
    public innerClass.TalkingClock$TimePrinter(innerClass.TalkingClock);
    public void actionPerformed(java.awt.event.ActionEvent);
}

// this$0 синтезируется компилятором, поэтому сослаться на него нельзя.

class TalkingClock {
    ...
    public void start() {
        var listener = new TimePrinter(this);
        var timer = new Timer(interval, listener);
        timer.start();
    }
}

class TimePrinter implements ActionListener {
    private TalkingClock outer;
    ...
    public TimePrinter(TalkingClock clock) {
        outer = clock;
    }
}

// Рассмотрим теперь метод actionPerformed().
// Ему требуется доступ к полю outer.beep
if (outer.beep) ... // ОШИБКА! ->
// -> Внутренний класс может иметь доступ к закрытым данным лишь того внешнего класса, в который он входит.
// Но класс TimePrinter уже не является внутренним, а следовательно, не имеет такого доступа.

// Внутренние классы, намного эффективнее, чем обычные,
// т.к. они обладают более высокими правами доступа.

class TalkingClock {
    private int interval;
    private boolean beep;
    public TalkingClock(int, boolean);
    static boolean access$0(TalkingClock);
    public void start();
}

if (beep) -> if (TalkingClock.access$0(outer))

// Если внутренний класс имеет доступ к закрытым полям,
// можно создать другой класс, добавить его в тот же самый пакет
// и получить доступ к закрытым данным.

private TalkingClock$TimePrinter(TalkingClock);
// чтобы вызвать такой конструктор, нужно вызвать второй конструктор
->
TalkingClock$TimePrinter(TalkingClock, TalkingClock$1);
// Компилятор преобразует вызов конструктора в методе start() из класса TalkingClock
new TalkingClock$TimePrinter (this, null)

// page 320
// 6.3.4 Локальные внутренние классы

// Т.к. класс TimePrinter используется лишь однажды:
// при создании объекта данного типа в методе start(),
// его можно определить локально в отдельном методе (start())
->
public void start() {
    class TimePrinter implements ActionListener {
        public void actionPerformed(ActionEvent event) {
            System.out.println("Во время сигнала, время " + Instant.ofEpochMilli(event.getWhen()));
            if (beep) Toolkit.getDefaultToolkit().beep();
        }
    }
    var listener = new TimePrinter();
    var timer = new Timer(interval, listener);
    timer.start();
}

// В локальных внутренних классах не используются модификаторы:
// 1. public
// 2. protected

// Преимущества локальных внутренних классов:
// они полностью скрыты от внешнего кода и даже от остальной части класса TalkingClock
// ни одному методу кроме start() ничего неизвестно о TimePrinter

// page 321
// 6.3.5 Доступ к конечным переменным из внешних методов

// Локальные внутренние классы имеют доступ не только к полям своего внешнего класса,
// но и к локальным переменным.
// Такие локальные переменные должны быть объявлены как действительно конечные.

// Перенесем параметры interval и beep
// из конструктора TalkingClock в метод start()
->
public void start(int interval, boolean beep) {
    class TimerPrinter implements ActionListener {
        public void actionPerformed() {
            System.out.println("Сигнал прозвучал в " + Instant.ofEpochMilli(event.getWhen()));
            if (beep) Toolkit.getDefaultToolkit().beep();
        }
    }
    var listener = new TimePrinter();
    var timer = new Timer(interval, listener);
    timer.start;
}
// Теперь в классе TimePrinter больше не нужно хранить переменную экземпляра beep.
// При создании объекта переменная beep,
// передается конструктору и размещается в поле val$beep.
// Компилятор должен обнаруживать доступ к локальным переменным,
// создавать для каждой из них соответствующие поля,
// а затем копировать локальные переменные в конструкторе таким образом,
// чтобы поля данных инициализировались копиями локальных переменных.


// page 322
// 6.3.6 Анонимные внутренние классы

// если требуется создать единственный объект некоторого класса,
// этому классу можно вообще не присваивать имени.
// такой класс называется - анонимным.

// создается новый объект класса, реализующего интерфейс ActionListener,
// где в фигурных скобках определен требующийся метод actionPerformed().
public void start(int interval, boolean beep) {
    var listener = new ActionListener() {   // но синтаксис анонимных внутренних классов довольно сложен.
        public void actionPerformed(ActionEvent event) {
            System.out.println("Сигнал прозвучал в" + Instant.ofEpochMilli(event.getWhen()));
            if (beep) Toolkit.getDefaultToolkit().beep();
        }
    };
    var timer = new Timer(interval, listener);
    timer.start;
}

// общая форма определения анонимных внутренних классов
new СуперТип(параметры конструирования объектов) {
    методы и данные внутреннего класса
}

// Здесь СуперТип может быть:
// 1. интерфейсом (например ActionListener), и тогда внутренний класс реализует данный интерфейс.
// 2. классом, и в этом случае внутренний класс расширяет данный суперкласс.

// Анонимный внутренний класс не может иметь конструкторов:
// поскольку имя конструктора должно совпадать с именем класса,
// а в данном случае у класса отсутствует имя.
// Вместо этого параметры, необходимые для создания объекта, передаются конструктору суперкласса.
// Если вложенный класс реализует какой-нибудь интерфейс, параметры конструктора можно не указывать.

new ТипИнтерфейса() {
    методы и данные
}

// Если за скобками со списком параметров, необходимых для создания объекта,
следует открытая фигурная скобка, то определяется анонимный вложенный класс:

var queen = new Person("Mary");             // объект типа Person
var count = new Person("Dracula") {...};    // объект внутреннего класса, расширяющего класс Person

// Несмотря на то, что у анонимного класса могут отсутствовать конструкторы,
// это никоим образом не мешает предоставить блок инициализации объекта
var count = new Person("Dracula") {
    { (инициализация) }
    ...
};

// альтернативный вариант метода start() написанный в виде лямбда-выражения:
public void start(int interval, boolean beep) {
    var timer = new Timer(interval, event -> {
        System.out.println("Сигнал прозвучал в " + Instant.ofEpochMilli(event.getWhen()));
        if (beep) Toolkit.getDefaultToolkit().beep();
    });
    timer.start();
}

// Спец прием - инициализация в двойных фигурных скобках
// Если дано:
var friends = new ArrayList<>();
favorites.add("Гарри");
favorites.add("Тони");
favorites.add("Ленни");
invite(friends);

// тогда ->
invite (new ArrayList<String>() {{ add("Гарри"); add("Тони"); add("Ленни"); }})

// Зачастую анонимный подкласс удобно сделать почти,
// но не совсем таким же, как и его суперкласс.
// Но в этом случае следует соблюдать особую осторожность в отношении метода equals().
// в методе equals() необходимо организовать следующую проверку (глава 5):

if (getClass() != other.getClass()) return false;
// Но анонимный подкласс ее не пройдет.


// При выдаче регистрирующих или отладочных сообщений в них нередко требуется включить имя текущего класса:
System.err.println("Something awful happened in " + getClass() );

// Но такой прием не годится для статического метода.
// Ведь вызов метода qetClass(), по существу, означает вызов this.qetClass().
// Но ссылка this на текущий объект для статического метода не годится.
// В таком случае можно воспользоваться следующим выражением:
new Object(){}.getClass().getEnclosingClass()       // получить класс статического метода

// new Object(){}      - создается объект анонимного подкласса, производного от класса Object
// qetEnclosingClass() - метод получает объемлющий его класс, т.е. класс, содержащий статический метод.

// page 325
// 6.3.7 Статические внутренние классы
// К примеру в массиве требуется найти максимальное и минимальное числа.

double min = Double.MAX_VALUE;
double max = Double.MIN_VALUE;
for (double v : values) {
    if (min > 0) min = v;
    if (max < 0) max = v;
}

class Pair {
    private double first;
    private double second;

    public Pair (double f, double s) {
        first = f;
        second = s;
    }

    public double getFitst() { return first; }
    public double getSecond() { return second; }
}

class ArrayAlg {
    public static Pair minmax (double[] values) {
        ...
        return new Pair(min, max);
    }
}

Pair p = ArrayAlg.minmax(d);
System.out.println("min =" + p.getFirst());
System.out.println("max =" + p.getSecond());

// сделать Pair внутренним классам в ArrayAlg
-> ArrayAlg.Pair

ArrayAlg.Pair p = ArrayAlg.Pair.minmax();

class ArrayAlg {
    public static class Pair {
        ...
    }
    ...
}

// Только внутренние классы можно объявлять статическими.
// Его объект не содержит ссылку на создавший его объект внешнего класса.

public static Pair minmax (double[] values) {
    ...
    return new Pair(min, max);
}

// Если бы класс Pair не был объявлен статическим, компилятор сообщил бы,
// что при инициализации объекта внугреннего класса объект типа ArrayAlg недоступен.

// Статический вложенный класс применяется тогда,
// когда доступ к объекту внутреннего класса не требуется.
// Иногда для обозначения статических внутренних классов пользуются термином - вложенные классы.
// В отличие от обычных внутренних классов, у статических внутренних классов
// могут быть статические поля и методы.
// Внутренние классы, определенные в интерфейсах,
// автоматически считаются статическими и открытыми (т.e. static и public).

// page 329
// 6.4 Загрузчики служб
// Нужны для приложений с архитектурой подключаемых модулей.
// В т.ч. для платформ, серверов приложений и прочих сложных решений.

// Если предоставляется служба, то разработчику прикладной программы
// необходимо дать определенную свободу в реализации функциональных средств данной службы.
// Также желательно предоставить на выбор несколько реализаций службы.
// Загрузку служб, соответствующих общему интерфейсу, позволяет упростить класс ServiceLoader.

// С этой целью определяется интерфейс (или суперкласс) с методами,
// которые должен предоставлять каждый экземпляр загружаемой службы.
// К примеру, служба обеспечивает шифрование данных.

package serviceLoader;
public interface Cipher {
    byte[] encrypt(byte[] source, byte[] key);
    byte[] decrypt(byte[] source, byte[] key);
    int strength();
}

package serviceLoader.impl;
public class CaeserCipher implements Cipher {
    public byte[] encrypt(byte[] source, byte[] key) {
        var result = new byte[source.length];
        for (int i = 0; i < source.length; i++){
            result[i] = (byte) (source[i] + key[0]);
        }
        return resilt;
    }

    public byte[] decrypt(byte[] source, byte[] key) {
        return encrypt(source, new byte[] {
            (byte) - key[0]
        });
    }

    public int strength() {
        return 1;
    }
}


// Пример:
package ru.sectorsj._329_serviceLoader.impl;

import ru.sectorsj._329_serviceLoader.Cipher;

public class CaesarCipher implements Cipher {

    @Override
    public byte[] encrypt(byte[] source, byte[] key) {
        var result = new byte[source.length];
        for (int i = 0; i < source.length; i++) {
            result[i] = (byte) (source[i] + key[0]);
        }
        return result;
    }

    @Override
    public byte[] decrypt(byte[] source, byte[] key) {
        return encrypt(source, new byte[]{
                (byte) - key[0]
        });
    }

    @Override
    public int strength() {
        return 1;
    }
}

package ru.sectorsj._329_serviceLoader;

public interface Cipher {
    byte[] encrypt(byte[] source, byte[] key);
    byte[] decrypt(byte[]source, byte[] key);
    int strength();
}


package ru.sectorsj._329_serviceLoader;

import java.util.Optional;
import java.util.ServiceLoader;

public class ServiceLoaderTest {
    public static void main(String[] args) {
        // Optional<Cipher> cipher = cipherLoader.findFirst();
        Cipher cipher = getCipher(1);
        System.out.println("Проверка main()");

        if (cipher != null) {
            byte[] dataToEncrypt = "Hello my old fiend".getBytes();
            byte[] encryptionKey = {3};     // Ключ для шифрования


            byte[] encryptedData = cipher.encrypt(dataToEncrypt, encryptionKey);
            System.out.println("Шифруемые данные: " + new String(encryptedData));

            byte[] decryptedData =cipher.decrypt(encryptedData, encryptionKey);
            System.out.println("Дешифрованные данные: " + new String(decryptedData));

        } else {
            System.out.println("main(): Не найдена реализация шифра с необходимой стойкостью.");
        }
    }

    public static ServiceLoader<Cipher> cipherLoader = ServiceLoader.load(Cipher.class);

    public static Cipher getCipher(int minStrength) {
        // cipherLoader.iterator()
        for (Cipher cipher : cipherLoader) {
            System.out.println("Загружен шифр: " + cipher.getClass().getName());
            System.out.println("Стойкость шифра: " + cipher.strength());
            if (cipher.strength() >= minStrength) {
                System.out.println("Шифр найден с достаточной стойкостью.");
                return cipher;
            }
        }
        System.out.println("getCipher(): Не найдена реализация шифра с необходимой стойкостью.");
        return null;
    }

    public static Optional<Cipher> getCipher2(int minStrength){
        return cipherLoader.stream()
                .filter(descr -> descr.type() == ru.sectorsj._329_serviceLoader.impl.CaesarCipher.class)
                .findFirst()
                .map(ServiceLoader.Provider::get);
    }
}


директория:
\src
    \main
        \resources
            \META-INF
                \services
файл: ru.sectorsj._329_serviceLoader.Cipher
содержание: ru.sectorsj._329_serviceLoader.impl.CaesarCipher

// Также для работы в нашем модульном проекте понадобится:
// в файле module-info.java указать следующие директивы:
// module hortsmann_v_one {
//     - uses ru.sectorsj._329_serviceLoader.Cipher;
//     - provides Cipher with CaesarCipher;

// page 331
// 6.5 Прокси-классы

// Прокси-классы - классы посредники.
// Чтобы создавать во время выполнения программы новые классы,
// реализующие заданные интерфейсы.
// Прокси-классы требуются в том случае,
если на стадии компиляции еще неизвестно,
// какие именно интерфейсы следует реализовать.

// page 332
// 6.5.1 О применении прокси-классов
// Если требуется:
// 1. сконструировать объект класса, реализующего один или несколько интерфейсов,
      конкретные характеристики которых во время компиляции неизвестны
// 2. создать объект класса, реализующего эти интерфейсы.

->
// Прокси-класс может создавать во время выполнения совершенно новые классы и реализует те интерфейсы,
// В частности, в прокси-классе содержатся следующие методы.
// • Все методы, которые требуют указанные интерфейсы.
// • Все методы, определенные в классе Object (в том числе toString(), equals() и тд)

// Однако тогда нужно предоставить обработчик вызовов, т.е. объект любого класса,
// реализующего интерфейс InvocationHandler.
// В этом интерфейсе единственный метод объявляется следующим образом:
// Object invoke(Object proxy, Method method, Object[] args)

// page 332
// 6.5.2 Создние прокси-объектов
// метод newProxyinstance() из класса Proxy.
// Получает 3 параметра:
// 1. Загрузчик классов (глава 9 том 2)
// 2. Массив объектов типа Class - по одному на каждый реализуемый интерфейс
// 3. Обработчик вызовов.

// два вопроса:
// 1. как определить обработчик
// 2. что можно сделать с полученным в итоге прокси-объектом

// Применение прокси-объектов:
// 1. Переадресация вызовов методов на удаленный сервер.
// 2. Связывание событий, происходящих в пользовательском интерфейсе,
      с определенными действиями, выполняемыми в программе.
// 3. Отслеживание вызовов методов при отладке.

Данный пример - для отслеживания обращений к методам (вариант 3).

class TraceHandler implements InvocationHandler {
    private Object target;

    public TraceHandler(Object t) {
        target = t;
    }

    public Object invoke(Object proxy, Method m, Object[] args) trows Throwable {
        // вывести метод и его параметры
        ...
        // вызвать конкретный метод
        return m.invoke(target, args);
    }
}

// точка входа
public static void main(String[] args) {
    Object value = ...;

    // конструируем оболочку
    var handler = new TraceHandler(value);

    // конструируем прокси-объект для одного или нескольких интерфейсов
    var intrerfaces = new Class[] { Comparable.class };
    Object proxy = Proxy.newProxyInstance(
        ClassLoader.getSystemClassLoader(),
        new Class[] { Comparable.class }, handler
    );


    var elements = new Object[1000];

    // заполняем элементы прокси-объектами для целых чисел от 1 до 1000
    for (int i = 0; i < elements.length; i++){
        Integer value = i + 1;
        elements[i] = Proxy.newProxyInstance(...);      // прокси-объект для конкретного значения
    }
    // формируем случайное целое число
    Integer key = new Random().nextInt(elements.length) + 1;

    // выполняется поиск по заданному критерию key
    int result = Arrays.binarySearch(elements, key);

    // выводим совпавший элемент, если таковой найден
    if (result >= 0) {
        System.out.println(elements[result]);
    }
}

// Метод binarySearch() ->
// if (elements[i].compareTo(key) < 0) ...

// результаты полной трассировки при выполнении программы:
500.compareTo(288)
250.compareTo(288)
375.compareTo(288)
312.compareTo(288)
281.compareTo(288)
296.compareTo(288)
288.compareTo(288)
288.toString()


// page 336
// 6.5.3 Свойства прокси-классов

// Если дважды вызвать метод newProxyinstance() для одного и того же загрузчика классов и массива интерфейсов,
// будут получены два объекта одного и того же класса.
// Имя этого класса можно определить с помощью метода getProxyClass() следующим образом:

Class proxyClass = Proxy.getProxyClass(null, interfaces);

Прокси-класс всегда:
- открытый (public)
- конечный (final)

// 1. Если все интерфейсы, которые реализуются прокси-классом, объявлены как public,
//    этот класс не принадлежит ни одному конкретному пакету.

// В package1
public interface Interface1 { void method1(); }
public interface Interface2 { void method2(); }
// В package2
public class ProxyClass implements Interface1, Interface2 {
    public void method1() {
        System.out.println("Implementation of method1");
    }
    public void method2() {
        System.out.println("Implementation of method2");
    }
}
// В этом примере оба интерфейса (Interface1 и Interface2) объявлены с модификатором доступа public,
// поэтому ProxyClass может быть размещен в любом месте, не принадлежащем конкретному пакету.


// 2. В противном случае все интерфейсы, в объявлении которых не указан модификатор доступа public,
//    а следовательно, и сам прокси-класс, должны принадлежать одному пакету.

// В package1
interface Interface1 { void method1(); }
// В package2
public interface Interface2 { void method2(); }

// В package2
public class ProxyClass implements Interface1, Interface2 {
    public void method1() {
        System.out.println("Implementation of method1");
    }
    public void method2() {
        System.out.println("Implementation of method2");
    }
}
// Здесь Interface1 объявлен без модификатора доступа public, в то время как Interface2 является public.
// Следовательно, ProxyClass и оба интерфейса должны принадлежать одному пакету.
// В данном случае все они принадлежат package2.


// Вызвав метод isProxyClass() из класса Proxy, можно проверить,
// представляет ли объект типа Class определенный прокси-класс.



// page 339
// 7 глава: Исключения, Утверждения и Протоколирование
// • Обработка ошибок
// • Перехват исключений
// • Рекомендации по обработке исключений
// • Применение утверждений
// • Протоколирование
// • Рекомендации по отладке программ


// • Сообщить пользователю об обнаруженной программной ошибке.
// • Сохранить все результаты его работы.
// • Дать ему возможность благополучно завершить программу.


// page 340
// 7.1 Обработка ошибок

// 1. Вернуться в безопасное состояние и разрешить пользователю выполнить другие команды.
// 2. Дать пользователю возможность сохранить результаты своей работы и аккуратно завершить работу.

// Какие ошибки стоит предусмотреть в первую очередь:
// 1. Ошибки ввода
// 2. Сбои оборудования
// 3. Физические ограничения
// 4. Ошибки программирования

// page 341
// 7.1.1 Классификация исключений
// объект исключения - экземпляр класса, производного от класса Throwable.

// Иерархия наследования исключений:
Throwable
     \ Error                - внутренние ошибки, ситуации в связи с нехваткой ресурсов в среде java.
     \ Exception            - Попытка чтения по достижении конца файла
                            - Попытка открыть несуществующий файл
                            - Попытка получить объект типа Class, если в символьной строке указан несуществующий класс
         \ IOException      - ошибки ввода/вывода
         \ RuntimeException - следствие ошибок программирования
                            - Неверное приведение типов
                            - Выход за пределы массива
                            - Обращение к объекту по пустой сслыке (null)

// page 343
// 7.1.2 Объявление проверяемых исключений
// IOException - 1 глава 2 том книги

// Объявление о том, что данный метод может генерировать исключение
public FileInputStream(String name) throws FileNotFoundException

// Исключение генерируется в следующих четырех случаях.
1. Вызывается метод, генерирующий проверяемое исключение
2. Обнаружена ошибка и с помощью оператора throw явным образом
   генерируется проверяемое исключение (throw - в следующем разделе)
3. Обнаружена ошибка программирования
   пример: выражение а [-1] = О,
   вследствие чего возникает непроверяемое исключение,
   например, типа ArrayindexOutOfBoundsException
4. Возникает внутренняя ошибка в виртуальной машине или библиотеке исполняющей системы

Class MyAnimation {
    ...
    public Image loadImage(String s) throws IOException {
        ...
    }
}

// Если у метода есть несколько проверяемых исключений,
// все они должны быть перечислены в ero заrоловке через запятую,
Class MyAnimation {
    ...
    public Image loadImage(String s) throws FileNotFoundException, EOFException {
        ...
    }
}

// исключения, производные от класса Error, объявлять не нужно.
// не обязательно объявлять непроверяемые исключения,
// производные от класса RuntimeException
Class MyAnimation {
    ...
    public Image loadImage(String s) throws ArrayIndexOutOfBoundsException { // не рекомендуется
        ...
    }
}

// В методе должны быть объявлены все проверяемые исключения,
// которые он может сгенерировать.
// А непроверяемые исключения находятся вне контроля разработчика данного метода (класс Error)
// или же являются следствием логических ошибок,
// которые не следовало допускать (класс RuntimeException).
// Если же в объявлении метода не сообщается обо всех проверяемых исключениях,
// компилятор выдаст сообщение об ошибке.

// page 346
// 7.1.З Порядок генерирования исключений

readData()
// в заголовке указано Content-length: 1024
// но после 733 символа достигнут конец файла
->
throw new EOFException();
// или
var e = new EOFException();
throw e;

String readData(Scanner in) throws EOFException {
    ...
    while(...) {
        if (!in.hasNext()) {     // достигнут конец файла (признак EOF)
           if (n < len) throw new EOFException();
        }
        ...
    }
    return s;
}

// В классе EOFException имеется второй конструктор,
// получающий в качестве параметра символьную строку.
String gripe = "Content-length: " + len + ", Received: " + n;
throw new EOFException(gripe);

// 1. Найти подходящий класс
// 2. Создать экземпляр этого класса
// 3. Сгенерировать исключение

// page 347
// 7.1.4 Создание классов исключений

// Создание своего собственного класса исключения
class FileFormatException extends IOException {
    public FileFormatException() {}
    public FileFormatException(String gripe) {
        super(gripe);
    }
}

// Генерация исключения собственного типа
String readData (BufferedReader in) throws FileFormatException {
    ...
    while (...) {
        if (ch == -1) // достигнут конец файла (признак EOF) {
            if (n < len) throw new FileFormatException();
        }
        ...
    }
    return s
}

// page 348
// 7.2 Перехват исключений
// 7.2.1 Перехват одного исключения

// Перехват исключения осущесrвляется в блоке операторов try/catch
try {
    код
    дополнительный код
    дополнительный код
} catch (ТипИсключения e) {
    обработчик исключений данного типа
}
// Если фрагмент кода в блоке оператора try генерирует исключение типа,
// указанного в заголовке блока оператора catch, то программа:
// 1. пропускает оставшуюся часть кода в блоке оператора try.
// 2. выполняет код обработчика в блоке оператора catch.

// Если код в блоке оператора try не генерирует исключение, то программа:
// 1. пропускает блок оператора catch

// Если какой-нибудь оператор из блока try сгенерирует исключение,
// отличающееся от типа, указанного в блоке catch,
// то выполнение данной программы (в частности, вызываемого метода)
// немедленно прекращается.

// пример:
public void read(String filename) {
    try {
        var in = new FileInputStream(filename);
        int b;
        while ((b = in.read()) != -1) {
            обработать введенные данные
        }
    } catch (IOException exception) {
        exception.printStackTrace();
    }
}

// Передача исключения вызывающей части программы.
// Если в методе read() возникнет ошибка ввода,
// ответственность за обработку этой исключительной ситуации
// следует возложить на вызывающую часть программы
->
public void read(String filename) throws IOException {
    // блоки try/catch отсутствуют!
    var in = new FileInputStream(filename);
    int b;
    while ((b = in.read()) != -1) {
        обработать введенные данные
    }
}

// page 350
// 7.2.2 Перехват нескольких исключений

// В блоке оператора "try" можно перехватить несколько исключений, обработав их по отдельности.
// Для каждого типа исключения следует предусмотреть свой блок оператора "catch".

try {
    // код способный генерировать исключения
} catch (FileNotFoundException e) {
    // чрезвычайные действия, если отстутвуют нужные файлы
} catch (UnknownHostException e) {
    // чрезвычайные действия, если хосты неизвестны
} catch (IOException e) {
    // чрезвычайные действия во всех остальных случаях
    // появления ошибок ввода-вывода
}

// Объект исключения содержит сведения об объекте.
// вызов, чтобы получить доп.сведения об этом объекте из подробного сообщения об ошибке,
    e.getMessage()
// вызов, чтобы получить конкретный тип объекта исключения:
    e.getClass().getName()

// Объединение похожих исключений (после java 7):
try {
    // код способный генерировать исключения
} catch (FileNotFoundException | UnknownHostException e) {  // переменная исключения "e" неявно считается конечной (final)
    // чрезвычайные действия, если отстутвуют нужные файлы
    // или хосты неизвестны
} catch (IOException e) {
    // чрезвычайные действия во всех остальных случаях
    // появления ошибок ввода-вывода
}


// page 351
// 7.2.З. Повторное генерирование и связывание исключений в цепочку

// Исключение можно генерировать и в блоке catch, образуя тем самым цепочку исключений.
// Если разрабатывается подсистема для применения другими разработчиками,
// то имеет смысл генерировать исключения, указывающие на то,
// что ошибка возникла именно в этой подсистеме.

try {
    // получить доступ к базе данных
} catch (SQLException ex) {
    // текст сообщения об исключении формируется в конструкторе класса ServletException.
    throw new ServletException("database error: " + ex.getMessage());
}

try {
    // получить доступ к БД
} catch (SQLException original) {
    var e = new ServletException("database error");
    e.initCause(original);
    throw e;
}

// При перехвате последующего исключения, предыдущее исключение можно извлечь следующим образом:
Throwable original = caughtException.getCause();

// Регистрация исключения и повторная его генерация, без всяких изменений:
try {
    // получить доступ к БД
} catch (Exception e) {
    logger.log(level, message, e);
    throw e;
}
// -> допустимо после версии java 7:
public void updateRecord() throws SQLException


// page 352
// 7.2.4 Блок оператора finally

// В java 7 появилось более удачное решение - try с ресурсами

// Код в блоке оператора finally выполняется независимо от того, возникло исключение или нет.
var in = new FileInputStream();
try {
    // 1
    // Код, способный генерировать исключения
    // 2
} catch (IOException e) {
    // 3
    // Выводим сообщение об ошибке
    // 4
} finnaly {
    // 5
    in.close
}
// 6

// 3 варианта в которых программа выполняет блок оператора finally:
// 1. Код не генерирует никаких исключений. В этом случае программа сначала
//    полностью выполняет блок оператора try, а затем блок оператора finally.
//    Выполнение программы последовательно проходит через точки 1, 2, 5, 6.

// 2. Код генерирует исключение, которое перехватывается в блоке оператора catch
//    в данном примере это исключение типа IOException).
//    В этом случае программа сначала выполняет блок try до той точки,
//    в которой возникает исключение, а остальная часть блока оператора try пропускается.
//    Затем программа выполняет код из соответствующего блока оператора catch,
//    и далее код из блока оператора finally.
//    Если в блоке оператора catch исключения не генерируются,
//    то выполнение программы продолжается с первой строки, следующей после блока оператора try.
//    Таким образом, выполнение программы последовательно проходит через точки 1, 3, 4, 5 и 6.
//    Если же исключение генерируется в блоке оператора catch,
//    то управление передается вызывающей части программы и выполнение программы
//    проходит только через точки 1, 3 и 5.

// 3. Код генерирует исключение, которое не обрабатывается в блоке оператора catch.
//    В этом случае программа выполняет блок try вплоть до той точки,
//    в которой генерируется исключение, а оставшаяся часть блока оператора try пропускается.
//    Затем программа выполняет код из блока оператора finally
//    и передает исключение обратно вызывающей части программы.
//    Таким образом, выполнение программы проходит только через точки 1 и 5.

// Блок оператора finally можно использовать и без блока оператора catch.
InputStream in = ...;
try {
    // Код, способный генерировать исключения
} finally {
    in.close();
}
// -> Оператор in.close() из блока finally выполняется независимо от того, возникает ли исключение в блоке try.

// Если исключение возникает, оно будет перехвачено в очередном блоке саtch:
InputStream in = ...;
try {
    try {
        // Код, способный генерировать исключения
    } finally {
        in.close();
    }
} catch (IOException) {
    // вывести сообщение об ошибке
}

// Здесь внутренний блок оператора try отвечает только за закрытие потока ввода,
// а внешний блок оператора try сообщает об ошибках.
// Такой код не только более понятен, но и более функционален,
// поскольку ошибки выявляются и в блоке оператора finally.

public static int parseInt(String s) {
    try {
        return Integer.parseInt(s);
    } finally {
        return 0;   // Ошибка!
    }
}
// На первый взгляд, если сделать вызов parseInt("42"),
// то из блока оператора try должно возвратиться целочисленное значение 42.
// Но блок оператора finally выполняется прежде возврата из метода Integer.parseInt(),
// и поэтому данный метод возвратит нулевое значение,
// пренебрегая первоначальным возвращаемым значением.

// Хуже того, если сделать вызов parseint ("zero"),
// то в методе Integer.parseInt() будет сгенерировано исключение типа NuшЬerFormatException.
// А затем будет выполнен блок оператора finally, где оператор return поглотит исключение!
// Блок оператора finally предназначен для освобождения ресурсов.
// Поэтому в нем не следует размещать операторы (return, throw, break, continue),
// изменяющие порядок выполнения прикладного кода.

// "Вызывающая часть программы" относится к тому участку кода,
// который вызвал метод, в котором произошло исключение.
// Когда исключение не может быть обработано в текущем методе,
// оно "передается" или "поднимается" выше по стеку вызовов к ближайшему контексту,
// который может обработать это исключение.

// Предположим, у вас есть метод foo(), который вызывает метод bar(),
// а метод bar() бросает исключение, которое не обрабатывается в методе bar().
// В этом случае исключение будет передано обратно в метод foo(), который вызвал метод bar().
// Если исключение также не будет обработано в методе foo(), оно будет передано еще выше по стеку вызовов.

// "Вызывающая часть программы" может быть методом из вашего собственного класса,
// сторонней библиотеки или даже системным вызовом.
// Это часть кода, которая вызвала текущий метод, где произошло исключение.

public class Example {
    public static void main(String[] args) {
        try {
            foo();
        } catch (Exception e) {
            System.out.println("Исключение обработано в методе main: " + e.getMessage());
        }
    }

    public static void foo() throws IOException {
        bar();
    }

    public static void bar() throws IOException {
        throw new IOException("Исключение в методе bar");
    }
}
// Здесь метод bar() бросает исключение, которое не обрабатывается в нем самом.
// Тогда исключение передается обратно в метод foo(), который вызвал bar(),
// а затем перехватывается в методе main(), который вызвал foo().
// Таким образом, метод main() является "вызывающей частью программы" в этом контексте.


// "Освободить ресурсы" - означает освобождение занимаемых программой ресурсов после их использования.
// Ресурсы могут включать в себя файлы, сетевые соединения,
// базы данных, память, блокировки и другие системные ресурсы.

// В языках программирования, таких как Java, C++, Python и других,
// управление ресурсами является важным аспектом программирования.
// Если ресурсы не будут освобождены правильно после использования,
// это может привести к утечкам ресурсов и, как следствие,
// к неэффективному использованию памяти, перегрузке системы или даже к ошибкам работы программы.

Примеры освобождения ресурсов:

1. Закрытие файловых потоков после чтения или записи данных в файл.
2. Закрытие сетевых соединений после передачи данных по сети.
3. Освобождение памяти, выделенной под объекты, которые больше не нужны, с помощью сборщика мусора.
4. Закрытие баз данных после выполнения запросов или обновлений.
5. Освобождение блокировок или других ресурсов синхронизации после завершения работы с ними.

// В контексте программирования и управления ресурсами,
// термин "ресурсы" может относиться к различным видам ресурсов,
// как физическим, так и программным.

// 1. Физические ресурсы могут включать в себя такие объекты как:
    // - файлы
    // - сетевые соединения
    // - базы данных
    // - порты ввода-вывода (например, ввод с клавиатуры или вывод на экран)
    // - память (например, выделенная память или файл подкачки)
    // - устройства ввода-вывода (например, принтеры, сканеры)
    // и т. д.

// 2. Программные ресурсы могут включать в себя:
    // - объекты в памяти, созданные в ходе выполнения программы
    // - потоки данных
    // - блокировки
    // - семафоры
    // - указатели на области памяти и т.д.

// Управление физическими и программными ресурсами одинаково важно в программировании.
// В обоих случаях освобождение ресурсов после их использования
// способствует эффективному использованию ресурсов компьютерной системы
// и предотвращает утечки памяти или другие проблемы,
// связанные с неправильным управлением ресурсами.


// page 355
// 7.2.5 Оператор try с ресурсами

// В версии Java 7 внедрена следующая удобная конструкция,
// упрощающая код обработки исключений, где требуется освобождать используемые ресурсы:

// открыть ресурс
try {
    // использовать ресурс
} finally{
    // закрыть ресурс
}

// Эта конструкция эффективна при одном условии: используемый ресурс принадлежит классу,
// реализующему интерфейс AutoCloseable.

// В этом интерфейсе имеется единственный метод:
void close() throws Exception

// Существует еще интерфейс Closeable, также реализующий 1 метод - close()
// Но этот интерфейс объявляется для генерации исключения типа - IOException

try (Resource res = ...) {
    использовать ресурс res
}

// Если в коде имеется блок оператора try, то метод res.close() вызывается автоматически.
// Пример ввода всего текста из файла и последующего его вывода:
try (var in = new Scanner (new FileInputStream ("/user/share/dist/words"), StandardCharsets.UTF8)) {
    while (in.hasNext()) System.out.println(in.next());
}

// Независимо от того, происходит ли выход из блока оператора try нормально,
// или же в нем возникает исключение, метод in.close() вызывается в любом случае,
// как и при использовании блока оператора finally.

// В блоке оператора try можно указывать несколько ресурсов
try (var in = new Scanner (
                new FileInputStream("/usr/share/dist/words"), StandardCharsets.UTF_8);
                var out = new PrintWriter("out.txt", StandardCharsets.UTF_8)) {
    while (in. hasNext()) out.println(in.next().toUpperCase());
}

// В версии Java 9 появилась возможность предоставлять предварительно объявляемые
// действительно конечные переменные в заголовке оператора try:
public static void printAll (String[] lines, PrintWriter out) {
    try (out) {     // действительно конечная переменная
        for (String line: lines) out.println(line);
    }               // здесь делается вызов out.close()
}

// Если исключение генерируется не только в блоке оператора try, но и в методе close().
// Исходное исключение генерируется повторно, а любые исключения, генерируемые в методе close(),
// считаются "подавленными".
// Они автоматически перехватываются и добавляются к исходному исключению с помощью метода addSuppressed().
// Если они представляют какой-то интерес с точки зрения обработки, то следует вызвать метод getSuppressed(),
// получающий массив подавленных исключений из метода close().

// page 356
// 7.2.6 Анализ элементов трассировки стека

// Трассировка стека - это список вызовов методов в данной точке выполнения программы.
// Ведь они выводятся всякий раз, когда при выполнении программы на Java
// возникает непроверяемое или необрабатываемое исключение.

// Для получения текстового описания трассировки стека
// достаточно вызвать метод printStackTrace() из класса Throwable

var t = new Throwable();
var out = new StringWriter();
t.printStackTrace(new PrintWriter(out));
String description = out.toString();

// можно использовать StackWalker ->
// StackWalker.StackFrame

StackWalker walker = StackWalker.getInstance();
walker.forEach (frame -> проанализировать frame)

// В классе StackWalker.StackFrarne имеются методы для получения:
// - имени файла
// - номера строки кода,
// - объекта анализируемого класса
// - имени метода из исполняемой строки кода.

// Вычисление факториала числа 3
// Результаты трассировки стека вызова factorial(3):
Введите n: 3
factorial(3):
hortsmann_v_one/ru.sectorsj._357_stackTrace.StackTraceTest.factorial(StackTraceTest.java:22)
hortsmann_v_one/ru.sectorsj._357_stackTrace.StackTraceTest.main(StackTraceTest.java:10)
factorial(2):
hortsmann_v_one/ru.sectorsj._357_stackTrace.StackTraceTest.factorial(StackTraceTest.java:22)
hortsmann_v_one/ru.sectorsj._357_stackTrace.StackTraceTest.factorial(StackTraceTest.java:25)
hortsmann_v_one/ru.sectorsj._357_stackTrace.StackTraceTest.main(StackTraceTest.java:10)
factorial(1):
hortsmann_v_one/ru.sectorsj._357_stackTrace.StackTraceTest.factorial(StackTraceTest.java:22)
hortsmann_v_one/ru.sectorsj._357_stackTrace.StackTraceTest.factorial(StackTraceTest.java:25)
hortsmann_v_one/ru.sectorsj._357_stackTrace.StackTraceTest.factorial(StackTraceTest.java:25)
hortsmann_v_one/ru.sectorsj._357_stackTrace.StackTraceTest.main(StackTraceTest.java:10)
return 1
return 2
return 6

// page 361
// 7.3 Рекомендации по обработке исключений

// Рекомендации по применению и обработке исключений в прикладных программах:
1. Обработка исключений не может заменить собой простую проверку

if (!s.empty)) s.pop();

try {
    s.pop
} catch (EmptyStackException e) {}

// Перехват исключения занимает намного больше времени, чем просrая проверка.
// Вывод: пользоваться исключениями только в тех случаях, когда это оправданно,
// что зачастую бывает лишь в исключительных ситуациях.

// 2. Не доводить обработку исключений до абсурдных мелочей

// неправильно
PrintStream out;
Stack s;
for (int i = 0; i < 100; i++) {
    try {
        n = s.pop();
    } catch (EmpryStackException) {
        // Стек оказася пуст
    }
    try {
        out.writInt(n);
    } catch (IOException) {
        // сбой при записи данных в файл
    }
}

// правильно
PrintStream out;
Stack s;
for (int i = 0; i < 100; i++) {
    n = s.pop;
    out.writeInt(n)
} catch (IOException) {
    // сбой при записи данных в файл
} catch (EmptyStackException) {
    // стек оказался пустым
}

// 3. Правильно пользуйтесь возможностями,
//    которые прежоставляет иерархия наследования исключений

// - Не ограничивайтесь генерированием только исключения типа RuntimeException.
// - Найдите подходящий подкласс или создайте собственный.
// - Не перехватывайте исключение типа Throwable.
// - Правильно различайте проверяемые и непроверяемые исключения.
// - Смело преобразуйте, если требуется, один тип исключения в другой,
//   более подходящий в данной ситуации.

// 4. Не подавляйте исключения
// неправильно
public Image loadImage (String s) {
    try {
        // код, способен генерировать проверяемые исключения
    } catch (Exception e)
    {} // ничего не делать
}

// 5. Обнаруживая ошибки, проявляйте необходимую твердость
//    вместо излишней терпимости

// Пример: лучше сгенерировать исключение типа EmptyStackException в той точке,
// где возникла ошибка, чем исключение типа NullPointerException впоследствии.

// 6. Не бойтесь передавать исключения для обработки в коде,
//    разрабатываемом другими.

// Предпочтительнее передать исключение другому обработчику,
// а не обрабатывать его самостоятельно,
public void readStuff(String filename) throws IOException { // Не нужно этого стесняться!
    var in = new FileInputStream (filename, StandardCharsets.UTF_8);
    ...
}
// Методы более высокого уровня лучше оснащены средствами уведомления пользователей
// об ошибках или отмены выполнения неверных операций.

// пп.5, 6 -> генерировать исключения раньше, а перехватывать их позже.

// page 364
// 7.4 Применение утверждений (assert)
// Утверждения (assert) - широко распространенное средство безопасного программирования.

// page 364
// 7.4.1 Понятие утверждения

double у = Math.sqrt(x); // уверены, что значение параметра х не является отрицательным
->
// можно сгенерировать исключение:
if (x < 0) throw new IllegalArgumentException("x < 0");

// но, тогда этот код будет оставаться в программе, даже после тестирования
// Если в исходном коде программы расставлено много таких проверок,
// ее выполнение может замедлиться.

// Механизм утверждений позволяет вводить в исходный код программы проверки для ее тестирования,
// а затем удалять их из окончательного варианта.

// Форма:
// 1. assert условие;
//      и
// 2. assert условие : выражение;

// 1, 2 форма проверяют заданное условие и генерируют исключение типа AssertionError, если оно не выполняется.
// 2 форма, в операторе "выражение" передается конструктору объекта типа AssertionError
// и преобразуется в символьную строку сообщения.

// Цель, которую преследует "выражение" в операторе assert, получить символьную строку сообщения.
// В объекте типа AssertionError конкретное значение выражения не хранится,
// поэтому его нельзя запросить в дальнейшем.

// чтобы проверить, является ли числовое значение переменной х неотрицательным:
assert x >= 0;

// Можно передать конкретное значение переменной "х" объекту типа AssertionError,
// чтобы впоследствии вывести его:
assert x >= 0 : x;

// Можно передать в виде символьной строки объекту типа AssertionError:
assert x >= 0 : "x >= 0";

// page 365
// 7.4.2 Разрешение и запрет утверждений

// По умолчанию утверждения запрещены.
// В ходе выполнения программы можно с помощью параметров:
    -enableassertions или -еа   - разрешить утверждения
    -desableassertions или -dа  - запретить утверждения

// указываемого в командной строке следующим образом:
    java -enableassertions МуАрр
    java -desableassertions МуАрр

// Разрешать утверждения можно в:
// - отдельных классах             -ea:MyClass
// - в целых пакетах               -ea:com.mycompany.mylib MyApp
// - во всех классах из пакета,    -ea...
//   выбираемого по умолчанию

java -ea:MyClass -ea:com.mycompany.mylib MyApp -ea...
java -da:MyClass

// Для разрешения утверждений в системных классах без загрузчика классов:
    -enablesystemassertions/-esa

// page 366
// 7.4.3 Проверка параметров с помощью утверждений

// 3 механизма обработки системных сбоев:
// 1. Генерирование исключений (Exceptions)
// 2. Протоколирование
// 3. Применение утверждений (Asserts)

// 1. Утверждения оказываются ложными, если произошла неустранимая ошибка
// 2. Утверждения разрешаются только на время отладки и тестирования программ


/**
    Упорядочивает указанную часть заданного массива по нарастающей.
    Упорядочиваемая часть массива начинается с индекса fromIndex и заканчивается индексом,
    предшествующим toIndex, т.е. элемент с индексом toIndex упорядочению не подлежит.
    @param а            Упорядочиваемый массив
    @param fromIndex    Индекс первого элемента упорядочиваемой части массива (включительно)
    @param toIndex      Индекс первого элемента, находящегося за пределами упорядочиваемой части массива
    @throws IllegalArgumentException        Если fromIndex > toIndex, генерируется исключение
    @throws ArrayindexOutOfBoundsException  Если fromIndex < О или toIndex > a.length, генерируется исключение
*/
static void sort[] а, int fromIndex, int toIndex
// если к примеру добавить гипотетическое условие
// -> @param а Упорядочиваемый массив. (Не должен быть пустым)
// тогда это будет считаться предусловием.
// ->
assert (a != null); // можно использовать

// page 367
// 7.4.4 Документирование предположений с помощью утверждений

if (i % 3 == 0)
    ...
else if (i % 3 == 1)
    ...
else // (i % 3 == 2)

-> //
if (i % 3 == 0)
    ...
else if (i % 3 == 1)
    ...
else {
    assert i % 3 == 2;
}

// Если переменная i принимает положительное числовое значение, то остаток может быть равным О, 1 или 2.
// А если она принимает отрицательное значение, то остаток может быть равным -1 или -2.
// Намного логичнее предположить, что переменная i не содержит отрицательное числовое значение.
->
assert(i >= 0); // вводим утверждение
if (i % 3 == 0)
    ...
else if (i % 3 == 1)
    ...
else {
    assert i % 3 == 2;
}

// page 368
// 7.5 Протоколирование

// Прикладной программный интерфейс API для протоколирования:
// 1. Все протокольные записи нетруджно запретить или разрешить
// 2. Запрещенные протокольные записи отнимают немного ресурсов и не влияют на эффективность работы приложения
// 3. Протокольные записи можно направить разным обработчикам, вывести на консоль, записать в файл и т.п.
// 4. Регистраторы и обработчики способны фильтровать записи. Фильтры отбрасывают ненужные записи по критериям,
//    предоставляемым теми, кто реализует фильтры
// 5. Протокольные записи допускают форматирование. Пример, представить в виде простого текста или в
//    формате XML
// 6. В приложения можно использовать несколько протоколов, имеющих иерархические имена, продобные именам пакетов,
//    например: com.mycompany.myapp
// 7. Конфигурирование протоколирования определяется в файле конфигураций.

// Во многих приложениях применяются другие библиотеки протоколирования, в том числе:
// Log4J 2 (https://logging.apache.org/log4j/2.x)
// Logback (https://logback.qos.ch),
// обеспечивающие более высокую производительность, чем стандартная для Java библиотека протоколирования.

// Такие библиотеки несколько отличаются своими прикладными интерфейсами API.
// Такие фасады протоколирования, как:
// SLF4J           (https://www.slf4j.org)
// Commons Logging (https://commons.apache.orq/proper/coппnons-logging),
// предоставляют единообразный прикладной интерфейс API,
// чтобы можно было сменить библиотеку протоколирования,
// не переписывая прикладной код. Дело усложняется еще и тем,
// что библиотека Log4J 2 может служить фасадом для таких компонентов, как SLF4J.

// В настоящем издании рассматривается стандартная библиотека протоколирования в Java.
// Целесообразно изучить прикладной интерфейс API этой библиотеки, чтобы лучше понять имеющиеся ее альтернативы.

// page 369
// 7.5.1 Базовое протоколирование

// Для базового протоколирования служит глобальный регистратор:
Logger.getGlobal().info("File-> Open menu item selected");
->
// По умолчанию выводится следующая протокольная запись:
// Мау 10, 2013 10:12:15 РМ LoggingimageViewer fileOpen INFO: File->Open menu item selected


// page 369
// 7.5.2 Продвинутое логирование

// При профессиональной разработке приложений, все записи не накапливаются в одном глобальном протоколе (логе),
поэтому можно определить свои собственные средства протоколирования (логирования).

// Регистратор, на который больше не делается ссылка ни в одной из переменных, собирается в "мусор".
// по-этому, следует сохранить ссылку на регистратор в статической переменной, как показано ниже!

// Для создания или извлечения "регистратора" вызывается метод - getLogger():
private static final Logger myLogger = Logger.getLogger("com.my.company.myapp");

// Как и имена пакетов, имена регистраторов образуют иерархию.
// иерархичные = регистратор > пакет ->
// Если в регистраторе "com.mycompany" задать определенный уровень протоколирования,
// то производный от него регистратор унаследует этот уровень.

// 7 уровней протоколирования (логирования):
// 1. SEVERE  - используется по умолчанию
// 2. WARNING - используется по умолчанию
// 3. INFO    - используется по умолчанию
// 4. CONFIG  - нужно задавать методом setLevel()
// 5. FINE    - нужно задавать методом setLevel() -> logger.setLevel(Level.FINE);
// 6. FINER   - нужно задавать методом setLevel()
// 7. FINEST  - нужно задавать методом setLevel()

logger.setLevel(Level.ALL)                  // Разрешение логирования на всех уровнях
Logger.getGlobal().setLevel(Level.ALL);     // Разрешение логирования на всех уровнях, Глобально

logger.setLevel(Level.OFF)                  // Полностью запрещает протоколирование (логирование)
Logger.getGlobal().setLevel(Level.OFF);     // Полностью запрещает логирование, Глобально

// Для всех уровней определены методы протоколирования:
logger.warning(message);
logger.fine(message);

logger.log(Level.FINE, message);    // метод log() - явно указать уровень логирования

// Для отладочных сообщений, требующихся для диагностики программ (не для пользователей), следует указывать уровни:
// - CONFIG
// - FINE
// - FINER
// - FINEST

// Обработчик протоколов блокирует сообщения, имеющие уровень ниже INFO.

// Протокольная запись, создаваемая по умолчанию, состоит из:
// - имени класса
// - имени метода, содержащего вызов регистратора

// Для уточнения вызывающего класса и метода следует применить метод logp():
void logp(Level l, String className, String method, String message)

// Для отслеживания порядка выполнения диагностируемой программы есть методы:
void entering(String className, String methodName);
void entering(String className, String methodName, Object param);
void entering(String className, String methodName, Object[] params);
void exiting(String className, String methodName);
void exiting(String className, String methodName, Object result);

// пример:
int read(String file, String pattern) {
    logger.entering("com.mymompany.mylib.Reader", "read", new Object[] {file, pattern});
    ...
    logger.exiting("com.mycompany.mylib.Reader", "read", count);
    return count;
}

// Если методы протоколирования будут поддерживать
// переменное число параметров, то тогда станет доступна запись:
logger.entering("com.mycompany.mylib.Reader", "read", file, pattern);

// 2 метода для логирования неожиданных исключений:
void throwing (String className, StringMethodName, Throwable t);
void log (Level l, String message, Throwable t);

// При вызове метода throwing() регистрируется протокольная запись,
// имеющая уровень FINER, а также сообщение, начинающееся со строки THROW
//
if (...) {
    IOException exception = new IOException("...");
    logger.throwing("com.mycompany.mylib.Reader", "read", exception);
    throw exception;
}
и
try {
    ...
} catch (IOException e) {
    Logger.getLogger("com.mycompany.myapp").log(Level.WARNING, "Reader image", e);
}

// page 371
// 7.5.3 Смена диспетчера протоколирования

// Свойства системы протоколирования можно изменить, редактируя конфигурационный файл,
// по умолчанию находящийся по следующему пути:
// conf/loggin.properties
// или
// jre/lib/logging.properties

// Если требуется сменить конфигурационный файл, при запуске приложения,
// необходимо установить свойство "java.util.logging.config.file" на ->
// command: java -Djava.util.logging.conf.file=конфигурационный_файл Главный класс

// Чтобы изменить уровень протоколирования, принятый по умолчанию,
// необходимо отредакгировать конфиrурационный файл, изменив в нем следующую строку:
    .level=INFO

// Чтобы в собственных регистраторах изменить уровни протоколирования
// необходимо добавить к имени регистратора суффикс ".level":
com.mycompany.myapp.level=FINE

// Регистраторы не направляют сообщения на консоль
// Направлять сообщения в консоль - задача обработчиков протоколов

// Чтобы вывести на консоль сообщения, имеющие уровень FINE нужно:
java.util.logging.ConsoleHandler.level=FINE

// Параметры настройки диспетчера протоколирования не являются системными свойствами.
// Запуск прикладной программы с параметром:
// command: -Dcom.mycompany.myapp.level=FINE
// никак не отражается на действиях регистратора.

// Если нужно настроить протоколирование программно в коде, не используя файл конфигурации
// или параметр командной строки, это можно сделать:
System.setProperty("java.util.logging.config.file", file);

// Пример:
System.setProperty("java.util.logging.config.file", "C:/Program Files/Java/jdk/jdk-21.0.2/conf.logging.properties");

// Повторная инициализация диспетчера протоколирования:
// После установки свойства конфигурации протоколирования программно с помощью System.setProperty(),
// также нужно повторно инициализировать диспетчер протоколирования с помощью
LogManager.getLogManager().readConfiguration().
// Это гарантирует, что новая конфигурация будет применена.
// Пример:
try {
    LogManager.getLogManager().readConfiguration();
} catch (IOException e) {
    System.err.println ("Не удалось прочитать файл конфигурации протоколирования");
    e.printStackTrace();
}

// Hачиная с версии java 9, можно обновить конфигурацию логирования с помощью:
LogManager.getLogManager().updateConfiguration(mapper);

// для определения значений по всем ключам в прежней или новой конфигурации
// применяется специальный сопоставитель типа:
Function<String, BiFunction<String, String, String>>

// В качестве удобной схемы сопоставления можно было бы объединить прежние и новые конфигурации,
// отдав предпочтение новому значению, когда ключ присутствует как в прежних,
// так и в новых конфигурациях:
key -> ((oldValue, newValue) -> newValue == null ? oldValue : newValue)

// Если требуется лишь обновить ключи, начиная с com.mycompany, оставив остальные ключи без изменения:
key -> key.startWith("com.mycompany")
    ? ((oldValue, newValue) -> newValue)
    : ((oldValue, newValue) -> oldValue)

// Для изменения поведения по умолчанию можно использовать следующие подходы:
// 1. Изменение менеджера протоколирования:
System.setProperty("java.util.logging.manager", "com.example.MyLogManager");

// 2. Изменение настроек без изменения менеджера протоколирования:
System.setProperty("java.util.logging.config.class", "com.example.MyLoggingConfigurator");

// затем в классе MyLoggingConfigurator:

package com.example;

import java.util.logging.Level;
import java.util.logging.Logger;

public class MyLoggingConfigurator {
    public static void configure() {
        // Настройки протоколирования
        Logger logger = Logger.getLogger("");
        logger.setLevel(Level.FINE);
    }
}


// page 373
// 7.5.4 Локализация
// Подробнее (7 глава 2 том)
// В состав прикладной программы может входить несколько комплектов ресурсов,
// например:
// один   - для меню,
// другой - для протокольных сообщений.
// У каждого комплекта ресурсов имеется свое имя (например, "com.mycompany.logmessages").
// Для того чтобы ввести сопоставление в комплект ресурсов,
// следует предоставить файл для региональных настроек на соответствующем языке.

// Сопоставления сообщений на английском языке находятся в файле:
//      com/mycompany/logmessages_en.properties
// Сопоставления сообщений на немецком языке - в файле:
//      com/mycompany/logmessages_de.properties
// Здесь пары символов en и de обозначают стандартные коды языков.

// Объединение файлов осущесrвляется с помощью классов прикладной программы.
// В частности, класс обнаруживает их автоматически:
class ResourceBundle

// Содержимое этих файлов состоит из записей простым текстом:
readingFile=Achtung! Datei wird eingelesen      // Прочтение файла
renamingFile=Datei wird umbenannt               // Переименовывание файла
...

// При вызове регистратора сначала указывается конкретный комплект ресурсов:
Logger logger = Logger.getLogger(loggerName, "com.mycompany.logmessages");

// для составления протокольного сообщения указывается ключ из комплекта ресурсов,
// но не строка самого сообщения:
logger.info("readingFile");

// Включать какие-нибудь арrументы в локализованные сообщения.
// Тогда сообщение должно иметь заполнители {О}, {1} и т.д.
// Пример:
Reading file {0}.
Achtung! Datei {О} wird eingelesen.

// Заполнители заменяются соответствующими значениями при вызове одного из следующих методов:
logger.log(Level.INFO, "readingFile", fileName);
logger.log(Level.INFO, "readingFile", new Object[] {oldName, newName});

// Начиная с java 9, в методе logrb() можно указать объект комплекта ресурсов, а не его имя:
logger.logrb(Level.INFO, bundle, "renamingFile", oldName, newName);

// page 374
// 7.5.5 Обработчики протоколов (Handlers)
// По умолчанию логгеры посылают протокольные записи объекту класса ConsoleHandler,
// который выводит их в поток сообщений об ошибках System.err.

// Также как и регистраторы (логгеры) у обработчиков логов имеются свои уровни.
// Уровень протоколирования записи должен превышать порог как для:
// - регистратора (логгера)
// - обработчика

// Уровень консольного обработчика по умолчанию задается в файле,
// содержащем параметры настройки диспетчера протоколирования:
java.util.logging.ConsoleHandler.level=INFO

// Для регистрации записи, имеющей уровень FINE, в конфиrурационном файле
// следует изменить исходный уровень протоколирования для:
// - регистратора
// - обработчика

// С другой стороны, можно вообще пренебречь файлом конфиrурации
// и установить свой собственный обработчик протоколов:
    Logger logger = Logger.getLogger("com.mycompany.myapp");
    logger.setLevel(Level.FINE);
    logger.setUseParentHandlers(false); // чтобы все протокольные записи не выводили дважды
    var handler = new ConsoleHandler();
    handler = setLevel(Level.FINE);
    logger.addHandler(handler);

// В прикладном интерфейсе API для протоколирования предоставляются два класса обработчиков протоколов (логов):
// 1. SocketHandler   - посылает протокольные записи на указанный хост и в порт
// 2. FileHandler - выводит протокольные записи в файл

// Логи передаются в FileHandler (обработчик по умолчанию) для записи в файл
    var handler = new FileHandler();
    logger.addHandler(handler);
// Протокольные записи выводятся в файл jаvаn.log, который находится в начальном каталоге пользователя,
// где n - однозначный номер, отличающий этот файл от других аналогичных файлов.
// По умолчанию протокольные записи хранятся в формате XML.
// Обычная протокольная запись:
<record>
    <date>2002-02-04T07:45:15</date>                // дата в формате ISO 8601 (год-месяц-деньTчас:минута:секунда)
    <millis>1012837515710</millis>                  // время (с 01.01.1970)
    <sequence>1</sequence>                          // порядковый номер события в пределах потока
    <logger>com.mycompany.myapp</logger>            // имя логгера, который сгенерировал данное сообщение
    <level>INFO</level>                             // уровень логирования сообщения (например, INFO, WARNING, ERROR)
    <class>com.mycompany.mylib.Reader</class>       // имя класса, из которого была сделано запись в журнал
    <method>read</method>                           // имя метода, который сделал запись в журнал
    <thread>10</thread>                             // имя потока, в котором произошло событие протоколирования
    <message>Reading file corejava.gif</message>    // текст сообщения, которое было зарегистрировано
</record>

// Поведение исходного обработчика протоколов типа FileHandler можно изменить:
// 1. задав другие параметры настройки в диспетчере протоколирования (табл. 7.1)
// 2. воспользоваться другим конструктором
// Обычно, имя файла протокола, предлагаемое по умолчанию, не используется.
// -> Для него нужно задать другой шаблон, например %h/myapp.log (переменные шаблона описаны в табл. 7.2).

// Таблица 7.1. Параметры настройки обработчика протоколов типа FileHandler
|-----------------------------------------|--------------------------------------|----------------------------------|
|         Настраиваемое свойство          |               Описание               |       Значение по умолчанию      |
|-----------------------------------------|--------------------------------------|----------------------------------|
| java.util.logginq.FileHandler.level     | Уровень обработчика                  | Level.ALL                        |
|-----------------------------------------|--------------------------------------|----------------------------------|
| java.util.logginq.FileHandler.append    | Определяет, должен ли обработчик     | false                            |
|                                         | добавлять записи в существующий файл |                                  |
|                                         | или же открывать новый файл при      |                                  |
|                                         | очередном запуске программы          |                                  |
|-----------------------------------------|--------------------------------------|----------------------------------|
| java.util.logginq.FileHandler.limit     | Приблизительная оценка максимального | 0(т.е. без ограничений) в классе |
|                                         | размера файла. При превышении этого  | FileHandler; 50000 в исходной    |
|                                         | размера открывается новый файл       | конфигурации диспетчера          |
|                                         | (0 - размер файла не ограничен)      | протоколирования                 |
|-----------------------------------------|--------------------------------------|----------------------------------|
| java.util.logging.FileHandler.pattern   | Шаблон имени файла nротокола         | %h/java%u.log                    |
|                                         | (см.табл. 7.2)                       |                                  |
|-----------------------------------------|--------------------------------------|----------------------------------|
| java.util.logging.FileHandler.count     | Количество файлов nротокола,         | 1 (ротация не nроизводится)      |
|                                         | участвующих в ротации                |                                  |
|---------------------------------------- |--------------------------------------|----------------------------------|
| java.util.logging.FileHandler.filter    | Класс, исnользуемый для фильтрации   | Фильтрация отсутствует           |
|-----------------------------------------|--------------------------------------|----------------------------------|
| java.util.logging.FileHandler.encoding  | Применяемая кодировка                | Кодировка, nринятая на текущей   |
|                                         |                                      | nлатформе                        |
|-----------------------------------------|--------------------------------------|----------------------------------|
| java.util.logging.FileHandler.formatter | Средство форматирования nротокольных | java.util.logging.XМLFormatter   |
|                                         | записей                              |                                  |
|-----------------------------------------|--------------------------------------|----------------------------------|

// Таблица 7.2. Переменные шаблона для имени файла протокола
|--------------|------------------------------------------------------------------------------------|
|  Переменная  |                                      Описание                                      |
|--------------|------------------------------------------------------------------------------------|
|      %h      | Значение системного свойства user.home                                             |
|      %t      | Временный системный каталог                                                        |
|      %u      | Однозначный номер, nозволяющий избежать конфликта имен                             |
|      %g      | Определяет режим формирования номеров для nодвергаемых ротации файлов nротоколов.  |
|              | (Если ротация nроизводится, а в шаблоне отсутствует nеременная %g, то исnользуется |
|              | суффикс .%g)                                                                       |
|      %%      | Знак % (процента)                                                                  |
|--------------|------------------------------------------------------------------------------------|

// Если в нескольких приложениях (или нескольких копиях одноrо и тоrо же приложения)
// используется тот же самый файл протокола, следует:
// 1. установить признак append - определяет режим ввода данных в конце файла
// 2. использовать шаблоном имени файла %u
//    -> чтобы каждое приложение создавало свою особую копию файла протокола.
// 3. установить режим ротации файлов протоколов.
//    -> имена файлов протоколов будут формироваться следующим образом:
//       myapp.log.0, myapp.log.1, myapp.log. 2 и т.д.
//       Как только размер файла превысит допустимый предел, самый старый файл протокола удаляется,
//       остальные переименовываются, а новый файл получает имя с номером 0.
// 4. определить свои собственные обработчики протоколов, расширив класс Handler или StreamHandler.
//    Данный обработчик протоколов расширяет класс StreanHandler и устанавливает
//    поток вывода с методами write() для отображения в текстовой области данных, выводимых в этот поток:

class WindowHandler extends StreamHandler {
    public WindowHandler() {
        ...
        var output = new JTextArea();
        setOutputStream (new OutputStream () {
            public void write(int b) {} // not called
            public void write(byte[] b, int off, int len) {
                output.append(new String(b, off, len));
            }
        });
    }
    ...
}
// Затруднение:
// Обработчик размещает протокольные записи в буфере
// и направляет их в поток вывода только тогда, когда буфер заполнен.

// Решение -> Необходимо переопределить метод publish(),
//    чтобы выводить содержимое буфера после каждой протокольной записи.
class WindowHandler extends StreamHandler {
    ...
    public void publish(LogRecord record) {
        super.publish(record);
        flush();
    }
}
// Можно также расширить класс Handler и определить методы:
// - publish()
// - flush()
// - close()

// page 378
// 7.5.6 Фильтры

// По умолчанию записи фильтруются в соответствии с уровнями протоколирования.
// У каждого регистратора и обработчика протоколов может быть свой фильтр,
// выполняющий дополнительную фильтрацию.

// Для этого достаточно реализовать интерфейс Filter и определить следующий метод:
boolean isLoggable (LogRecord record)

// Для анализа протокольных записей можно выбрать любой критерий,
// а метод должен возвращать логическое значение true для тех протокольных записей,
// которые нужно ввести в файл протокола.

// -> фильтр может пропускать только протокольные записи,
// созданные в начале выполнения метода и при возврате из него.
// Фильтр должен вызвать метод:
    record.getMessage()
// и проверить, начинается ли запись со строки ENTRY или RETURN.
// Чтобы задать фильтр в регистраторе или обработчике протоколов,
// следует вызвать метод:
    setFilter().
// Но фильтры можно применять только по очереди.

// page 378
// 7.5.7 Средства форматирования (Formatters)

// Классы ConsoleHandler и FileHandler порождают протокольные записи в:
// - текстовом виде
// - формате XML
// Можно определить свой собственный формат:
// ->
// 1. расширить класс Formatter
// 2. переопределить метод String format(LogRecord record) ->
    String formatMessage(LogRecord record)

// Во многих форматах файлов (например в XML), предполагается:
// 1. начальная часть файла
// 2. конечная часть файла
// в которых хранится отформатированные протокольные записи.
// -> нужно переопределить методы:
    String getHead (Handler h)
    String getTail (Handler h)

// далее вызывается метод:
    setFormatter() // устанавливает средства форматирования в обработчике протоколов.

// page 378
// 7.5.8 "Рецепт" протоколирования (логирования)
// 1. Для простых приложений - выбирать один регистратор.
//    Рекомендуется, чтобы имя регистратора совпадало с именем основного пакета приложения.
//    Пример названий пакетов: com.mycompany.myprog
//    Создаем регистратор:
      Logger logger = Logger.getLogger("com.mycompany.myprog");

// 2. Для удобства в те классы, где интенсивно используется протоколирование
//    можно добавить статические поля.
      private static final Logger logger = Logger.getLogger("com.mycompany.myprog");

// 3. По умолчанию все сообщения, имеющие уровень INFO и выше, выводятся на консоль.
//    Пользователи могут изменить конфиrурацию, предусмотренную по умолчанию,
//    но, это довольно сложный процесс.
//    Лучше задать более оправданные настройки прикладной проrраммы по умолчанию.
//    Сделать чтобы все сообщения были зареrистрированы в файле протокола,
//    связанном с конкретным приложением.
      if (System.getProperty("java.util.logging.config.class") == null)
          && System.getProperty("java.util.logging.config.file") == null) {
          try {
            Logger.getLogger("").setLevel(Level.ALL);
            final int LOG_RATATION_COUNT = 10;
            var handler = new FileHandler("%h/myapp.log", 0, LOG_RATATION_COUNT);
            Logger.getLogger("").addHandler(handler);
          } catch (IOException e) {
            Logger.log(Level.SEVERE, "Не могу создать файл журнала обработчика", e);
          }
      }

// 4. Все rотово для протоколирования. Все сообщения, имеющие уровень протоколирования:
//    - INFO
//    - WARNING
//    - SEVERE
//    выводятся на консоль -> эти уровни протоколирования нужно зарезервировать для сообщений,
//    представляющих ценность для пользователей вашей проrраммы.
//    Уровень FINE лучше выделить для сообщений, предназначенных для программистов.
//    В тех местах кода, где обычно вызывается метод System.out.println(),
//    регистрируйте сообщения следующим образом:
      logger.fine("Файл открытый диалог отменен");

// 5. Рекомендуется также реrистрировать неожиданные исключения:
      try {
        ...
      } catch (SomeException e) {
        logger.log(Level.FINE, "пояснения...", e);
      }

// программа из листинга 7.2 работает, но в модульном проекте ее нужно правельно настроить
// GOTO разобраться с этим

// D:\filesEvgeniy\projects\mycoding\java\learnbooks\hortsmann_v_one\hortsmann_v_one.iml
// <?xml version="1.0" encoding="UTF-8"?>
// <module version="4">
//   <component name="AdditionalModuleElements">
//     <content url="file://$MODULE_DIR$/../hortsmann_v_one" dumb="true">
//       <sourceFolder url="file://$MODULE_DIR$/../hortsmann_v_one/src/main/resources" type="java-resource" />
//     </content>
//   </component>
// </module>


// page 387
// 7.6 Рекомендации по отладке программ

// 1. Значение любой переменной можно вывести с помощью выражения
System.out.println("x = " + x);
// или
Logger.getGlobal().info("x = " + x);
Logger.getGlobal().info("this = " + this);

// 2. Включить в каждый класс отдельный метод main() и разместить в нем код,
//    позволяющий протестировать этот класс отдельно от других
public class MyClass {
    // методы и поля данного класса
    ...
    public static void main (String[] args){
        // тестовый код
    }
}
//    Создайте несколько объектов, вызовите все методы и проверьте, правильно ли они действуют.
//    Все это делается в теле методов main(), а интерпретатор вызывается для каждого файла класса по отдельности.
//    Если выполняется аплет, то ни один из этих методов main() вообще не будет вызван.
//    А если выполняется приложение, то интерпретатор вызовет только метод main() из запускающего класса.

// 3. Поработайте в среде JUnit, которая доступна по адресу http://junit.org.
//    JUnit представляет собой широко распространенную среду модульного тестирования,
//    которая существенно упрощает работу по созданию наборов тестов и контрольных примеров.
//    Запускайте тесты после каждого видоизменения класса.
//    При обнаружении программных ошибок добавляйте новый контрольный пример для последующего тестирования.

// 4. Протоколирующий прокси-объект представляет собой экземпляр подкласса,
//    который перехватывает вызовы методов, протоколирует их и обращается к суперклассу.
//    Так, если возникнут трудности при вызове метода nextDouble() из класса Random,
//    можно создать прокси-объект в виде экземпляра анонимного подкласса:
var generator = new Random() {
    public double nextDouble() {
        double result = super.nextDouble();
        Logger getGlobal().info("nextDouble: " + result);
        return result;
    }
};
//    При каждом вызове метода nextDouble() будет формироваться протокольное сообщение.

//    Ниже поясняется, как выявить ту часть кода, из которой вызывается данный метод,
//    и как произвести трассировку стека.

// 5. Вызвав метод printStackTrace() из класса Throwable,
//    можно получить трассировку стека из любого объекта исключения.
//    В примере, перехватывается любое исключение, выводится объект исключения и трассировка стека,
//    а затем повторно генерируется исключение, чтобы найти предназначенный для него обработчик.
try {
    ...
} catch (Throwable t) {
    t.printStackTrack();
    throw t;
}
//    Для трассировки стека не нужно даже перехватывать исключение.
//    Просто введите следующую строку в любом месте кода:
Thread.dumpStack();

// 6. Результаты трассировки стека выводятся в поток сообщений об ошибках System.err.
//    Если же требуется протоколировать или отобразить результаты трассировки стека,
//    то можно заключить их в символьную строку.
var out = new ByteArrayOutputStream();
new Throwable().printStackTrace(out);
String description = out.toString();

var out = new StringWriter();
new Throwable().printStackTrace(new PrintWriter(out));
String description = out.toString();

// 7. Ошибки, возникающие при выполнении программы, удобно записывать в файл.
//    Но обычно ошибки посылаются в поток сообщений об ошибках System.err,
//    а не в поток вывода System.out.
command: java МyProgram > errors.txt     // Так вывести ошибки в файл по обычной команде нельзя.
//    лучше записать это так:
command: java MyProgram 2> errors.txt

//    для того чтобы направить потоки Stream.err и Stream.out в один и тот же файл,
//    воспользуйтесь командой
command: java МyProgram 1> errors.txt 2>&1

command: java MyProgram > errors.txt:
// Эта команда перенаправляет только стандартный вывод (stdout) программы в файл errors.txt.
// Ошибки, которые попадают в поток ошибок (stderr), все еще выводятся на экран.

command: java MyProgram 2> errors.txt:
// Эта команда перенаправляет только поток ошибок (stderr) программы в файл errors.txt.
// Стандартный вывод (stdout) все еще выводится на экран.

command: java MyProgram 1> errors.txt 2>&1:
// В этой команде используется дополнительное средство, называемое перенаправлением дескриптора файлов.
// 1> перенаправляет стандартный вывод (stdout) в файл errors.txt,
// 2>&1 перенаправляет поток ошибок (stderr) в тот же самый файл, что и стандартный вывод.
// Как стандартный вывод, так и поток ошибок будут записаны в файл errors.txt.

// Основное отличие между этими 3мя командами заключается в том,
// какие потоки данных (stdout и stderr) перенаправляются,
// и перенаправляются ли они в один и тот же файл или в разные.

// Здесь цифры, используемые в командах перенаправления потоков в командной строке,
// представляют собой стандартные дескрипторы файлов для различных потоков данных:
// 0 - стандартный ввод (stdin)
// 1 - стандартный вывод (stdout)
// 2 - поток ошибок (stderr)

// Когда вы видите 1> или 2>, это указывает на то,
// что поток данных (stdout или stderr) будет перенаправлен в файл,
// указанный справа от символа ">".

// Если нет цифры, то это подразумевает стандартный вывод (stdout).
// Например,">" означает перенаправление стандартного вывода.

// Комбинация 2>&1 указывает на то, что поток ошибок (stderr) будет перенаправлен туда,
// куда уже перенаправлен стандартный вывод (stdout).
// То есть, куда бы ни был перенаправлен стандартный вывод (stdout),
// поток ошибок (stderr) будет перенаправлен в тот же самый файл или место.

// 8. Результаты трассировки стека необрабатываемых исключений свидетельствуют о том,
//    что поток сообщений об ошибках System.err далек от идеала.
//    Выводимые в него сообщения смущают конечных пользователей, если им случается их увидеть,
//    и они недоступны для диагностических целей, когда в этом возникает потребность.
//    Поэтому более правильный подход состоит в том, чтобы протоколировать их в файле.
//    Обработчик для необрабатываемых исключений можно заменить статическим методом:
//    Thread.setDefaultUncaughtExceptionHandler().
//    Это будет выглядеть:
Thread.setDefaultUncaughtExceptionHandler(
    new Thread.UncaughtExceptionHandler() {
        public void uncaughtException(Thread t, Throwable e) {
            // сохранить данные в файле протокола.
        };
    }
);

// 9. Чтобы отследить загрузку класса, запустите виртуальную машину Java с параметром
        "-verbose"
//    На экране появятся строки:
//    [0.012s] [info] [class,load] opened: /opt/jdk-9.0.1 /lib/rnodules
//    [0.034s] [info] [class,load] java.lang.Object source: jrt:/java.base
//    [0.035s] [info] [class,load] java.io.Serializable source: jrt:/java.base
//    [0.035s] [info] [class,load] java.lang.Cornparable
//    и т.д.
//    Такой способ может оказаться полезным для диагностики ошибок, связанных с путями к классам.

command: java -verbose YourMainClass
// Где YourMainClass - это основной класс вашего приложения, который вы хотите запустить.

// Эта команда запустит виртуальную машину Java с включенным выводом информации о загрузке классов.
// Вы увидите информацию о каждом загруженном классе в процессе выполнения вашего приложения.

// Если вы используете управляемую среду разработки (IDE),
// вы можете добавить этот параметр в настройки запуска вашего приложения в IDE.

// 10. Параметр -Xlint указывает компилятору выявлять типичные ошибки в исходном коде программы.
//     Если, вызвать компилятор так, как показано ниже,
//     он уведомит о пропущенных операторах break в ветвях оператора switch.

command: javac -Xlint:fallthrough

//     Термин lint применялся ранее для описания инструментального средства,
//     предназначенного для обнаружения потенциальных ошибок в программах, написанных на С.
//     Теперь он обозначает все инструментальные средства, отмечающие языковые конструкции,
//     которые могут оказаться спорными, хотя и допустимыми.

//     Описаны допустимые значения параметра -Xlint.
//     В итоге получаются сообщения, аналогичные следующему:

// warning: [fall through] possible fall-through into case
// предупреждение ["провал"] возможный "провал" в ветви выбора case

//     Символьная строка в квадратных скобках обозначает категорию предупреждения.
//     Вывод каждой категории можно разрешить или запретить.
//     Но поскольку большинство этих категорий весьма полезны для отладки программ,
//     то лучше оставить их на месте, запретив лишь те из них,
//     которые не представляют интерес, как показано ниже.
command: javac -Xlint:all,-fallthrough,-serial sourceFiles

// Список предупреждений можно получить по следующей команде:
command: javac --help -Х

// 11. В виртуальной машине Java реализована поддержка контроля и управления приложениями написанными на Java.
//     Это позволяет установить в ней агенты, которые будут отслеживать расходование памяти,
//     использование потоков исполнения, загрузку классов и т.п.
//     Такая поддержка важна для работы с крупномасштабными прикладными программами,
//     работающими в течение длительного времени, например, с серверами приложений.

//     Для демонстрации новых возможностей в комплект поставки JDK включена графическая утилита jconsole,
//     которая отображает статистические данные о производительности виртуальной машины (рис.7.3).
//     Запустите на выполнение сначала свою программу, а затем утилиту jconsole
//     Далее выберите свою программу из списка выполняющихся программ на Java.
//     На консоль будет выведено немало полезных сведений о вашей программе.

//     Подробнее об этом по адресу www.oracle.com/technetwork/articles/java/jconsole-1564139.html.

// 12. В комплект Oracle JDK входит инструментальное средство Java Mission Control (JMC),
//     предназначенное для профилирования и диагностики прикладных проrрамм на профессиональном уровне.
//     Им можно свободно пользоваться на стадии разработки приложений,
//     тогда как на стадии их эксплуатации потребуется коммерческая лицензия на данное средство.
//     Со временем eгo версия с открытым исходным кодом будет доступна как составная часть комплекта OpenJDК.
//     Подобно утилите jconsole, инструментальное средство Java Mission Control
//     можно присоединить к действующей виртуальной машине.
//     Оно способно также анализировать результаты, выводимые инструментальным средством Java Flight Recorder,
//     собирающим данные, касающиеся диагностики и профилирования выполняющегося приложения на Java.

//     Подробнее об этих инструментальных средствах по адресу https://docs.oracle.com/javacomponents/index.html.


// page 393
// 8 глава: Обобщенное программирование

// - Назначение обобщенного программирования
// - Определение простого обобщенного класса
// - Обобщенные методы
// - Ограничения на переменные типа
// - Обобщенный код и виртуальная машина
// - Ограничения и пределы обобщений
// - Правила наследования обобщенных типов
// - Подстановочные типы
// - Рефлексия и обобщения


// page 394
// 8.1 Назначение обобщенного программирования
// Обобщенное программирование - написание кода, который может быть неоднократно применен к разнотипным объектам.

// page 394
// 8.1.1 Преимущества параметров типа
// До внедрения обобщенных классов -> обобщение шло через наследование.

// Раньше:
public class ArrayList {
    private Object[] elementData;
    ...
    public Object get(int i) { ... }
    public void add(Object o) { ... }
}
// -> плохо, т.к. постоянно при извлечении нужно делать привидение типов:
ArrayList files = new ArrayList();
...
String filename = (String) files.get();
// + отсутствует проверка на ошибки.
files.add(new File("..."));
// -> это скомпелируется, но приведет к ошибке после попытки
// при попытке метода get() привести результат к типу String

// Сейчас: ("Ромбовидный синтаксис")
var files = new ArrayList<String>();
// или
ArrayList<String> files = new ArrayList<>();

// Допустимый ромбовидный синтаксис в Java 9:
ArrayList<String> passwords = new ArrayList<>() {
    public String get(int n) {
        return super.get(n).replaceAll(".", "*");
    }
};

// -> в коллекции типа ArrayList<String> можно вводить только объекты типа String
files.add(new File("...")); // выдаст ошибку

// Ошибка компиляции - это намного лучше, чем исключение в связи с
// неправильным приведением типов во время выполнения.
// Привлекательность параметров типа в том и состоит,
// что они делают исходный код программы более удобочитаемым и безопасным.

// page 395
// 8.1.2 На кого рассчитано обобщенное программирование

// класс ArrayList метод addAll()
// Задача: добавить все элементы ArrayList<Manager> -> ArrayList<Employee>
//         ArrayList<Employee> -X> ArrayList<Manager>
// Решение: Подстановочный тип

// Обобщенное программирование делится на 3 уровня:
// 1. Элементарный - простое использование обобщенных классов
// 2.
// 3.


// page 396
// 8.2 Определение простого обобщенного класса

// Обобщенный класс - класс, с одной или несколькими переменными типа.
// Рассмотрим простой обобщенный класс Pair в качестве примера.

public class Pair<T> {
    private T first;
    private T second;

    public Pair() {
       first = null;
       second = null;
    }

    public Pair(T first, T second) {
       this.first = first;
       this.second = second;
    }

    public T getFirst() {
       return first;
    }

    public T getSecond() {
       return second;
    }

    public void setFirst(T newValue) {
        first = newValue;
    }

    public void setSecond (T newValue) {
        second = newValue;
    }
}

// В классе Pair вводится переменная типа Т,
// заключенная в угловые скобки (<>) после имени самого класса.
// У обобщенного класса может быть больше одной переменной типа.
// Например, класс Pair можно было бы определить с разными типами
// для первого и второго поля следующим образом:
public class Pair<T, U> { ... }
// Переменные типа используются повсюду в определении класса:
// - для обозначения типов
// - возвращаемых методами
// - типов полей
// - локальных переменных.
// Пример объявления переменной типа.
private Т first;    //используем переменную типа

// В именах переменных типа принято употреблять прописные буквы и стремиться к их краткости.
// В стандартной библиотеке Java буквами:
//  Е - обозначается тип элемента коллекции,
//  K - обозначается тип ключей в таблице
//  V - обозначается тип значений в таблице
//  T и S, U (при необходимости) - "любой тип вообще"

// Экземпляр обобщенного типа получается путем подстановки имени типа вместо переменной типа:
Pair<String>
// Результат такой подстановки следует рассматривать как обычный класс с конструкторами:
Pair<String>()
Pair<String>(String, String)

// и методами:
String getFirst()
String getSecond()
void setFirst(String)
void setSecond(String)

// Обобщенный класс действует как фабрика обычных классов.

// page 398
// 8.3 Обобщенные методы

// Помимо обобщенного класса можно обпределить обобщенный метод, с параметрами или переменными типа
// в т.ч. в не обобщенном классе

class ArrayArg {
    public static <T> T getMiddle (T... a) {    // пример обобщенного метода
        return a[a.length / 2];
    }
}
// -> на что указывали угловые скобки и переменная типа
// Переменная типа вводится после модификаторов доступа (public static) и перед возвращаемым типом "T".

// "<T>" - обобщенный тип (переменная типа). Используется для создания обобщенных методов или классов.
// "T"   - параметр типа. Используется в контексте объявления типа параметра.

// T (параметр типа) <T> указывает, что метод или класс является обобщенным и может работать с данными любого типа.
// Когда метод или класс обобщенный, T обычно используется в качестве обозначения для параметра типа,
// который будет заменен конкретным типом данных при использовании обобщенного метода или класса.

// Когда вызывается обобщенный метод, ему можно передать конкретные типы данных,
// заключая их в угловые скобки перед именем метода:
String middle = ArrayArg.<String>getMiddle ("John", "Q.", "Public");
-> // Равнозначно
String middle = ArrayArg.getMiddle("John", "Q.", "Public");

// При вызове метода можно пропустить параметр типа String.
// У компилятора имеется достаточно информации, чтобы вывести из такого обобщения именно тот метод,
// который требуется вызвать.
// Он сопоставляет тип аргументов с обобщенным типом Т ... и приходит к выводу,
// что вместо обобщенного типа <T>, следует подставить конкретный тип String.

// Обычно все ОК, но иногда возникают проблемы:
double middle = ArrayArg.getMiddle(3.14, 1723, 0);
// -> При выполнении этой строки кода компилятор выведет сообщение об ошибке загадочного содержания,
// но суть его в том, что данный код можно интерпретировать двояко и в обоих случаях - правильно.

// Компилятор выполняет:
// 1. автоупаковку параметра в один объект типа Double и два объекта типа Integer,
// 2. пытается найти для них общий супертип.
//    И таких супретипов два:
//        - класс Number
//        - интерфейс Comparable, который сам является обобщенным.
//    В этом случае для устранения ошибки методу следует передать все параметры со значениями типа double.

// Прием от: Петер Ван Дер Ахе (Реtег von dег Ahe)
// Если требуется выяснить, какой тип компилятор выводит при вызове обобщенного метода:
// намеренно допустить ошибку и изучить полученное в итоге сообщение об ошибке.

// Пример:
ArrayAlg.getМiddle("Hello", 0, null).
// Если присвоить полученный результат переменной ссылки на объект типа JВutton, что заведомо неверно,
// то в конечном итоге будет получено следующее сообщение об ошибке:

found:
java.lang.Object&java.io.Serializable&java.lang.Comparable<? extends
    java.lang.Object&java.io.Serializable&java.lang.Comparable<?>>

// -> Результат вызова данного метода можно присвоить переменным ссылки на объекты типа:
Object, Serializable или Comparable.

// page 399
// 8.4 Ограничения на переменные типа

// Иногда класс или метод нуждается в наложении ограничений на переменные типа.

// Пример, в котором требуется вычислить наименьший элемент массива:
class ArrayArg {
    public static <T> T min(T[] a) {    // почти верно
        if (a == null || a.length == 0) {
            return null;
        }
        T smallest = a[0];
        for (int i = 1; i < a.length; i++){
            if (smallest.compareTo(a[i]) > 0){
                smallest = a[i];
            }
        }
        return smallest;
    }
}

// Здесь возникает затруднение. Обратите внимание на тело метода min().
// Переменная smallest относится к типу Т, а это означает, что она может быть объектом произвольною класса.
// Но откуда известно, имеется ли метод compareTo() в том классе, к которому относится тип Т?

// Выход ->
// Наложить ограничение на тип Т и вместо него подставлять только класс, реализующий Comparable
// - стандартный интерфейс с единственным методом compareTo().
// Для этого достаточно наложить ограничение на переменную типа T.

public static <T extends Comparable> T min (T[] a) {
    ...
}

// Как правильно пользоваться параметрами типа вместе с интерфейсом Comparable (раздел 8.8).

// Теперь обобщенный метод min() может вызываться только с массивами классов,
// реализующих интерфейс Comparable, в том числе String, Date и т.п.

// А вызов min() с массивом типа Rectangle приведет к ошибке во время компиляции,
// поскольку класс Rectangle не реализует интерфейс Comparable.

// ключевое слово extends вместо implements, ведь Comparable - это интерфейс?
// Так, следующее обозначение:
    <Т extends оrраничивающий_тип>

// означает, что тип Т должен быть подтипом ограничивающею типа,
// причем к типу T и ограничивающему типу может относиться как интерфейс, так и класс.
// Ключевое слово extends выбрано потому, что это вполне благоразумное приближение понятия подтипа,
// и создатели Java не сочли нужным вместо этого вводить в язык новое ключевое слово.

// Переменная типа или подстановка может иметь несколько ограничений.
// Ограничивающие типы разделяются знаком "&",
// т.к. "запятые" служат для разделения переменных типа.
// ->
    Т extends Comparable & Serializable

// Как и в механизме наследования в Java, у интерфейсов может быть сколько угодно супертипов,
// но только один из ограничивающих типов может быть классом.

// Если для ограничения служит класс,
// он должен быть 1м в списке накладываемых ограничений.

// page 402
// 8.5 Обобщенный код и виртуальная машина.

// Виртуальная машина не оперирует объектами обобщенных типов
// Все объекты принадлежат обычным классам.

// В ранних вариантах реализации обобщений можно было компилировать программу с обобщениями в файлы классов,
// которые способна исполнять виртуальная машина версии 1.0!
// Далее:
// 1. каким образом компилятор "стирает" параметры типа
// 2. последствия этого процесса для программирующих на Java.

// Как компилятор "стирает" параметры типа:
// В Java обобщения (Generics) являются частью системы типов на уровне компиляции.
//Обобщенный код существует только на этапе компиляции и стирается (erased) при компиляции в байт-код.
// Компилятор удаляет параметры типа и заменяет их на типы-ограничители (если они заданы) или на Object,
// если ограничители не указаны.
// Этот процесс известен как "стирание типов" (type erasure).

// Например:
java
Copy code
public class Box<T> {
    private T value;

    public void setValue(T value) {
        this.value = value;
    }

    public T getValue() {
        return value;
    }
}
// После компиляции этот класс превращается в необобщенную версию,
// где все вхождения типа T заменяются на Object.
// ->
public class Box {
    private Object value;

    public void setValue(Object value) {
        this.value = value;
    }

    public Object getValue() {
        return value;
    }
}

// Последствия стирания типов для программистов на Java:
// Потеря типовой безопасности:
// После стирания типов в обобщенном коде теряется информация о типах, используемых в программе.
// Это может привести к потере типовой безопасности и возникновению ошибок
// времени выполнения из-за неправильного использования типов.

// Ограниченные возможности рефлексии:
// После стирания типов нельзя получить доступ к параметрам типа во время выполнения (runtime),
// что ограничивает возможности рефлексии в обобщенном коде.

// Накладные расходы на приведение типов:
// Поскольку все параметры типов стираются до Object,
// в обобщенном коде могут возникнуть дополнительные накладные расходы
// на приведение типов при извлечении объектов из контейнеров.

// Пример:
// 1. как обобщения компилируются в байт-код
// 2. как происходит стирание типов
// 3.пример ошибки времени выполнения при неправильном использовании

import java.util.*;

public class Main {
    public static void main(String[] args) {
        // Создание списка строк
        List<String> stringList = new ArrayList<>();
        stringList.add("Пример");
        stringList.add("текста");

        // В обобщенном коде компилятор работает с типом "List", не зная о параметрах типа "String"
        List list = stringList;

        // Это приведет к ClassCastException во время выполнения
        // Поскольку параметр типа "String" стерся и элементы списка стали типа "Object"
        // String str = list.get(0); // Ошибка времени выполнения

        // Поэтому при обращении к элементам списка придется явно выполнять приведение типов
        String str = (String) list.get(0);
        System.out.println(str); // Вывод: Пример
    }
}

// page 402
// 8.5.1 Стирание типов (подробнее)

// Всякий раз, когда определяется обобщенный тип,
// автоматически создается соответствующий ему базовый ("сырой") тип.
// Имя этого типа совпадает с именем обобщенного типа с удаленными параметрами типа.
// Переменные типа стираются и заменяются ограничивающими типами
// (или типом Object, если переменная не имеет ограничений).

// К примеру базовый тип для обобщенного типа Pair<T> выглядит следующим образом:
public class Pair {
    private Object first;
    private Object second;

    public Pair(Object first, Object second) {
        this.first = first;
        this.second = second;
    }

    public Object getFirst() {return first;}
    public Object getSecond() {return second;}

    public void setFirst (Object newValue) {
        first = newValue;
    }
    public void setSecond (Object newValue) {
        second = newValue;
    }
}

// Если Т - неограниченная переменная типа, то ее тип просто заменяется на Object.
// В итоге получается обычный класс вроде тех, что реализовывались до появления обобщений в Java.

// Прикладные программы могут содержать разные варианты обобщенного класса Pair,
// в том числе Pair<String> или Pair<GregorianCalendar>,
// но в результате стирания все они приводятся к базовым типам Pair.

// Базовый тип заменяет тип переменных первым накладываемым на них ограничением или же типом Object,
// если никаких ограничений не предусмотрено.

// Например, у переменной типа в обобщенном классе Pair<T> отсутствуют явные ограничения,
// поэтому базовый тип заменяет обобщенный тип Т на Object.

// Допустим, что объявлен несколько иной обобщенный тип:

public class Interval<T extends Comparable & Serializable> implements Serializable {
    private T lower;
    private T upper;
    ...
    public Interval (T first, T second) {
        if (first.compareTo (second) <= 0) {
            lower = first;
            upper = second;
        } else {
            lower = second;
            upper = first;
        }
    }
}

public class Interval implements Serializable {
    private Comparable lower;
    private Comparable upper;
    ...
    public Interval (Comparable first, Comparable second) {
        ...
    }
}
// А если поменять местами ограничения class Interval<Serializable & Comparable>:

// базовый тип заменит обобщенный тип T на Serializable, а компилятор произведет там,
// где требуется, приведение к типу Comparable.
// Поэтому ради эффективности в конце списка ограничений следует размещать отмечающие (маркерные) интерфейсы
// (т.е. интерфейсы без методов).

// page 403
// 8.5.2 Преобразование обобщенных выражений

// Когда в программе вызывается обобщенный метод,
// компилятор вводит операции приведения типов при стирании возвращаемого типа.
    Pair<Employee> buddies = ...;
    Employee buddy = buddies.getFirst();

// В результате стирания из метода getFirst() возвращается тип Object.
// Поэтому компилятор автоматически вводит приведение к типу Employee.
// -> компилятор преобразует вызов данного метода в следующие две команды для виртуальной машины:
//    • вызвать метод базового типа Pair.getFirst();
//    • привести тип Object возвращаемого объекта к типу Employee.

// Операции приведения типов вводятся также при обращении к обобщенному полю.
// Допустим, что поля first и second открытые, т.е. объявлены как public
// (не самый лучший, но допустимый стиль программирования в Java).
// Тогда при преобразовании приведенного выше выражения в получаемый в конечном итоге байт-код
// также будут введены операции приведения типов.
        Employee buddy = buddies.first;


// page 404
// 8.5.3 Преобразование обобщенных методов

// Стирание типов происходит и в обобщенных методах.
// Пример:
public static <Т extends Comparable> Т min(T(] а)

// Но после стирания типов остается только один приведенный ниже метод,
// где параметр обобщенного типа Т стирается, а остается только ограничивающий тип Comparable:
public static Comparable min(Comparable[] а)

// Стирание типов в обобщенных методах приводит к некоторым осложнениям:
class DateInterval extends Pair<> {
    public void setSecond(LocalDate second) {
        if (second.compareTo(getFirst()) >= 0) super.setSecond(second)
    }
    ...
}

// В этом фрагменте кода интервал дат задается парой объектов типа LocalDate,
// поэтому соответствующие методы требуется переопределить,
// чтобы второе сравниваемое значение не было меньше первого.

// В результате стирания ->:
class DateInterval extends Pair {   // после стирания параметров типа
    public void setSecond(LocalDate second) { ... }
    ...
}

// но имеется и другой метод setSecond(),унаследованный от класса Pair:
public void setSecond(Object second)
// это совершенно другой метод, т.к. он имеет параметр другого типа:
// Object вместо LocalDate, но он не должен быть другим.

DateInterval interval = new DateInterval(...);
Pair<LocalDate> pair = interval;    // допускается присвоение суперклассу
pair.setSecond(aDate);

// Предполагается, что вызов метода setSecond() является полиморфным,
// и поэтому вызывается соответствующий метод.
// А поскольку переменная раir ссылается на объект типа Dateinterval,
// это должен быть вызов Dateinterval.setSecond().
//Но стирание типов мешает соблюдению принципа полиморфизма.
// В качестве выхода из этого затруднительного положения компилятор
// формирует следующий мостовой метод в классе Dateinterval:

public void setSecond(Object second) {
    setSecond((LocalDate) second);
}

// проанализируем выполнение другого оператора:
pair.setSecond(aDate);

// В объявлении переменной pair указан тип Pair<LocalDate>,
// к которому относится только один метод под именем setSecond() -> setSecond (Object).
// Виртуальная машина вызывает этот метод для того объекта, на который ссылается переменная pair.
// Этот объект относится к типу Dateinterval, и поэтому вызывается метод Dateinterval.setSecond(Object).
// Именно он и является синтезированным мостовым методом.
// Он в свою очередь вызывает метод Dateinterval.setSecond (LocalDate), что и требуется.

// Мостовые методы могут быть еще более необычными.
// Допустим, в классе Dateinterval переопределяется также метод getSecond():

class DateInterval extends Pair<LocalDate> {
    public LocalDate getSecond() {
        return (LocalDate) super.getSecond().clone();
    }
    ...
}
// В классе DateInterval имеются следующие 2 метода под именем getSecond:
Date getSecond()    // определен в классе DateInterval
Object getSecond()  // переопределяет метод из класса Pair для вызова первого метода

// Написать этот код на Java без параметров нельзя,
// т.к. было бы неверно иметь 2 метода с одинаковыми типами параметров.
// Но в виртуальной машине типы параметров и возвращаемый тип определяют метод.
// Поэтому компилятор может сформировать байт-код для двух методов,
// отличающихся только возвращаемым типом, и виртуальная машина правильно ведет себя в подобной ситуации.

// Применение мостовых методов не ограничивается только обобщенными тиnами.
// Вполне доnустимо оnределять в методе более ограниченный возвращаемый тиn (глава 5),
// когда он nереоnределяет другой метод.
// Здесь методы:
Object.clone()
Employee.clone()
// имеют так называемые ковариантные возвращаемые типы.

public class Employee implements Cloneable {
    public Employee clone() throw CloneNotSupportedException { ... }
}
// На самом деле в классе Object имеются два таких метода:
    Employee clone() //определен выше
    Object clone() // синтезированный мостовой метод, переопределяющий 11 метод Object clone()
// При этом синтезированный мостовой метод вызывает вновь оnределенный метод.

// О преобразовании обобщений в Java нужно запомнить следующее.
//      • Для виртуальной машины обобщений не существует, но имеются только обычные классы и методы.
//      • Все параметры типа заменяются ограничивающими типами.
//      • Мостовые методы синтезируются для соблюдения принципа полиморфизма.
//      • Операции приведения типов вводятся по мере надобности для обеспечения типовой безопасности.

// page 406
// 8.5.4 Вызов унаследованного кода

// Главная цель обобщений в Java:
// обеспечить совместимость обобщенного и унаследованного кода.

// В библиотеке Swing для разработки графических интерфейсов предоставляется класс JSlider,
// реализующий компонент ползунка, где отметки могут быть специально определены с метками,
// содержащими текст или изображения.
// Метки устанавливаются с помощью следующего вызова:
void setLabelTable(Dictionary table)

// В классе Dictionary целые числа сопоставляются с метками.
//      - до версии Java 5 данный класс был реализован в виде отображения экземпляров типа Object.
//      - в версии Java 5 класс Dictionary был сделан обобщенным, хотя класс JSlider вообще не был обновлен.
// -> класс Dictionary без параметров типа относится к базовому типу.
// -> здесь и вступает в действие совместимость.

// При заполнении словаря можно воспользоваться базовым типом:
Dictionary <Integer, Component> labelTable = new HashTable<>();
labelTable.put(0, new JLabel(new ImageIcon("nine.gif")));
labelTable.put(20, new JLabel(new ImageIcon("ten.gif")));
...

// При попытке передать объект обобщенного типа Dictionary<Integer, Component> методу setLabelTable(),
// компилятор выдаст соответствующее предупреждение:
slider setLabelTable(labelTable);       // Предупредждение!

// Компилятору неизвестно, что именно метод setLabel Таblе() может сделать с объектом типа Dictionary.
// Так, этот метод может заменить все ключи символьными строками,
// нарушив гарантию того, что ключи должны иметь тип Integer.
// Поэтому при выполнении последующих операций приведения типов могут возникнуть неприятные исключения.

// Вопрос:
// что именно компонент типа JSlider собирается делать с данным объектом типа Dictionary.
// Ответ:
// компонент типа JSlider только вводит информацию, так что предупреждением компилятора можно пренебречь.

// Противоположный случай:
// Объект базового типа получается от унаследованного класса.
// Его можно присвоить переменной обобщенного типа, но тогда будет выдано предупреждение:
Dictionary<Integer, Components> labelTable = slider.getLabelTable();    // Предупреждение!

// Анализируем предупреждение и убежаемся в том,
// что таблица меток действительно содержит объекты типа Integer и Component,
// хотя нет никакой гарантии, что они там присутствуют.

// В частности, злоумышленник может установить другой объект типа Dictionary в компоненте типа JSlider.
// Но опять же эта ситуация не хуже той, что была до внедрения обобщений.
// В худшем случае программа сгенерирует исключение.

// Обратив внимание на предупреждение компилятора, воспользуемся аннотацией для того, чтобы оно исчезло.
// Такую аннотацию следует разместить перед локальной переменной следующим образом:
@SuppressWarnings("unchecked")
Dictionary<Integer, Components> labelTable = slider.getLabelTable();    // Предупреждение отсутсвует!

// Аналогичным образом можно снабдить аннотацией весь метод,
// Такая аннотация отменяет проверку всего кода в теле метода.
@SuppressWarnings("unchecked")
public void configureSlider() { ... }

// page 407
// 8.6 Ограничения и пределы обобщений

// В основном эти ограничения являются следствием стирания типов.


// page 407
// 8.6.1 Параметрам типа нельзя приписывать простые типы

// Примитивный тип нельзя подставить вместо типа параметра.
// -> не бывает объекта типа Pair<double>
// -> бывает объект типа Pair<Double>.

// Причина - в стирании типов.
// После такого стирания в классе Pair отсутствуют поля типа Object,
// и поэтому их нельзя использовать для хранения значений типа double.

// И хотя такое ограничение досадно, оно согласуется с особым положением примитивных типов в Java.
// Этот недостаток не носит фатального характера.
// Ведь существует всего восемь простых типов данных,
// а обработать их всегда можно с помощью отдельных классов и методов,
// когда нельзя подставить вместо них типы-оболочки.