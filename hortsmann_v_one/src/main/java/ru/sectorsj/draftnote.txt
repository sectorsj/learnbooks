// For notes
https://horstmann.com/corejava/index.html

// page 239
var list = new ArrayList<Integer>();
list.add(3);            ->      list.add(Integer.valueOf(3));       // автоупаковка
int n = list.get(i);    ->      int n = list.get(i).intValue();     // автораспаковка

// метод, изменяющий свои числовые параметры,
// с использованием контейнерного типа - intHolder
public static void triple (intHolder x) {
    x.value++;      // успешная модификация локальной переменной
}

// page 242
// методы с переменным числом параметров

public class PrintStream {
    public PrintStream printf(String fmt, Object ... args) {       // Object ...   ->   Object[]
        return format(fmt, args);
    }

    System.out.printf("%d %s", n, "widgets");   ->  System.out.printf("%d %s", new Object[] { new Integer(n), "widgets"} );
}

public static double max (double... values) {
    double largest = Double.MIN_VALUE;
    for (double v : values){
        if (v > largest) {
            largest = v;
        }
    }
    return largest;
}

double m = mах(З.1, 40.4, -5);   ->  new double[] { 3.1, 40.4, -5 }

// page 243
// Классы перечислений

public enum Size {
    SMALL,
    MEDIUM,
    LARGE,
    EXTRA_LARGE
};
// В классы Enum можно добавить конструкторы, методы и поля


public enum Size{
    SMALL("S"),
    MEDIUM("M"),
    LARGE("L"),
    EXTRA_LARGE("XL"),

    private String abbreviation;

    private Size(String abbreviation){
        this.abbreviation = abbreviation;
    }

    public String getAbbreviation() {
        return abbreviation;
    }
}
Size s = (Size) Enum.valueOf(Size.class, "SMALL");  // s будет присвоено значение Size.SМALL
Size[] values = Size.values();  // Size.SMALL, Size.MEDIUM, Size.LARGE,Size.EXTRA_LARGE

// page 245
// 5.7 Рефлексия
задачи для рефлексии:
    • анализировать возможности классов в процессе выполнения программы;
    • проверять объекты при выполнении программы;
      например, с помощью рефлексии можно реализовать метод toString(),
      совместимый со всеми классами;
    • реализовывать обобщенный код для работы с массивами;
    • применять объекты типа Method, которые работают аналогично указателям на функции в языках, подобных С++.

// Класс Class
Employee e;
Class cl = e.getClass();
System.out.println(e.getClass().getName() + ": " + e.getName()); -> Employee: Harry Hacker

var generator = new Random();
Class cl = generator.getClass();
String name = cl.getName(); // в переменной name устанавливает строковое значение "java.util.Date"

String className = "java.util.Date";
Class cl = Class.forName(className);

Class cl1 = Date.class; // если произведен импорт пакета java.util.*;
Class cl2 = int.class;  // тип int - это не класс, но, несмотря на это, int.class - это объект типа Class.
Class сlЗ = Double[].class;

Employee.class => Class<Employee>

var className = "java.util.Random"; // или любое другое имя класса с конструктором без аргументов
Class cl = Class.forName(className);
Object obj = cl.getConstructor().newInstance(); // получение экземпляра класса "Random"

// page 249
// 5.7.2 Обработка исключений
public static void doSomethingWithClass(String name) throws ReflectiveOperationException {
    Class cl = Class.forName(name); // может сгенерировать исключение сделать что-нибудь с переменной cl
}

// 5.7.3 Ресурсы
// Примеры:
• Файлы изображения и звука
• Текстовые файлы, содержащие строки сообщений и метки экранных кнопок.

Для компиляции листинга 5.13 (ResourceTest)
1. нужно создать архивный JАR-файл
2. запустить его на выполнение, выполнив следующие команды:
    javac resource/ResourceTest.java
    jar cvfe ResourceTest.jar resources.ResourceTest\ resources/*.class resources/*.qif resources/data/*.txt corejava/*.txt
    java -jar ResourceTest.jar

В итоге получилось так:

Структура JAR-файла:
\ResourceTest.jar
    \corejava
        \title.txt
    \META-INF
        \MANIFEST.MF
    \data
        \about.txt
    \ru
        \sectorsj
            \_251_res
                \ResourceTest.class
    \about.gif

package ru.sectorsj._251_res;

import javax.swing.*;
import java.io.*;
import java.net.*;
import java.nio.charset.*;

public class ResTest {
    public static void main(String[] args) throws IOException {
        Class cl = ResTest.class;
        URL aboutURL = cl.getResource("/about.gif");
        var icon = new ImageIcon(aboutURL);

        InputStream stream = cl.getResourceAsStream("/data/about.txt");
        var about = new String(stream.readAllBytes(), "UTF-8");

        InputStream stream2 = cl.getResourceAsStream("/corejava/title.txt");
        var title = new String(stream2.readAllBytes(), StandardCharsets.UTF_8).trim();

        JOptionPane.showMessageDialog(null,
                about,
                title,
                JOptionPane.INFORMATION_MESSAGE,
                icon);
    }
}

jar cvfe .\ru\sectorsj\_251_res\ResourceTest.jar ru.sectorsj._251_res.ResTest
ru/sectorsj/_251_res/ResTest.class
-C D:\filesEvgeniy\projects\mycoding\java\learnbooks\hortsmann_vol1\src\main\resources\_251 corejava
-C D:\filesEvgeniy\projects\mycoding\java\learnbooks\hortsmann_vol1\src\main\resources\_251 about.gif
-C D:\filesEvgeniy\projects\mycoding\java\learnbooks\hortsmann_vol1\src\main\resources\_251 data

*добавил папки, а не конечные файлы.

// page 263
// 5.7.6.

var а= new Employee[100];
...
// массив заполнен
a = Arrays.copyOf(a, 2 * a.length);

// бесполезно!!!
public static Object[] badCopyOf(Object[J а, int newLength) {
    var newArray = new Object[newLength];
    System.arraycopy(a, 0, newArray, 0, Math.min(a.length, newLength));
    return newArray;
}

Для этого потребуются методы класса Array из пакета java.lang.reflect
и особенно метод newInstance()

// так можно
Object newArray = Array.newInstance(componentType, newLength);

Для того чтобы определить тип элементов нового массива, необходимо:
1. Определить, какому именно классу принадлежит объект "а".
2. Убедиться в том, что он действительно является массивом.
3. Воспользоваться методом getComponentType() из класса Class
    (определен лишь для объектов типа Class, представляющих массивы),
    чтобы получить требуемый тип массива.

public static Object goodCopyOf(Object а, int newLength) {
    Class cl = a.getClass();
    if (!cl.isArray()) return null;
    Class componentType = cl.getComponentType();
    int length = Array.getLength(a);
    Object newArray = Array.newInstance(componentType, newLength);
    System.arraycopy(a, 0, newArray, 0, Math.min(length, newLength) );
    return newArray;
}

// page 266
// 5.7.7 Вызов произвольных методов и конструкторов

Object invoke(Object obj, Object ... args)

String n = (String) m1.invoke(harry);
double s = (Double) m2.invoke(harry);

// Как получить объект типа Method?
Method getMethod(String name, Class ... parameterTypes)

Method m1 = Employee.class.getMethod("getName");
Method m2 = Employee.class.getMethod("raiseSalary", double.class);

// для конструкторов
Class cl = Random.class;    // или любой другой класс с конструктором, принимающим параметр типа long
Constructor cons = cl.getConstructor(long.class);
Object obj = cons.newInstance(45L);

public static native double java.lang.Math.sqrt(double)
 1.0000  |       1.0000
 2.0000  |       1.4142
 3.0000  |       1.7321
 4.0000  |       2.0000
 5.0000  |       2.2361
 6.0000  |       2.4495
 7.0000  |       2.6458
 8.0000  |       2.8284
 9.0000  |       3.0000
10.0000  |       3.1623

double dx = (to - from) / (n - 1);
for (double x = from; x <= to; x +=dx) {
    double y = (Double) f.invoke(null, x);          // т.к. вызывается статический метод, 1й параметр - null
    System.out.printf("%10.4f | %10.4f%n", x, y);   // где f - это объект типа Method/
}
Math.class.getMethod("sqrt", double.class)

// page 270
// 5.8 Рекомендации по применению наследования


Резюме
1. размещайте общие операции и поля в суперклассе
2. Стараться не пользоваться защищенными (protected) полями
3. Использовать наследование для моделирования отношений - "является"
4. Не пользоваться наследованием, если не все методы имеет смысл сделать наследуемыми
5. Не изменять предполагаемое поведение метода при его переопределении
6. Пользоваться принципом полиморфизма, а не данными о типе
7. Не злоупотреблять механизмом рефлексии

// 273
// interfaces | lambdas | inner classes | service loaders | proxies

// 6.1 Интерфейсы
// 6.1.1 Понятие интерфейса

// до java 5
public interface Comparable {
    int compareTo(Object other);
}
// после java 5
public interface Comparable<T> {
    int compareTo(T other); //этот параметр относится к обобщенному типу Т
}

Итак, если Comparable<Employee> ->  int compareTo(Employee other);


class Employee implements ComparaЫe<Employee> {
    public int compareTo(Employee other) {
        return DouЫe.compare(salary, other.salary);
    }
    ...
}

// page 289
// 6.1.8 Интерфейс Comparable

public interface Comparator<T> {
    int compare(T first, Т second);
}

// создаем компаратор для сравнения строк по их длине
class LengthComparator implements Comparator<String>{
    public int compare(String first, String second) {
        return first.length() - second.length();
    }
}

var comp = new LengthComparator();
if (comp.compare(words[i], words(j]) > 0) ...

String[] friends = { "Peter", "Paul", "Mary" };
Arrays.sort(friends, new LengthComparator());

// page 290
// 6.1.9 Клонирование объектов

var original = new Employee("Невил Долгопупс", 50000);
Employee copy = original;
copy.raiseSalary(10);   // упс, оригинал тоже изменился!

Employee copy = original.clone();
copy.raiseSalary(10);   // хорошо, теперь оригинал не изменился!

Метод clone() - является защищенным (protected)

Чтобы применить метод clone(), нужно принять следующее решение:
Вариант 1. Достаточно ли метода clone(), предоставляемого по умолчанию?
Вариант 2. Можно ли доработать предоставляемый по умолчанию метод clone() таким образом,
   чтобы вызывать его для изменяемых объектов?
Вариант 3. Следует ли вообще отказаться от применения метода clone()?

Если хотите использовать Вариант 1 или Вариант2, то нужно:
1. Реализовать интерфейс Cloneable.
2. Переопределить метод clone() с модификатором доступа public.

Интерфейс Cloneable - маркерный интерфейс, т.е. не имеет ни одного метода.
Его задача, разрешить выполнение операции instanceof
для проверки типа следующим образом:

if (obj instanceof Cloneable) ...

Для реализации метода clone() по умолчанию(неполное копирование), нужно:
1. реализовать интерфейс Cloneable,
2. переопределить метод clone() как открытый (public)
3. сделать вызов super.clone()

class Employee implements Cloneable {
    // сделать метод открытым, изменить возвращаемый тип
    public Employee clone() throws CloneNotSupportedException {
        return (Employee) super.clone();
    }
    ...
}

// пример реализации метода clone(), выполняющего полное копирование
class Employee implements Cloneable{
    ...

    public Employee clone() throws CloneNotSupportedException{
        // вызов метода Object.clone()
        Employee cloned = (Employee) super.clone();

        // клонировать изменяемые поля
        cloned.hireDay = (Date) hireDay.clone();

        return cloned
    }
}

// пример метода clone() в массивах,
// но он открытый (public), а не защищенный (protected)
int[] luckyNumbers = {2, 3, 5, 7, 11, 13};
int[] cloned = (int[]) luckyNumbers.clone();
cloned[5] = 12;     // не изменяет элемент массива luckyNumbers[5]

// page 296
// 6.2 Лямбда выражения
// 6.2.1 Причины для употребления лямбда-выражений

class Worker implements ActionListener {
    public void actionPerformed(ActionEvent event){
        // сделать что-то
    }
}

class LengthComparator implements Comparator<String> {
    public int compare(String first, String second) {
        return first.length() - second.length();
    }
}
...
Arrays.sort(strings, new LengthComparator());



// 6.2.2 Синтаксис лямбда-выражений
first.length() - second.length()
->
(String first, String second) -> first.length() - second.length()

// -> λfirst.λsecond.first.length() - second.length()

// если есть параметры:
(String first, String second) -> {
    if (first.length() < second.length()) return -1;
    else if (first.length() > second.length()) return 1;
    else return 0;
}

// при отсутствии параметров:
() -> {
    for (int i = 100; i >= 0; i--)
        System.out.println(i);
}

// Можно опустить типы параметров лямбда выражений, т.к.
// результат вычисления лямбда-выражения присваивается компаратору символьных строк.
// (first, second) тоже самое, что и "(String first, String second)"

Comparator<String> comp = (first, second) ->
    first.length() - second.length();

// Если у метода имеется единственный параметр выводимого типа,
// то можно опустить круглые скобки
// вместо (event) -> ...
// или (ActionListener event) -> ...

ActionListener listener = event ->
    System.out.println("Время " + Instant.ofEpochMilli(event.getWhen()));

// Результат вычисления лямбда-выражений вообще не указывается.
// Данное выражение может быть использовано там,
// где ожидается результат типа int
(String first, String second) ->
    first.length() - second.length()


// Недопустимо, чтобы значение возвращалось в одних ветвях лямбда-выражения,
// но не возвращалось в других его ветвях.
(int х) -> (if (х >= 0) return 1;)      // Ошибка!


// page 300
// 6.2.3 Функциональные интерфейсы


Чтобы продемонстрировать преобразование в функциональный интерфейс,
рассмотрим снова метод Arrays.sort().
В качестве второго параметра ему требуется экземпляр типа Comparator - интерфейса с единственным методом.

Вместо него достаточно предоставить лямбда-выражение следующим образом:
Arrays.sort(words, (first, second) -> first.length() - second.length() );
Подспудно метод Arrays.sort() принимает объект некоторого класса,
реализующего интерфейс Comparator.
В результате вызова метода compare() для этого объекта выполняется тело лямбда-выражения.
Управление такими объектами и классами полностью зависит от конкретной реализации
и может быть намного более эффективным, чем применение традиционных внутренних классов.
Поэтому лямбда-выражение лучше всего рассматривать как функцию, а не объект,
приняв к сведению, что оно может быть передано функциональному интерфейсу.

В стандартной библиотеке Java предоставляется целый ряд
весьма универсальных функциональных интерфейсов,
входящих в пакет java.util.function

BiFunction<String, String, Integer> comp
    = (first, second) -> first.length() - second.length();

public interface Predicate<T> {
    boolean test(T t);
    // Дополнительные методы по умолчанию и статические методы
}

// removeIf() - из класса ArrayList, с параметром типа Predicate
list.removeIf(e -> e == null);

// Supplier<T>
public interface Supplier<T>{
    T get();
}

LocalDate hireDay = Objects.requireNonNullOrElse(day, new LocalDate(1970, 1, 1));
->
LocalDate hireDay = Objects.requireNonNullOrElseGet(day,
    () -> new LocalDate(1970, 1, 1));


// page 302
// 6.2.4 Ссылки на методы

var timer = new Timer(1000, event -> System.out.println(event));
->
var timer = new Timer(1000, System.out::println);

Arrays.sort(strings, String::compareToignoreCase)

Разновидности ссылок на методы в лямбда выражениях:
1 Объект:: МетодЭкземпляра
2  Класс:: МетодЭкземпляра
3  Класс:: СтатическийМетод

|       Ссылка на метод        |    Равнозначное лямбда-выражение      |                       Примечания                      |
|------------------------------|---------------------------------------|-------------------------------------------------------|
| System.out::println          |   x -> System.out.println(x)          |   ссылка на метод равнозначна лямбда выражению,       |
|                              |                                       |   параметры которого передаются методу                |
| String::compareToignoreCase  |  (х, у) -> х.compareToignoreCase (у)  |   первый параметр ссылки на метод становится          |
|                              |                                       |   неявным параметром метода                           |
| separator::equals            |   x -> separator.equals(x)            |   Это выражение-метод с заданным объектом             |
|                              |                                       |   экземпляра. Параметр лямбда-выражения               |
|                              |                                       |   передается как явный параметр метода                |
| String::trim                 |   x -> x.trim()                       |   Это выражение-метод с заданным классом и методом    |
|                              |                                       |   экземпляра. Параметр лямбда-выражения становится    |
|                              |                                       |   неявным параметром                                  |
| String::concat               |   (x, y) -> x.concat(y)               |   Здесь вызывается метод экземпляра, но на этот раз   |
|                              |                                       |   с явным параметром. Как и прежде, первый параметр   |
|                              |                                       |   лямбда-выражения становится неявным параметром, а   |
|                              |                                       |   остальные параметры передаются методу               |
| Integer::valueOf             |   x -> Integer::valueOf(x)            |   Это выражение-метод с заданным статическим методом. |
|                              |                                       |   Параметр лямбда-выражения передается этому          |
|                              |                                       |   статическому методу                                 |
| Integer::sum                 |   (x, y) -> Integer::sum(x, y)        |   Это еще один пример вызова статического метода,     |
|                              |                                       |   но на этот раз с двумя параметрами. Оба параметра   |
|                              |                                       |   лямбда-выражения передаются статическому методу.    |
|                              |                                       |   В частости, метод Integer.sun() создается, чтобы    |
|                              |                                       |   служить в качестве ссылки на метод. В качестве      |
|                              |                                       |   альтернативы можно было бы просто составить         |
|                              |                                       |   лямбда-выражение (x, y) -> x + y                    |
| Integer:new                  |   x -> new Integer(x)                 |   Это ссылка на конструктор (6.2.5). Параметры        |
|                              |                                       |   лямбда-выражения передаются конструктору            |
| Integer[]::new               |   n -> new Integer[n]                 |   Это ссылка на конструктор массива (6.2.5) Параметр  |
|                              |                                       |   лямбда-выражения определяет длину массива           |
|------------------------------|---------------------------------------|-------------------------------------------------------|

Objects.isNull(obj) => Predicate =>
list.removeIf(Objects::isNull);     // эту строку легче читать
list.removeIf(e -> e == null);      // чем эту

this::equals        x -> this.equals(x);
super::equals       x -> super.equals(x);

 Ссылка super является целевой и вызывает вариант заданного метода экземпляра из суперкласса.

// Пример
class Greeter {
    public void greet(ActionEvent event) {
        System.out.println("Hello, the time is" + Instant.ofEpochMilli(event.getWhen()))
    }
}

class RepeatedGreeter extends Greeter {
    public void greet(ActionEvent event) {
        var timer = new Timer(1000, super::greet);
        timer.start();
    }
}

// page 305
// 6.2.5 Ссылки на конструкторы

Ссылки на конструкторы действуют таким же образом, как и ссылки на методы,
за исключением того, что вместо имени метода указывается операция new.

ArrayList<String> names = ...;
Stream<Person> stream = names.stream().map(Person::new);
List<Person> people = stream.collect(Collectors.toList());

int[]::new  => x -> new int[x]

Object[] people = steam.toArray();      // допустим требуется создать массив из объектов типа Person
->
Object[] people = steam.toArray(Person[]::new);

// page 306
// 6.2.6 Область видимости переменных

public static void repeatMessage(String text, int delay) {
    ActionListener listener = event -> {
        System.out,println(text);
        Toolkit.getDefaultToolkit().beep();
    };
    new Timer(delay, listener).start();
}

// Следующий вызов:
repeatMessage("Hello", 1000);   // выводит слово - Hello 1000 раз в отдельном потоке исполнения

Переменная - text, весьма необычна.

Лямбда-выражение имеет следующие составляющие:
1. Блок кода
2. Параметры
3. Значения свободных переменных, т.е. таких переменных,
   которые не являются параметрами и не определены в коде
-> text - это свободная переменная (строка "Hello")
// значение переменной text захвачено лямбда-выражением.

// Блок кода вместе со значениями свободных переменных называется - замыканием.
// Лямбда-выражения служат в качестве замыканий
// В лямбда-выражении можно ссылаться только на те переменные, значения которых не изменяются.

public static void countDown(int start, int delay){
    ActionListener listener = event -> {
        start--;    // ОШИБКА! изменить захваченную переменную нельзя!
        System.out.println(start);
    };
    new Timer(delay, listener).start();
}

// В лямбда-выражении не допускается ссылаться на переменную, которая изменяется извне.
public static void repeat(String text, int count) {
    for (int i = 1; i <= count; i++) {
        ActionListener listener = event -> {
            System.out.println(i + ": " + text);    // Ошибка! Нельзя ссылаться на изменяемую переменную "i"
        };
        new Timer(1000, listener).start();
    }
}

// Правило гласит: любая захваченная переменная в лямбда-выражении должна
// быть действительно конечной, т.е. такой переменной,
// которой вообще не присваивается новое значение после ее инициализации.

// Не допускается объявлять параметр или переменную в лямбда-выражении
// с таким же именем как и у локальной переменной:

Path first = Path.get("/usr/bin");
Comparator<String> comp = (first, second) -> first.length() - second.length(); // ОШИБКА! переменная first уже определена!

public class Application() {
    public void init() {
        ActionListener listener = event -> {
            System.out.println(this.toString());
            ...
        }
        ...
    }
}

// page 308
// 6.2.7 Обработка лямбда-выражений

// Причины для отложенного выполнения кода:
1. Выполнение кода в отдельном потоке.
2. Неоднократное выполнение кода.
3. Выполнение кода в нужный момент по ходу алгоритма (например, выполнение операции сравнения при сортировке).
4. Выполнение кода при наступлении какого-нибудь события (щелчка на экранной кнопке, поступления данных и т.д.).
5. Выполнение кода только по мере надобности.

// Пример:
repeat(10, () -> System.out.println("Hello, World!"));

public static void repeat(int n, Runnable action) {
    for (int i = 0; i < n; i++){
        action.run();
    }
}

public interface IntConsumer {
    void accept(int value);
}

// Обновленный метод repeat():
public static void repeat(int n, IntConsumer action) {
    for (int i = 0; i < n; i++) {
        action.accept(i);
    }
}

// вызов нового метода repeat():
repeat(10, i -> System.out.println("Countdown: " + (9 - i)));

// таблица 6.2 наиболее употребляемые функциональные интерфейсы:
|----------------------|------------ |--------------|------------------|-----------------------|-----------------------|
|    Функциональный    |    Типы     | Возвращаемый | Имя абстрактного |        Описание       |         Другие        |
|       интерфейс      | параметров  |     тип      |      метода      |                       |         методы        |
| -------------------- |------------ |--------------|------------------|-----------------------|-----------------------|
| Runnable             | отсутствует |     void     |        run       | Выполняет действие без|                       |
|                      |             |              |                  | аргументов или возвра-|                       |
|                      |             |              |                  | щаемого значения      |                       |
|----------------------|-------------|--------------|------------------|-----------------------|-----------------------|
| Supplier<T>          | отсутствует |       T      |        get       | Предоставляет значение|                       |
|                      |             |              |                  | типа T                |                       |
|----------------------|-------------|--------------|------------------|-----------------------|-----------------------|
| Consumer<T>          |      T      |     void     |      accept      | Употребляет значение  |        andThen        |
|                      |             |              |                  | типа T                |                       |
|----------------------|-------------|--------------|------------------|-----------------------|-----------------------|
| BiConsumer<T, U>     |     T, U    |     void     |      accept      | Употребляет значение  |        andThen        |
|                      |             |              |                  | типа T и U            |                       |
|----------------------|-------------|--------------|------------------|-----------------------|-----------------------|
| Function<T, R>       |      T      |      R       |       apply      | Функция с аргументом  |   compose, andThen,   |
|                      |             |              |                  | T                     |   identity            |
|----------------------|-------------|--------------|------------------|-----------------------|-----------------------|
| BiFunction<T, U, R>  |     T, U    |      R       |      apply       | Функция с аргументами |        andThen        |
|                      |             |              |                  | T и U                 |                       |
|----------------------|-------------|--------------|------------------|-----------------------|-----------------------|
| UnaryOperator<T>     |      T      |      T       |      apply       | Унарная операция над  |   compose, andThen,   |
|                      |             |              |                  | типом T               |   identity            |
|----------------------|-------------|--------------|------------------|-----------------------|-----------------------|
| BinaryOperator<T>    |     T, T    |      T       |      apply       |Двоичная операция над  | andThen,maxBy, minBy  |
|                      |             |              |                  |типом T                |                       |
|----------------------|-------------|--------------|------------------|-----------------------|-----------------------|
| Predicate<T>         |      T      |    boolean   |       test       | Булевозначная функция |   and, or, negate,    |
|                      |             |              |                  |                       |        isEqual        |
|----------------------|-------------|--------------|------------------|-----------------------|-----------------------|
| BiPredicate<T, U>    |     T, U    |    boolean   |       test       | Булевозначная функция |    and, or, negate    |
|                      |             |              |                  | с аргументами         |                       |
|----------------------|-------------|--------------|------------------|-----------------------|-----------------------|

// Пример: PConsumer -> IntConsumer
// По этому был использован IntConsumer вместо Consumer<Integer>

// таблица 6.3 : Функциональные интерфейсы для примитивных типов,
где обозначения:
1. р, q относятся к типам: int, long, double
2. Р, Q относятся к типам: Int, Long, Double
|----------------------|------------ |--------------|------------------|
|    Функциональный    |    Типы     | Возвращаемый | Имя абстрактного |
|       интерфейс      | параметров  |     тип      |      метода      |
| -------------------- |------------ |--------------|------------------|
| BooleanSupplier      | отсутствует |    boolean   |   getAsBoolean   |
| PSupplier            | отсутствует |      p       |      getAsP      |
| PConsumer            |      p      |     void     |      accept      |
| ObjPConsumer<T>      |     T, p    |     void     |      accept      |
| PFunction<T>         |      p      |      T       |      apply       |
| PToQFunction         |      T      |      q       |     applyAsQ     |
| ToPFunction<T>       |      T      |      T       |     applyAsQ     |
| ToPBiFunction<T, U>  |     T, U    |      p       |     applyAsQ     |
| PUnaryOperator       |      p      |      p       |     applyAsQ     |
| PBinaryOperator      |     p, p    |      p       |     applyAsQ     |
| PPredicate           |      p      |    boolean   |       test       |
|----------------------|-------------|--------------|------------------|

// Функциональные интерфейсы из таблиц 6.2 и 6.3 рекомендованы к употреблению!!!
// Если вы разрабатываете собственный интерфейс с единственным абстрактным методом,
// его можно пометить аннотацией @Functionalinterface. Это не обязательно,
// но дает ряд преимуществ.

// page 311
// 6.2.8 Еще о компараторах

// Comparator -> comparing () (статический метод)
// Имеется массив объектов типа Person. Сортировка его элементов по имени.
Arrays.sort(people, Comparator.comparing(Person::getName));

// Компараторы можно связывать в цепочку с помощью метода thenComparing().
Если у двух людей оказываются одинаковые фамилии, то применяется второй компаратор.
Arrays.sort(people, Comparator
    .comparing(Person::getLastName)
    .thenComparing(Person::getFirstName));

// люди сортируются по длине их имен:
Arrays.sort(people, Comparator.comparing(Person::getName,
    (s, t) -> Integer.compare(s.length(), t.length())));
->
Arrays.sort(people, Comparator.comparingInt(
    p -> p.getName().length()));

// методы nullFirst() и nullLast() принимающие имеющийся компаратор,
// чтобы он не генерировал исключение при появлении пустых значений - null.
Comparator.comparing(Person::getMiddleName(),
    Comparator.nullFirst(...))
->
// производится статический импорт по директиве java.util.Comparator.*
Arrays.sort(people, comparing(Person::getMiddleName, nullsFirst(naturalOrder())));

// статический метод reverseOrder() производит сортировку в порядке,
// обратном естественному (naturalOrder()).
// naturalOrder().reversed() = reverseOrder()


// page 312
// 6.З Внутренние классы

// Зачем нужны внутренние классы?
1. Внутренний класс можно скрыть от других классов того же пакета.
2. Объект внутреннего класса имеет доступ к данным объекта,
   в котором он определен, включая закрытые данные.

// 6.3.1 Доступ к состоянию объекта с помощью внутреннего класса

//
public class TalkingClock {
    private int interval;
    private boolean beep;

    public TalkingClock(int interval, boolean beep) {...}
    public void start() {...}

    // внутренний класс
    public class TimerPrinter implements ActionListener {
        ...
    }
}

// подробнее класс TimerPrinter
public class TimerPrinter implements ActionListener {
    public void actionPerformed(ActionEvent event) {
        System.out.println("Сигнал прозвучал в " + Instant.ofEpochMilli(event.getWhen()));
        if (beep) Toolkit.getDefaultToolkit().beep();

    }
}
// в классе TimePrinter отсутствует поле beep.
// Вместо этого метод actionPerformed() обращается к соответствующему полю объекта типа TalkingClock.
// Добавим в код ссылку на объект внешнего класса - other.
->
public class TimerPrinter implements ActionListener {
    public void actionPerformed(ActionEvent event) {
        System.out.println("Сигнал прозвучал в " + Instant.ofEpochMilli(event.getWhen()));
        if (other.beep) Toolkit.getDefaultToolkit().beep();
    }
}
 -> public TimerPrinter(TalkingClock){
    // автоматически генерируется код
    other = clock;
 }

 var = new TimePrinter(this); //параметр добавляется автоматически


// page 316
// 6.3.2 Специальные синтаксические правила для внутренних классов

// ВнешнийКласс.this    - ссылка на внешний класс из внутреннего
// Пример такой ссылки в классе TimerPrinter
public void actionPerformed(ActionEvent event) {
    ...
    if (TalkingClock.this.beep) Toolkit.getDefaultToolkit().beep();
}

ОбъектВнешнегоКласса.new ВнутреннийКласс(параметры конструктора)

// Пример:
ActionListener listener = this.new TimePrinter();

TalkingClock jabberer = new TalkingClock(1000, true);
TalkingClock.TimePrinter listener = jabberer.new TimePrinter();

// Если ссылка на внутренний класс делается
// за пределами области действия внешнего класса,
ВнешнийКласс.ВнутреннийКласс


// page 317
// 6.3.3 О пользе, необходимости и безопасности внутренних классов

// Обращение с внутренними классами происходит на уровне компилятора, а не виртуальной машины.
// Для обозначения внутренних классов используется знак $, разделяющий имена внешних и внутренних классов.
// -> для виртуальной машины внутренние классы неотличимы от внешних.

// ВнутреннийКласс TimePrinter входящий в состав ВнешнегоКласса TalkingClock преобразуется компилятором в
// -> TalkingClock$TimePrinter

// javap -private ИмяКласса

// Для UNIX:
java reflection.ReflectionTest ВнутреннийКласс.TalkingClock\$TimePrinter
или же так:
javap -private ВнутреннийКласс.TalkingClock\$TimePrinter
->
public class innerClass.TalkingClock$TimePrinter implements java.awt.event.ActionListener {
    final innerClass.TalkingClock this$0;
    public innerClass.TalkingClock$TimePrinter(innerClass.TalkingClock);
    public void actionPerformed(java.awt.event.ActionEvent);
}

// this$0 синтезируется компилятором, поэтому сослаться на него нельзя.

class TalkingClock {
    ...
    public void start() {
        var listener = new TimePrinter(this);
        var timer = new Timer(interval, listener);
        timer.start();
    }
}

class TimePrinter implements ActionListener {
    private TalkingClock outer;
    ...
    public TimePrinter(TalkingClock clock) {
        outer = clock;
    }
}

// Рассмотрим теперь метод actionPerformed().
// Ему требуется доступ к полю outer.beep
if (outer.beep) ... // ОШИБКА! ->
// -> Внутренний класс может иметь доступ к закрытым данным лишь того внешнего класса, в который он входит.
// Но класс TimePrinter уже не является внутренним, а следовательно, не имеет такого доступа.

// Внутренние классы, намного эффективнее, чем обычные,
// т.к. они обладают более высокими правами доступа.

class TalkingClock {
    private int interval;
    private boolean beep;
    public TalkingClock(int, boolean);
    static boolean access$0(TalkingClock);
    public void start();
}

if (beep) -> if (TalkingClock.access$0(outer))

// Если внутренний класс имеет доступ к закрытым полям,
// можно создать другой класс, добавить его в тот же самый пакет
// и получить доступ к закрытым данным.

private TalkingClock$TimePrinter(TalkingClock);
// чтобы вызвать такой конструктор, нужно вызвать второй конструктор
->
TalkingClock$TimePrinter(TalkingClock, TalkingClock$1);
// Компилятор преобразует вызов конструктора в методе start() из класса TalkingClock
new TalkingClock$TimePrinter (this, null)

// page 320
// 6.3.4 Локальные внутренние классы

// Т.к. класс TimePrinter используется лишь однажды:
// при создании объекта данного типа в методе start(),
// его можно определить локально в отдельном методе (start())
->
public void start() {
    class TimePrinter implements ActionListener {
        public void actionPerformed(ActionEvent event) {
            System.out.println("Во время сигнала, время " + Instant.ofEpochMilli(event.getWhen()));
            if (beep) Toolkit.getDefaultToolkit().beep();
        }
    }
    var listener = new TimePrinter();
    var timer = new Timer(interval, listener);
    timer.start();
}

// В локальных внутренних классах не используются модификаторы:
// 1. public
// 2. protected

// Преимущества локальных внутренних классов:
// они полностью скрыты от внешнего кода и даже от остальной части класса TalkingClock
// ни одному методу кроме start() ничего неизвестно о TimePrinter

// page 321
// 6.3.5 Доступ к конечным переменным из внешних методов

// Локальные внутренние классы имеют доступ не только к полям своего внешнего класса,
// но и к локальным переменным.
// Такие локальные переменные должны быть объявлены как действительно конечные.

// Перенесем параметры interval и beep
// из конструктора TalkingClock в метод start()
->
public void start(int interval, boolean beep) {
    class TimerPrinter implements ActionListener {
        public void actionPerformed() {
            System.out.println("Сигнал прозвучал в " + Instant.ofEpochMilli(event.getWhen()));
            if (beep) Toolkit.getDefaultToolkit().beep();
        }
    }
    var listener = new TimePrinter();
    var timer = new Timer(interval, listener);
    timer.start;
}
// Теперь в классе TimePrinter больше не нужно хранить переменную экземпляра beep.
// При создании объекта переменная beep,
// передается конструктору и размещается в поле val$beep.
// Компилятор должен обнаруживать доступ к локальным переменным,
// создавать для каждой из них соответствующие поля,
// а затем копировать локальные переменные в конструкторе таким образом,
// чтобы поля данных инициализировались копиями локальных переменных.


// page 322
// 6.3.6 Анонимные внутренние классы

// если требуется создать единственный объект некоторого класса,
// этому классу можно вообще не присваивать имени.
// такой класс называется - анонимным.

// создается новый объект класса, реализующего интерфейс ActionListener,
// где в фигурных скобках определен требующийся метод actionPerformed().
public void start(int interval, boolean beep) {
    var listener = new ActionListener() {   // но синтаксис анонимных внутренних классов довольно сложен.
        public void actionPerformed(ActionEvent event) {
            System.out.println("Сигнал прозвучал в" + Instant.ofEpochMilli(event.getWhen()));
            if (beep) Toolkit.getDefaultToolkit().beep();
        }
    };
    var timer = new Timer(interval, listener);
    timer.start;
}

// общая форма определения анонимных внутренних классов
new СуперТип(параметры конструирования объектов) {
    методы и данные внутреннего класса
}

// Здесь СуперТип может быть:
// 1. интерфейсом (например ActionListener), и тогда внутренний класс реализует данный интерфейс.
// 2. классом, и в этом случае внутренний класс расширяет данный суперкласс.

// Анонимный внутренний класс не может иметь конструкторов:
// поскольку имя конструктора должно совпадать с именем класса,
// а в данном случае у класса отсутствует имя.
// Вместо этого параметры, необходимые для создания объекта, передаются конструктору суперкласса.
// Если вложенный класс реализует какой-нибудь интерфейс, параметры конструктора можно не указывать.

new ТипИнтерфейса() {
    методы и данные
}

// Если за скобками со списком параметров, необходимых для создания объекта,
следует открытая фигурная скобка, то определяется анонимный вложенный класс:

var queen = new Person("Mary");             // объект типа Person
var count = new Person("Dracula") {...};    // объект внутреннего класса, расширяющего класс Person

// Несмотря на то, что у анонимного класса могут отсутствовать конструкторы,
// это никоим образом не мешает предоставить блок инициализации объекта
var count = new Person("Dracula") {
    { (инициализация) }
    ...
};

// альтернативный вариант метода start() написанный ввиде лямбда-выражения:
public void start(int interval, boolean beep) {
    var timer = new Timer(interval, event -> {
        System.out.println("Сигнал прозвучал в " + Instant.ofEpochMilli(event.getWhen()));
        if (beep) Toolkit.getDefaultToolkit().beep();
    });
    timer.start();
}

// Спец прием - инициализация в двойных фигурных скобках
// Если дано:
var friends = new ArrayList<>();
favorites.add("Гарри");
favorites.add("Тони");
favorites.add("Ленни");
invite(friends);

// тогда ->
invite (new ArrayList<String>() {{ add("Гарри"); add("Тони"); add("Ленни"); }})

// Зачастую анонимный подкласс удобно сделать почти,
// но не совсем таким же, как и его суперкласс.
// Но в этом случае следует соблюдать особую осторожность в отношении метода equals().
// в методе equals() необходимо организовать следующую проверку (глава 5):

if (getClass() != other.getClass()) return false;
// Но анонимный подкласс ее не пройдет.


// При выдаче регистрирующих или отладочных сообщений в них нередко требуется включить имя текущего класса:
System.err.println("Something awful happened in " + getClass() );

// Но такой прием не годится для статического метода.
// Ведь вызов метода qetClass(), по существу, означает вызов this.qetClass().
// Но ссылка this на текущий объект для статического метода не годится.
// В таком случае можно воспользоваться следующим выражением:
new Object(){}.getClass().getEnclosingClass()       // получить класс статического метода

// new Object(){}      - создается объект анонимного подкласса, производного от класса Object
// qetEnclosinqClass() - метод получает объемлющий его класс, т.е. класс, содержащий статический метод.

// page 325
// 6.3.7 Статические внутренние классы
// К примеру в массиве требуется найти максимальное и минимальное числа.

double min = Double.MAX_VALUE;
double max = Double.MIN_VALUE;
for (double v : values) {
    if (min > 0) min = v;
    if (max < 0) max = v;
}

class Pair {
    private double first;
    private double second;

    public Pair (double f, double s) {
        first = f;
        second = s;
    }

    public double getFitst() { return first; }
    public double getSecond() { return second; }
}

class ArrayAlg {
    public static Pair minmax (double[] values) {
        ...
        return new Pair(min, max);
    }
}

Pair p = ArrayAlg.minmax(d);
System.out.println("min =" + p.getFirst());
System.out.println("max =" + p.getSecond());

// сделать Pair внутренним классам в ArrayAlg
-> ArrayAlg.Pair

ArrayAlg.Pair p = ArrayAlg.Pair.minmax();

class ArrayAlg {
    public static class Pair {
        ...
    }
    ...
}

// Только внутренние классы можно объявлять статическими.
// Его объект не содержит ссылку на создавший его объект внешнего класса.

public static Pair minmax (double[] values) {
    ...
    return new Pair(min, max);
}

// Если бы класс Pair не был объявлен статическим, компилятор сообщил бы,
// что при инициализации объекта внугреннего класса объект типа ArrayAlg недоступен.

// Статический вложенный класс применяется тогда,
// когда доступ к объекту внутреннего класса не требуется.
// Иногда для обозначения статических внутренних классов пользуются термином - вложенные классы.
// В отличие от обычных внутренних классов, у статических внутренних классов
// могут быть статические поля и методы.
// Внутренние классы, определенные в интерфейсах,
// автоматически считаются статическими и открытыми (т.e. static и public).

// page 329
// 6.4 Загрузчики служб
// Нужны для приложений с архитектурой подключаемых модулей.
// В т.ч. для платформ, серверов приложений и прочих сложных решений.

// Если предоставляется служба, то разработчику прикладной программы
// необходимо дать определенную свободу в реализации функциональных средств данной службы.
// Также желательно предоставить на выбор несколько реализаций службы.
// Загрузку служб, соответствующих общему интерфейсу, позволяет упростить класс ServiceLoader.

// С этой целью определяется интерфейс (или суперкласс) с методами,
// которые должен предоставлять каждый экземпляр загружаемой службы.
// К примеру, служба обеспечивает шифрование данных.

package serviceLoader;
public interface Cipher {
    byte[] encrypt(byte[] source, byte[] key);
    byte[] decrypt(byte[] source, byte[] key);
    int strength();
}

package serviceLoader.impl;
public class CaeserCipher implements Cipher {
    public byte[] encrypt(byte[] source, byte[] key) {
        var result = new byte[source.length];
        for (int i = 0; i < source.length; i++){
            result[i] = (byte) (source[i] + key[0]);
        }
        return resilt;
    }

    public byte[] decrypt(byte[] source, byte[] key) {
        return encrypt(source, new byte[] {
            (byte) - key[0]
        });
    }

    public int strength() {
        return 1;
    }
}


// Пример:
package ru.sectorsj._329_serviceLoader.impl;

import ru.sectorsj._329_serviceLoader.Cipher;

public class CaesarCipher implements Cipher {

    @Override
    public byte[] encrypt(byte[] source, byte[] key) {
        var result = new byte[source.length];
        for (int i = 0; i < source.length; i++) {
            result[i] = (byte) (source[i] + key[0]);
        }
        return result;
    }

    @Override
    public byte[] decrypt(byte[] source, byte[] key) {
        return encrypt(source, new byte[]{
                (byte) - key[0]
        });
    }

    @Override
    public int strength() {
        return 1;
    }
}

package ru.sectorsj._329_serviceLoader;

public interface Cipher {
    byte[] encrypt(byte[] source, byte[] key);
    byte[] decrypt(byte[]source, byte[] key);
    int strength();
}


package ru.sectorsj._329_serviceLoader;

import java.util.Optional;
import java.util.ServiceLoader;

public class ServiceLoaderTest {
    public static void main(String[] args) {
        // Optional<Cipher> cipher = cipherLoader.findFirst();
        Cipher cipher = getCipher(1);
        System.out.println("Проверка main()");

        if (cipher != null) {
            byte[] dataToEncrypt = "Hello my old fiend".getBytes();
            byte[] encryptionKey = {3};     // Ключ для шифрования


            byte[] encryptedData = cipher.encrypt(dataToEncrypt, encryptionKey);
            System.out.println("Шифруемые данные: " + new String(encryptedData));

            byte[] decryptedData =cipher.decrypt(encryptedData, encryptionKey);
            System.out.println("Дешифрованные данные: " + new String(decryptedData));

        } else {
            System.out.println("main(): Не найдена реализация шифра с необходимой стойкостью.");
        }
    }

    public static ServiceLoader<Cipher> cipherLoader = ServiceLoader.load(Cipher.class);

    public static Cipher getCipher(int minStrength) {
        // cipherLoader.iterator()
        for (Cipher cipher : cipherLoader) {
            System.out.println("Загружен шифр: " + cipher.getClass().getName());
            System.out.println("Стойкость шифра: " + cipher.strength());
            if (cipher.strength() >= minStrength) {
                System.out.println("Шифр найден с достаточной стойкостью.");
                return cipher;
            }
        }
        System.out.println("getCipher(): Не найдена реализация шифра с необходимой стойкостью.");
        return null;
    }

    public static Optional<Cipher> getCipher2(int minStrength){
        return cipherLoader.stream()
                .filter(descr -> descr.type() == ru.sectorsj._329_serviceLoader.impl.CaesarCipher.class)
                .findFirst()
                .map(ServiceLoader.Provider::get);
    }
}


директория:
\src
    \main
        \resources
            \META-INF
                \services
файл: ru.sectorsj._329_serviceLoader.Cipher
содержание: ru.sectorsj._329_serviceLoader.impl.CaesarCipher

// Также для работы в нашем модульном проекте понадобится:
// в файле module-info.java указать следующие директивы:
// module hortsmann_v_one {
//     - uses ru.sectorsj._329_serviceLoader.Cipher;
//     - provides Cipher with CaesarCipher;










