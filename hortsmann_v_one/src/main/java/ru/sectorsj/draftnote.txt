// For notes
https://horstmann.com/corejava/index.html

// Краткий обзор книги:
// в главе 1 дается краткий обзор тех функциональных возможностей языка Java,
//           которыми он отличается от других языков программирования.
//           В ней поясняется, что было задумано разработчиками Java
//           и в какой мере им удалось воплотить задуманное в жизнь.
//           Затем приводится краткая история развития языка Java и показывается,
//           как он стал тем, чем он есть в настоящее время.

// в главе 2 поясняется, как загрузить и установить инструментарий JDК,
//           а также примеры программ к этой книге.
//           Затем рассматривается весь процесс компиляции и запуска трех типичных программ на Java
//           (консольного приложения, графического приложения и аплета) только средствами JDK,
//           текстового редактора, специально ориентированного на Java,
//           а также интегрированной среды разработки на Java.

// в главе 3 начинается обсуждение языка программирования Java и излагаются самые основы: переменные,
//           циклы и простые функции. Если у вас имеется опыт программирования на С или С++,
//           вам нетрудно будет усвоить материал этой главы, поскольку синтаксис этих языковых средств,
//           ничем не отличается в Java.
//           А если вам приходилось программировать на языках, не похожих на С, например на Visual Basic,
//           прочитайте эту главу с особым вниманием.

// в главе 4 представлены понятие инкапсуляции - первой из двух фундаментальных составляющих объектной ориентации,
//           а также механизмы, реализующие ее в языке Java: классы и методы.
//           В дополнение к правилам языка Java здесь также приводятся рекомендации
//           по правильному объектно-ориентированному проектированию.
//           И будет представлен замечательный инструмент javadoc,
//           форматирующий комментарии из исходного кода в набор веб-страниц с перекрестными ссылками.
//           Если у вас имеется опыт программирования на С++, можете лишь бегло просмотреть эту главу.
//           А тем, кому раньше не приходилось программировать на объектно-ориентированных языках,
//           придется потратить больше времени на усвоение принципов ООП, прежде чем изучать Java дальше.

// в главе 5 представлен еще один ее краеугольный камень - наследование.
//           Наследование позволяет модифицировать существующий класс
//           в соответствии с конкретными потребностями программирующего.
//           Это - основополагающий прием программирования на Java.
//           Механизм наследования в Java очень похож на аналогичный механизм в С++.
//           Опять же программирующие на С++ могут сосредоточить основное внимание лишь на языковых отличиях
//           в реализации наследования.

// в главе 6 поясняется, как пользоваться в Java понятием интерфейса.
//           Интерфейсы дают возможность выйти за пределы простого наследования, описанного в главе 5.
//           Овладение интерфейсами позволит в полной мере воспользоваться объектно-ориентированным подходом
//           к программированию на Java.
//           После интерфейсов рассматриваются лямбда-выражения в качестве краткого способа выражения блока кода,
//           который может быть выполнен впоследствии.
//           И, рассматривается также удобное языковое средство Java, называемое внутренними классами.

// в главе 7 посвящена обработке исключений - надежному механизму Java, призванному учитывать тот факт,
//           что непредвиденные ситуации могут возникать и в грамотно написанных программах.
//           Исключения обеспечивают эффективный способ отделения кода нормальной обработки от кода обработки ошибок.
//           Но даже после оснащения прикладной программы проверкой всех возможных исключительных ситуаций
//           в ней все-таки может произойти неожиданный сбой.
//           Во второй части этой главы будет представлено немало полезных советов по организации отладки программ.
//           Здесь рассматривается весь процесс отладки на конкретном примере.

// в главе 8 дается краткий обзор обобщенного программирования.
//           Обобщенное программирование делает прикладные программы легче читаемыми и более безопасными.
//           В этой главе будет показано, как применяется строгая типизация,
//           исключается потребность в неприглядном и небезопасном приведении типов
//           и как преодолеваются трудности на пути совместимости с предыдущими версиями Java.

// в главе 9 посвящена каркасу коллекций на платформе Java.
//           Всякий раз, когда требуется сначала собрать множество объектов, а в дальнейшем извлечь их,
//           приходится обращаться к коллекции, которая наилучшим образом подходит для конкретных условий,
//           вместо того чтобы сбрасывать их в обычный массив.
//           В этой главе будут продемонстрированы те преимущества, которые дают стандартные,
//           предварительно подготовленные коллекции.

// в главе 10 представлено введение в программирование графических пользовательских интерфейсов.
//            Будет показано, как создаются окна, как в них выполняется раскраска, рисуются геометрические фигуры,
//            форматируется текст многими шрифтами и как изображения выводятся на экран.
//            Далее здесь будет пояснено, как писать прикладной код, реагирующий на такие события,
//            как щелчки мышью или нажатия клавиш.

// в главе 11 посвящена более подробному обсуждению инструментальных средств Swing.
//            Набор инструментов Swing позволяет строить межплатформенный графический пользовательский интерфейс.
//            В этой главе вы ознакомитесь с различными видами экранных кнопок, текстовых компонентов, рамок,
//            ползунков, комбинированных списков, меню и диалоговых окон.
//            Но знакомство с некоторыми из более совершенных компонентов Swing
//            будет отложено до второго тома настоящего издания.

// в главе 12 посвящена обсуждению параллельного программирования,
//            которое позволяет выполнять программируемые задачи параллельно.
//            Это очень важное и любопытное применение технологии Java в эпоху многоядерных процессоров,
//            которые нужно загрузить работой, чтобы они не простаивали.

// в главе 13 завершающей первый том настоящего издания, приведено краткое введение в библиотеку JavaFX,
//            позволяющую разрабатывать современный графический пользовательский интерфейс настольных приложений.

// page 129
// 4.1.4 Отношения между классами

// Между классами существуют три общих вида отношений:
// 1. Зависимость ("использует - что-то")   (USES-A)
// 2. Агрегирование ("содержит - что-то")   (HAS-A)
// 3. Наследование ("является - чем-то")    (IS-A)

// Отношение зависимости наиболее очевидное и распространенное,
// в классе Order используется класс Account,
// поскольку объекты типа Order должны иметь доступ к объектам типа Account,
// чтобы проверить кредитоспособность заказчика.

// Но класс Item не зависит от класса Account,
// потому что объекты типа Item вообще не интересует состояние счета заказчика.
// -> один класс зависит от другого класса,
// если eгo методы выполняют какие-нибудь действия над экземплярами этого класса.

// Старайтесь свести к минимуму количество взаимозависимых классов.
// Если класс "А" не знает о существовании класса "В",
// то он ничего не знает о любых изменениях в нем!
// -> любые изменения в классе "В" не повлияют на поведение объектов класса "А".

// Агрегирование - объект класса "А" содержит объекты класса "В".
// Отношение агрегирования понять нетрудно, потому что оно конкретно.
// объект типа Order может содержать объекты типа Item.

// Некоторые специалисты не признают понятие агрегирования
// и предпочитают использовать более общее отношение ассоциации или связи между классами.
// С точки зрения моделирования это разумно.
// Но для программистов гораздо удобнее отношение, при котором один объект содержит другой.

// Пользоваться понятием агрегирования удобнее по еще одной причине:
// его обозначение проще для восприятия, чем обозначение отношения Ассоциации (табл. 4.1).

// Наследование выражает отношение между конкретным и более общим классом.
// Класс RushOrder наследуется от класса Order.

// Специализированный класс RushOrder содержит особые методы для обработки приоритетов
// и разные методы для вычисления стоимости доставки товаров, в то время как другие eгo методы,
// например, для заказа товаров и выписывания счетов, унаследованы от класса Order.

// Если класс "А" расширяет класс "В", то класс "А" наследует методы класса "В" и,
// кроме них, имеет дополнительные возможности.

// Подробно Наследование рассматривается в 5 главе.

// UМL (Unified Modeling Language) унифицированный язык моделирования,
// для составления диаграмм классов, описывающих отношения между классами.
// Пример такой диаграммы приведен на рисунке 4.2 (resources/_130/pic_4_2.puml)
// где классы обозначены прямоугольниками,
// а отношения между ними - различными стрелками.

// Таблица 4.1. Обозначение отношений между классами в UML
|-----------|----------------------|------------------------|--------|
|  Степень  |      Отношения       |       Английский       |   UML  |
|-----------|----------------------|------------------------|--------|
|     1     |  Наследование        |  Inheritance           |  --|>  |
|     2     |  Композиция          |  Composition           |  *--   |
|     3     |  Агрегирование       |  Aggregation           |  o--   |
|     4     |  Зависимость         |  Dependency            |  ..>   |
|     5     |  Реализация          |  Implementation        |  ..|>  |
|     6     |  Направленная связь  |  Directed association  |  -->   |
|     7     |  Ассоциация (Связь)  |  Association           |   --   |
|-----------|----------------------|------------------------|--------|

// Подробный разбор отношений между классами в UML:
// 1. Наследование (Inheritance):
//    Отношение, при котором один класс (подкласс или производный класс)
//    наследует свойства и поведение другого класса (суперкласса или базового класса).
//    Подкласс расширяет функциональность базового класса,
//    добавляя новые атрибуты и операции или переопределяя существующие.
//    Обозначается сплошной линией со стрелкой, направленной от подкласса к базовому классу.
//    Класс может наследовать свойства и методы другого класса,
//    известного как базовый класс или суперкласс.
//    Наследование обеспечивает механизм повторного использования кода и создает иерархию классов.

//    Пример: Класс Car может наследовать свойства и методы класса Vehicle,
//            если Vehicle является базовым классом.
class Vehicle {
    protected String brand;

    public void drive() {
        System.out.println("Vehicle is driving");
    }
}

class Car extends Vehicle {
    private int numberOfSeats;

    public void park() {
        System.out.println("Car is parked");
    }
}
// Класс Car наследует свойства и методы класса Vehicle, такие как brand, и метод drive().

// 2. Реализация (Implementation):
//    Отношение, при котором класс реализует абстрактный интерфейс.
//    Интерфейс определяет набор операций, которые должны быть реализованы в классе.
//    Класс может реализовывать один или несколько интерфейсов.
//    Обозначается пунктирной линией со стрелкой, направленной от класса к интерфейсу.
//    Класс обеспечивает реализацию методов определенных в интерфейсе.
//    В Java это осуществляется с помощью ключевого слова implements.

//    Пример: Класс Car может реализовывать интерфейс Driveable,
//            это означает, что он должен предоставить реализацию метода drive().
interface Driveable {
    void drive();
}

class Car implements Driveable {
    public void drive() {
        System.out.println("Car is driving");
    }
}
// Класс Car реализует интерфейс Driveable и предоставляет реализацию метода drive().

// 3. Зависимость (Dependency):
//    Отношение, при котором один класс использует или зависит от другого класса.
//    Класс, который зависит от другого, может ссылаться на объект зависимого класса,
//    использовать его методы или атрибуты.
//    Обозначается пунктирной линией со стрелкой,
//    направленной от зависимого класса к классу, от которого он зависит.
//    Изменения в одном классе могут повлиять на другой класс. Это отношение обычно возникает,
//    когда один класс использует функции или сервисы другого класса.
//    Один класс использует функции или сервисы другого класса.
//    Это отношение может быть временным и изменяемым.

//    Пример: Класс "A" зависит от класса "B",
//            если класс "A" использует объекты класса "B"
//            в своих методах или имеет ссылку на объект класса B.

//    Пример: Если класс Car использует класс Engine, то Car зависит от Engine.
public class Car {
    private Engine engine;

    public Car(Engine engine) {
        this.engine = engine;
    }

    public void start() {
        engine.start();
    }
}

public class Engine {
    public void start() {
        System.out.println("Engine started");
    }
}
// Класс Car зависит от класса Engine, так как он использует объект Engine для запуска двигателя.

// 4. Агрегирование (Aggregation):
//    Отношение "часть-целое", при котором один класс (целое) состоит из других классов (частей).
//    Части могут существовать независимо от целого.
//    Обозначается линией с пустым ромбом на стороне целого и стрелкой, направленной к частям.
//    Один объект является частью другого объекта, но может также существовать самостоятельно.
//    Это отношение является более слабым, чем композиция,
//    и составной объект не управляет жизненным циклом составных частей.

//    Пример: Класс Team агрегирует объекты класса Player, класс Team содержит объекты Player.
//            Объекты Player могут быть частью команды,
//            но также могут принадлежать к нескольким командам или существовать независимо от команд.
public class Team {
    private List<Player> players = new ArrayList<>();   // здесь происходит агрегация

    public void addPlayer(Player player) {
        players.add(player);
    }
}

public class Player {
    private String name;

    public Player(String name) {
        this.name = name;
    }
}
// Класс Team агрегирует объекты класса Player, так как игроки могут быть частью команды,
// но также могут существовать независимо от нее.


// Примеры неагрегированных случаев:
// Если класс Team содержал поле players, но не владел списком игроков.
// или
// Если players было бы передано или получено от другого объекта
// или
// Если Team использовало players, не являясь его владельцем.

// 1. Если players было бы передано через конструктор или метод классу Team:
public class Team {
    private List<Player> players;

    public Team(List<Player> players) {
        this.players = players; // передано извне
    }
}

// 2. Если players было бы получено из другого источника (через инъекцию зависимостей):
public class Team {
    private List<Player> players;

    // инъекция зависимости
    @Autowired
    public void setPlayers(List<Player> players) {
        this.players = players;
    }
}

// 3. Если players было бы получено из статического метода или фабрики:
public class Team {
    private List<Player> players;

    public void initializePlayers() {
        this.players = PlayerFactory.createPlayers();
    }
}

// В этих случаях Team не владеет списком игроков напрямую,
// а получает его из внешнего источника или передается извне,
// что не характеризует агрегацию.

// 5. Композиция (Composition):
//    Это специальный случай агрегирования, при котором части не могут существовать независимо от целого.
//    Если целое уничтожается, то уничтожаются и все его части.
//    Композиция обозначается линией с заполненным ромбом на стороне целого и стрелкой, направленной к частям.
//    Один объект является частью другого объекта,
//    но составной объект полностью контролирует жизненный цикл составных частей.
//    Если составной объект уничтожается, все его составные части также уничтожаются.

//    Пример: Класс Car композирует объект Engine. Класс Car содержит объект Engine.
//            Engine не может существовать без Car.
//            Если Car уничтожается, Engine также будет уничтожен.
public class Car {
    private Engine engine;  // здесь происходит композиция

    public Car() {
        this.engine = new Engine(); // здесь происходит композиция
    }

    public void start() {
        engine.start();
    }
}

public class Engine {
    public void start() {
        System.out.println("Engine started");
    }
}
// Класс Car композирует объект Engine, так как двигатель является неотъемлемой частью автомобиля.
// Если автомобиль уничтожается, двигатель также будет уничтожен.

// 6. Ассоциация или связь (Association):
//    Общий термин, обозначающий любое отношение между двумя классами,
//    при котором один класс знает о другом.
//    Связь может быть двунаправленной или однонаправленной (направленная связь),
//    в зависимости от того, знают ли оба класса друг о друге или только один из них.
//    Два класса связаны друг с другом, но не обязательно владеют друг другом или содержат друг друга.
//    Отношение ассоциации может быть более слабым и менее специфичным, чем агрегация или композиция.
//    Ассоциация просто указывает на существование отношения между двумя классами.
//    Это самое общее и распространенное отношение, и оно может быть слабым или сильным.

//    Пример: Класс Student ассоциируется с классом School.
//            Это может означать, что студенты учатся в школе, но отношение не определяет,
//            являются ли студенты частью школы или могут ли существовать независимо от нее.
public class School {
    private String name;

    public School(String name) {
        this.name = name;
    }
}

public class Student {
    private String name;
    private School school;  // здесь происходит ассоциация

    public Student(String name, School school) {
        this.name = name;
        this.school = school;
    }

    public School getSchool() {     // здесь происходит ассоциация
        return school;
    }
}

// Класс Student ассоциируется с классом School, так как студенты учатся в школе.
// Отношение не определяет, являются ли студенты частью школы
// или могут существовать независимо от нее.

// 7. Направленная ассоциация или Направленная связь (Directed Association):
//    Специальный случай связи, при котором один класс знает о другом, но не наоборот.
//    Обозначается линией со стрелкой, направленной от класса,
//    который знает о другом классе, к классу, о котором он знает.
//    Один класс явно связан с другим классом, и эта связь имеет направление или ориентацию.

//    Пример: Класс Teacher может иметь направленную ассоциацию с классом School,
//            указывая, что учитель преподает в этой школе.
class School {
    private String name;
}

class Teacher {
    private String name;
    private School school; // Направленная связь с классом School

    public Teacher(String name, School school) {
        this.name = name;
        this.school = school;
    }
}
// Класс Teacher имеет направленную ассоциацию с классом School,
// указывая, что учитель принадлежит к определенной школе.
// т.е. Teacher знает о School
// В классе Teacher отсутствует getter getSchool() с типом School, возвращающего school.


// Эти отношения позволяют:
// - структурировать
// - визуализировать
// взаимодействия между классами в объектно-ориентированном программировании,
// обеспечивая четкое понимание и документацию системы.


// page 194
// 5 глава: Наследование
// - Классы, суперклассы и подклассы
// - Глобальный суперкласс Object
// - Обобщенные списочные массивы
// - Объектные оболочки и автоупаковка
// - Методы с переменным числом параметров
// - Классы перечислений
// - Рефлексия
// - Рекомендации по применению наследования

//...

// page 239
var list = new ArrayList<Integer>();
list.add(3);            ->      list.add(Integer.valueOf(3));       // автоупаковка
int n = list.get(i);    ->      int n = list.get(i).intValue();     // автораспаковка

// метод, изменяющий свои числовые параметры,
// с использованием контейнерного типа - intHolder
public static void triple (intHolder x) {
    x.value++;      // успешная модификация локальной переменной
}

// page 242
// методы с переменным числом параметров

public class PrintStream {
    public PrintStream printf(String fmt, Object ... args) {       // Object ...   ->   Object[]
        return format(fmt, args);
    }

    System.out.printf("%d %s", n, "widgets");   ->  System.out.printf("%d %s", new Object[] { new Integer(n), "widgets"} );
}

public static double max (double... values) {
    double largest = Double.MIN_VALUE;
    for (double v : values){
        if (v > largest) {
            largest = v;
        }
    }
    return largest;
}

double m = mах(З.1, 40.4, -5);   ->  new double[] { 3.1, 40.4, -5 }

// page 243
// Классы перечислений

public enum Size {
    SMALL,
    MEDIUM,
    LARGE,
    EXTRA_LARGE
};
// В классы Enum можно добавить конструкторы, методы и поля


public enum Size{
    SMALL("S"),
    MEDIUM("M"),
    LARGE("L"),
    EXTRA_LARGE("XL"),

    private String abbreviation;

    private Size(String abbreviation){
        this.abbreviation = abbreviation;
    }

    public String getAbbreviation() {
        return abbreviation;
    }
}
Size s = (Size) Enum.valueOf(Size.class, "SMALL");  // s будет присвоено значение Size.SМALL
Size[] values = Size.values();  // Size.SMALL, Size.MEDIUM, Size.LARGE,Size.EXTRA_LARGE

// page 245
// 5.7 Рефлексия
задачи для рефлексии:
    • анализировать возможности классов в процессе выполнения программы;
    • проверять объекты при выполнении программы;
      например, с помощью рефлексии можно реализовать метод toString(),
      совместимый со всеми классами;
    • реализовывать обобщенный код для работы с массивами;
    • применять объекты типа Method, которые работают аналогично указателям на функции в языках, подобных С++.

// Класс Class
Employee e;
Class cl = e.getClass();
System.out.println(e.getClass().getName() + ": " + e.getName()); -> Employee: Harry Hacker

var generator = new Random();
Class cl = generator.getClass();
String name = cl.getName(); // в переменной name устанавливает строковое значение "java.util.Date"

String className = "java.util.Date";
Class cl = Class.forName(className);

Class cl1 = Date.class; // если произведен импорт пакета java.util.*;
Class cl2 = int.class;  // тип int - это не класс, но, несмотря на это, int.class - это объект типа Class.
Class сlЗ = Double[].class;

Employee.class => Class<Employee>

var className = "java.util.Random"; // или любое другое имя класса с конструктором без аргументов
Class cl = Class.forName(className);
Object obj = cl.getConstructor().newInstance(); // получение экземпляра класса "Random"

// page 249
// 5.7.2 Обработка исключений
public static void doSomethingWithClass(String name) throws ReflectiveOperationException {
    Class cl = Class.forName(name); // может сгенерировать исключение сделать что-нибудь с переменной cl
}

// 5.7.3 Ресурсы
// Примеры:
• Файлы изображения и звука
• Текстовые файлы, содержащие строки сообщений и метки экранных кнопок.

Для компиляции листинга 5.13 (ResourceTest)
1. нужно создать архивный JАR-файл
2. запустить его на выполнение, выполнив следующие команды:
    javac resource/ResourceTest.java
    jar cvfe ResourceTest.jar resources.ResourceTest\ resources/*.class resources/*.qif resources/data/*.txt corejava/*.txt
    java -jar ResourceTest.jar

В итоге получилось так:

Структура JAR-файла:
\ResourceTest.jar
    \corejava
        \title.txt
    \META-INF
        \MANIFEST.MF
    \data
        \about.txt
    \ru
        \sectorsj
            \_251_res
                \ResourceTest.class
    \about.gif

package ru.sectorsj._251_res;

import javax.swing.*;
import java.io.*;
import java.net.*;
import java.nio.charset.*;

public class ResTest {
    public static void main(String[] args) throws IOException {
        Class cl = ResTest.class;
        URL aboutURL = cl.getResource("/about.gif");
        var icon = new ImageIcon(aboutURL);

        InputStream stream = cl.getResourceAsStream("/data/about.txt");
        var about = new String(stream.readAllBytes(), "UTF-8");

        InputStream stream2 = cl.getResourceAsStream("/corejava/title.txt");
        var title = new String(stream2.readAllBytes(), StandardCharsets.UTF_8).trim();

        JOptionPane.showMessageDialog(null,
                about,
                title,
                JOptionPane.INFORMATION_MESSAGE,
                icon);
    }
}

jar cvfe .\ru\sectorsj\_251_res\ResourceTest.jar ru.sectorsj._251_res.ResTest
ru/sectorsj/_251_res/ResTest.class
-C D:\filesEvgeniy\projects\mycoding\java\learnbooks\hortsmann_vol1\src\main\resources\_251 corejava
-C D:\filesEvgeniy\projects\mycoding\java\learnbooks\hortsmann_vol1\src\main\resources\_251 about.gif
-C D:\filesEvgeniy\projects\mycoding\java\learnbooks\hortsmann_vol1\src\main\resources\_251 data

*добавил папки, а не конечные файлы.

// page 263
// 5.7.6.

var а= new Employee[100];
...
// массив заполнен
a = Arrays.copyOf(a, 2 * a.length);

// бесполезно!!!
public static Object[] badCopyOf(Object[J а, int newLength) {
    var newArray = new Object[newLength];
    System.arraycopy(a, 0, newArray, 0, Math.min(a.length, newLength));
    return newArray;
}

Для этого потребуются методы класса Array из пакета java.lang.reflect
и особенно метод newInstance()

// так можно
Object newArray = Array.newInstance(componentType, newLength);

Для того чтобы определить тип элементов нового массива, необходимо:
1. Определить, какому именно классу принадлежит объект "а".
2. Убедиться в том, что он действительно является массивом.
3. Воспользоваться методом getComponentType() из класса Class
    (определен лишь для объектов типа Class, представляющих массивы),
    чтобы получить требуемый тип массива.

public static Object goodCopyOf(Object а, int newLength) {
    Class cl = a.getClass();
    if (!cl.isArray()) return null;
    Class componentType = cl.getComponentType();
    int length = Array.getLength(a);
    Object newArray = Array.newInstance(componentType, newLength);
    System.arraycopy(a, 0, newArray, 0, Math.min(length, newLength) );
    return newArray;
}

// page 266
// 5.7.7 Вызов произвольных методов и конструкторов

Object invoke(Object obj, Object ... args)

String n = (String) m1.invoke(harry);
double s = (Double) m2.invoke(harry);

// Как получить объект типа Method?
Method getMethod(String name, Class ... parameterTypes)

Method m1 = Employee.class.getMethod("getName");
Method m2 = Employee.class.getMethod("raiseSalary", double.class);

// для конструкторов
Class cl = Random.class;    // или любой другой класс с конструктором, принимающим параметр типа long
Constructor cons = cl.getConstructor(long.class);
Object obj = cons.newInstance(45L);

public static native double java.lang.Math.sqrt(double)
 1.0000  |       1.0000
 2.0000  |       1.4142
 3.0000  |       1.7321
 4.0000  |       2.0000
 5.0000  |       2.2361
 6.0000  |       2.4495
 7.0000  |       2.6458
 8.0000  |       2.8284
 9.0000  |       3.0000
10.0000  |       3.1623

double dx = (to - from) / (n - 1);
for (double x = from; x <= to; x +=dx) {
    double y = (Double) f.invoke(null, x);          // т.к. вызывается статический метод, 1й параметр - null
    System.out.printf("%10.4f | %10.4f%n", x, y);   // где f - это объект типа Method/
}
Math.class.getMethod("sqrt", double.class)

// page 270
// 5.8 Рекомендации по применению наследования


Резюме
1. размещайте общие операции и поля в суперклассе
2. Стараться не пользоваться защищенными (protected) полями
3. Использовать наследование для моделирования отношений - "является"
4. Не пользоваться наследованием, если не все методы имеет смысл сделать наследуемыми
5. Не изменять предполагаемое поведение метода при его переопределении
6. Пользоваться принципом полиморфизма, а не данными о типе
7. Не злоупотреблять механизмом рефлексии

// 273
// 6 глава:
// interfaces | lambdas | inner classes | service loaders | proxies
~ Интерфейсы
~ Лямбда-выражения
~ Внутренние классы
~ Загрузчики служб
~ Прокси-классы


// 6.1 Интерфейсы
// 6.1.1 Понятие интерфейса

// до java 5
public interface Comparable {
    int compareTo(Object other);
}
// после java 5
public interface Comparable<T> {
    int compareTo(T other); //этот параметр относится к обобщенному типу Т
}

Итак, если Comparable<Employee> ->  int compareTo(Employee other);


class Employee implements ComparaЫe<Employee> {
    public int compareTo(Employee other) {
        return DouЫe.compare(salary, other.salary);
    }
    ...
}

// page 289
// 6.1.8 Интерфейс Comparable

public interface Comparator<T> {
    int compare(T first, Т second);
}

// создаем компаратор для сравнения строк по их длине
class LengthComparator implements Comparator<String>{
    public int compare(String first, String second) {
        return first.length() - second.length();
    }
}

var comp = new LengthComparator();
if (comp.compare(words[i], words(j]) > 0) ...

String[] friends = { "Peter", "Paul", "Mary" };
Arrays.sort(friends, new LengthComparator());

// page 290
// 6.1.9 Клонирование объектов

var original = new Employee("Невил Долгопупс", 50000);
Employee copy = original;
copy.raiseSalary(10);   // упс, оригинал тоже изменился!

Employee copy = original.clone();
copy.raiseSalary(10);   // хорошо, теперь оригинал не изменился!

Метод clone() - является защищенным (protected)

Чтобы применить метод clone(), нужно принять следующее решение:
Вариант 1. Достаточно ли метода clone(), предоставляемого по умолчанию?
Вариант 2. Можно ли доработать предоставляемый по умолчанию метод clone() таким образом,
   чтобы вызывать его для изменяемых объектов?
Вариант 3. Следует ли вообще отказаться от применения метода clone()?

Если хотите использовать Вариант 1 или Вариант2, то нужно:
1. Реализовать интерфейс Cloneable.
2. Переопределить метод clone() с модификатором доступа public.

Интерфейс Cloneable - маркерный интерфейс, т.е. не имеет ни одного метода.
Его задача, разрешить выполнение операции instanceof
для проверки типа следующим образом:

if (obj instanceof Cloneable) ...

Для реализации метода clone() по умолчанию(неполное копирование), нужно:
1. реализовать интерфейс Cloneable,
2. переопределить метод clone() как открытый (public)
3. сделать вызов super.clone()

class Employee implements Cloneable {
    // сделать метод открытым, изменить возвращаемый тип
    public Employee clone() throws CloneNotSupportedException {
        return (Employee) super.clone();
    }
    ...
}

// пример реализации метода clone(), выполняющего полное копирование
class Employee implements Cloneable{
    ...

    public Employee clone() throws CloneNotSupportedException{
        // вызов метода Object.clone()
        Employee cloned = (Employee) super.clone();

        // клонировать изменяемые поля
        cloned.hireDay = (Date) hireDay.clone();

        return cloned
    }
}

// пример метода clone() в массивах,
// но он открытый (public), а не защищенный (protected)
int[] luckyNumbers = {2, 3, 5, 7, 11, 13};
int[] cloned = (int[]) luckyNumbers.clone();
cloned[5] = 12;     // не изменяет элемент массива luckyNumbers[5]

// page 296
// 6.2 Лямбда выражения
// 6.2.1 Причины для употребления лямбда-выражений

class Worker implements ActionListener {
    public void actionPerformed(ActionEvent event){
        // сделать что-то
    }
}

class LengthComparator implements Comparator<String> {
    public int compare(String first, String second) {
        return first.length() - second.length();
    }
}
...
Arrays.sort(strings, new LengthComparator());



// 6.2.2 Синтаксис лямбда-выражений
first.length() - second.length()
->
(String first, String second) -> first.length() - second.length()

// -> λfirst.λsecond.first.length() - second.length()

// если есть параметры:
(String first, String second) -> {
    if (first.length() < second.length()) return -1;
    else if (first.length() > second.length()) return 1;
    else return 0;
}

// при отсутствии параметров:
() -> {
    for (int i = 100; i >= 0; i--)
        System.out.println(i);
}

// Можно опустить типы параметров лямбда выражений, т.к.
// результат вычисления лямбда-выражения присваивается компаратору символьных строк.
// (first, second) тоже самое, что и "(String first, String second)"

Comparator<String> comp = (first, second) ->
    first.length() - second.length();

// Если у метода имеется единственный параметр выводимого типа,
// то можно опустить круглые скобки
// вместо (event) -> ...
// или (ActionListener event) -> ...

ActionListener listener = event ->
    System.out.println("Время " + Instant.ofEpochMilli(event.getWhen()));

// Результат вычисления лямбда-выражений вообще не указывается.
// Данное выражение может быть использовано там,
// где ожидается результат типа int
(String first, String second) ->
    first.length() - second.length()


// Недопустимо, чтобы значение возвращалось в одних ветвях лямбда-выражения,
// но не возвращалось в других его ветвях.
(int х) -> (if (х >= 0) return 1;)      // Ошибка!


// page 300
// 6.2.3 Функциональные интерфейсы


Чтобы продемонстрировать преобразование в функциональный интерфейс,
рассмотрим снова метод Arrays.sort().
В качестве второго параметра ему требуется экземпляр типа Comparator - интерфейса с единственным методом.

Вместо него достаточно предоставить лямбда-выражение следующим образом:
Arrays.sort(words, (first, second) -> first.length() - second.length() );
Подспудно метод Arrays.sort() принимает объект некоторого класса,
реализующего интерфейс Comparator.
В результате вызова метода compare() для этого объекта выполняется тело лямбда-выражения.
Управление такими объектами и классами полностью зависит от конкретной реализации
и может быть намного более эффективным, чем применение традиционных внутренних классов.
Поэтому лямбда-выражение лучше всего рассматривать как функцию, а не объект,
приняв к сведению, что оно может быть передано функциональному интерфейсу.

В стандартной библиотеке Java предоставляется целый ряд
весьма универсальных функциональных интерфейсов,
входящих в пакет java.util.function

BiFunction<String, String, Integer> comp
    = (first, second) -> first.length() - second.length();

public interface Predicate<T> {
    boolean test(T t);
    // Дополнительные методы по умолчанию и статические методы
}

// removeIf() - из класса ArrayList, с параметром типа Predicate
list.removeIf(e -> e == null);

// Supplier<T>
public interface Supplier<T>{
    T get();
}

LocalDate hireDay = Objects.requireNonNullOrElse(day, new LocalDate(1970, 1, 1));
->
LocalDate hireDay = Objects.requireNonNullOrElseGet(day,
    () -> new LocalDate(1970, 1, 1));


// page 302
// 6.2.4 Ссылки на методы

var timer = new Timer(1000, event -> System.out.println(event));
->
var timer = new Timer(1000, System.out::println);

Arrays.sort(strings, String::compareToignoreCase)

Разновидности ссылок на методы в лямбда выражениях:
1 Объект:: МетодЭкземпляра
2  Класс:: МетодЭкземпляра
3  Класс:: СтатическийМетод

|       Ссылка на метод        |    Равнозначное лямбда-выражение      |                       Примечания                      |
|------------------------------|---------------------------------------|-------------------------------------------------------|
| System.out::println          |   x -> System.out.println(x)          |   ссылка на метод равнозначна лямбда выражению,       |
|                              |                                       |   параметры которого передаются методу                |
| String::compareToignoreCase  |  (х, у) -> х.compareToignoreCase (у)  |   первый параметр ссылки на метод становится          |
|                              |                                       |   неявным параметром метода                           |
| separator::equals            |   x -> separator.equals(x)            |   Это выражение-метод с заданным объектом             |
|                              |                                       |   экземпляра. Параметр лямбда-выражения               |
|                              |                                       |   передается как явный параметр метода                |
| String::trim                 |   x -> x.trim()                       |   Это выражение-метод с заданным классом и методом    |
|                              |                                       |   экземпляра. Параметр лямбда-выражения становится    |
|                              |                                       |   неявным параметром                                  |
| String::concat               |   (x, y) -> x.concat(y)               |   Здесь вызывается метод экземпляра, но на этот раз   |
|                              |                                       |   с явным параметром. Как и прежде, первый параметр   |
|                              |                                       |   лямбда-выражения становится неявным параметром, а   |
|                              |                                       |   остальные параметры передаются методу               |
| Integer::valueOf             |   x -> Integer::valueOf(x)            |   Это выражение-метод с заданным статическим методом. |
|                              |                                       |   Параметр лямбда-выражения передается этому          |
|                              |                                       |   статическому методу                                 |
| Integer::sum                 |   (x, y) -> Integer::sum(x, y)        |   Это еще один пример вызова статического метода,     |
|                              |                                       |   но на этот раз с двумя параметрами. Оба параметра   |
|                              |                                       |   лямбда-выражения передаются статическому методу.    |
|                              |                                       |   В частости, метод Integer.sun() создается, чтобы    |
|                              |                                       |   служить в качестве ссылки на метод. В качестве      |
|                              |                                       |   альтернативы можно было бы просто составить         |
|                              |                                       |   лямбда-выражение (x, y) -> x + y                    |
| Integer:new                  |   x -> new Integer(x)                 |   Это ссылка на конструктор (6.2.5). Параметры        |
|                              |                                       |   лямбда-выражения передаются конструктору            |
| Integer[]::new               |   n -> new Integer[n]                 |   Это ссылка на конструктор массива (6.2.5) Параметр  |
|                              |                                       |   лямбда-выражения определяет длину массива           |
|------------------------------|---------------------------------------|-------------------------------------------------------|

Objects.isNull(obj) => Predicate =>
list.removeIf(Objects::isNull);     // эту строку легче читать
list.removeIf(e -> e == null);      // чем эту

this::equals        x -> this.equals(x);
super::equals       x -> super.equals(x);

 Ссылка super является целевой и вызывает вариант заданного метода экземпляра из суперкласса.

// Пример
class Greeter {
    public void greet(ActionEvent event) {
        System.out.println("Hello, the time is" + Instant.ofEpochMilli(event.getWhen()))
    }
}

class RepeatedGreeter extends Greeter {
    public void greet(ActionEvent event) {
        var timer = new Timer(1000, super::greet);
        timer.start();
    }
}

// page 305
// 6.2.5 Ссылки на конструкторы

Ссылки на конструкторы действуют таким же образом, как и ссылки на методы,
за исключением того, что вместо имени метода указывается операция new.

ArrayList<String> names = ...;
Stream<Person> stream = names.stream().map(Person::new);
List<Person> people = stream.collect(Collectors.toList());

int[]::new  => x -> new int[x]

Object[] people = steam.toArray();      // допустим требуется создать массив из объектов типа Person
->
Object[] people = steam.toArray(Person[]::new);

// page 306
// 6.2.6 Область видимости переменных

public static void repeatMessage(String text, int delay) {
    ActionListener listener = event -> {
        System.out,println(text);
        Toolkit.getDefaultToolkit().beep();
    };
    new Timer(delay, listener).start();
}

// Следующий вызов:
repeatMessage("Hello", 1000);   // выводит слово - Hello 1000 раз в отдельном потоке исполнения

Переменная - text, весьма необычна.

Лямбда-выражение имеет следующие составляющие:
1. Блок кода
2. Параметры
3. Значения свободных переменных, т.е. таких переменных,
   которые не являются параметрами и не определены в коде
-> text - это свободная переменная (строка "Hello")
// значение переменной text захвачено лямбда-выражением.

// Блок кода вместе со значениями свободных переменных называется - замыканием.
// Лямбда-выражения служат в качестве замыканий
// В лямбда-выражении можно ссылаться только на те переменные, значения которых не изменяются.

public static void countDown(int start, int delay){
    ActionListener listener = event -> {
        start--;    // ОШИБКА! изменить захваченную переменную нельзя!
        System.out.println(start);
    };
    new Timer(delay, listener).start();
}

// В лямбда-выражении не допускается ссылаться на переменную, которая изменяется извне.
public static void repeat(String text, int count) {
    for (int i = 1; i <= count; i++) {
        ActionListener listener = event -> {
            System.out.println(i + ": " + text);    // Ошибка! Нельзя ссылаться на изменяемую переменную "i"
        };
        new Timer(1000, listener).start();
    }
}

// Правило гласит: любая захваченная переменная в лямбда-выражении должна
// быть действительно конечной, т.е. такой переменной,
// которой вообще не присваивается новое значение после ее инициализации.

// Не допускается объявлять параметр или переменную в лямбда-выражении
// с таким же именем как и у локальной переменной:

Path first = Path.get("/usr/bin");
Comparator<String> comp = (first, second) -> first.length() - second.length(); // ОШИБКА! переменная first уже определена!

public class Application() {
    public void init() {
        ActionListener listener = event -> {
            System.out.println(this.toString());
            ...
        }
        ...
    }
}

// page 308
// 6.2.7 Обработка лямбда-выражений

// Причины для отложенного выполнения кода:
1. Выполнение кода в отдельном потоке.
2. Неоднократное выполнение кода.
3. Выполнение кода в нужный момент по ходу алгоритма (например, выполнение операции сравнения при сортировке).
4. Выполнение кода при наступлении какого-нибудь события (щелчка на экранной кнопке, поступления данных и т.д.).
5. Выполнение кода только по мере надобности.

// Пример:
repeat(10, () -> System.out.println("Hello, World!"));

public static void repeat(int n, Runnable action) {
    for (int i = 0; i < n; i++){
        action.run();
    }
}

public interface IntConsumer {
    void accept(int value);
}

// Обновленный метод repeat():
public static void repeat(int n, IntConsumer action) {
    for (int i = 0; i < n; i++) {
        action.accept(i);
    }
}

// вызов нового метода repeat():
repeat(10, i -> System.out.println("Countdown: " + (9 - i)));

// таблица 6.2 наиболее употребляемые функциональные интерфейсы:
|----------------------|------------ |--------------|------------------|-----------------------|-----------------------|
|    Функциональный    |    Типы     | Возвращаемый | Имя абстрактного |        Описание       |         Другие        |
|       интерфейс      | параметров  |     тип      |      метода      |                       |         методы        |
| -------------------- |------------ |--------------|------------------|-----------------------|-----------------------|
| Runnable             | отсутствует |     void     |        run       | Выполняет действие без|                       |
|                      |             |              |                  | аргументов или возвра-|                       |
|                      |             |              |                  | щаемого значения      |                       |
|----------------------|-------------|--------------|------------------|-----------------------|-----------------------|
| Supplier<T>          | отсутствует |       T      |        get       | Предоставляет значение|                       |
|                      |             |              |                  | типа T                |                       |
|----------------------|-------------|--------------|------------------|-----------------------|-----------------------|
| Consumer<T>          |      T      |     void     |      accept      | Употребляет значение  |        andThen        |
|                      |             |              |                  | типа T                |                       |
|----------------------|-------------|--------------|------------------|-----------------------|-----------------------|
| BiConsumer<T, U>     |     T, U    |     void     |      accept      | Употребляет значение  |        andThen        |
|                      |             |              |                  | типа T и U            |                       |
|----------------------|-------------|--------------|------------------|-----------------------|-----------------------|
| Function<T, R>       |      T      |      R       |       apply      | Функция с аргументом  |   compose, andThen,   |
|                      |             |              |                  | T                     |   identity            |
|----------------------|-------------|--------------|------------------|-----------------------|-----------------------|
| BiFunction<T, U, R>  |     T, U    |      R       |      apply       | Функция с аргументами |        andThen        |
|                      |             |              |                  | T и U                 |                       |
|----------------------|-------------|--------------|------------------|-----------------------|-----------------------|
| UnaryOperator<T>     |      T      |      T       |      apply       | Унарная операция над  |   compose, andThen,   |
|                      |             |              |                  | типом T               |   identity            |
|----------------------|-------------|--------------|------------------|-----------------------|-----------------------|
| BinaryOperator<T>    |     T, T    |      T       |      apply       |Двоичная операция над  | andThen,maxBy, minBy  |
|                      |             |              |                  |типом T                |                       |
|----------------------|-------------|--------------|------------------|-----------------------|-----------------------|
| Predicate<T>         |      T      |    boolean   |       test       | Булевозначная функция |   and, or, negate,    |
|                      |             |              |                  |                       |        isEqual        |
|----------------------|-------------|--------------|------------------|-----------------------|-----------------------|
| BiPredicate<T, U>    |     T, U    |    boolean   |       test       | Булевозначная функция |    and, or, negate    |
|                      |             |              |                  | с аргументами         |                       |
|----------------------|-------------|--------------|------------------|-----------------------|-----------------------|

// Пример: PConsumer -> IntConsumer
// По этому был использован IntConsumer вместо Consumer<Integer>

// таблица 6.3 : Функциональные интерфейсы для примитивных типов,
где обозначения:
1. р, q относятся к типам: int, long, double
2. Р, Q относятся к типам: Int, Long, Double
|----------------------|------------ |--------------|------------------|
|    Функциональный    |    Типы     | Возвращаемый | Имя абстрактного |
|       интерфейс      | параметров  |     тип      |      метода      |
| -------------------- |------------ |--------------|------------------|
| BooleanSupplier      | отсутствует |    boolean   |   getAsBoolean   |
| PSupplier            | отсутствует |      p       |      getAsP      |
| PConsumer            |      p      |     void     |      accept      |
| ObjPConsumer<T>      |     T, p    |     void     |      accept      |
| PFunction<T>         |      p      |      T       |      apply       |
| PToQFunction         |      T      |      q       |     applyAsQ     |
| ToPFunction<T>       |      T      |      T       |     applyAsQ     |
| ToPBiFunction<T, U>  |     T, U    |      p       |     applyAsQ     |
| PUnaryOperator       |      p      |      p       |     applyAsQ     |
| PBinaryOperator      |     p, p    |      p       |     applyAsQ     |
| PPredicate           |      p      |    boolean   |       test       |
|----------------------|-------------|--------------|------------------|

// Функциональные интерфейсы из таблиц 6.2 и 6.3 рекомендованы к употреблению!!!
// Если вы разрабатываете собственный интерфейс с единственным абстрактным методом,
// его можно пометить аннотацией @Functionalinterface. Это не обязательно,
// но дает ряд преимуществ.

// page 311
// 6.2.8 Еще о компараторах

// Comparator -> comparing () (статический метод)
// Имеется массив объектов типа Person. Сортировка его элементов по имени.
Arrays.sort(people, Comparator.comparing(Person::getName));

// Компараторы можно связывать в цепочку с помощью метода thenComparing().
Если у двух людей оказываются одинаковые фамилии, то применяется второй компаратор.
Arrays.sort(people, Comparator
    .comparing(Person::getLastName)
    .thenComparing(Person::getFirstName));

// люди сортируются по длине их имен:
Arrays.sort(people, Comparator.comparing(Person::getName,
    (s, t) -> Integer.compare(s.length(), t.length())));
->
Arrays.sort(people, Comparator.comparingInt(
    p -> p.getName().length()));

// методы nullFirst() и nullLast() принимающие имеющийся компаратор,
// чтобы он не генерировал исключение при появлении пустых значений - null.
Comparator.comparing(Person::getMiddleName(),
    Comparator.nullFirst(...))
->
// производится статический импорт по директиве java.util.Comparator.*
Arrays.sort(people, comparing(Person::getMiddleName, nullsFirst(naturalOrder())));

// статический метод reverseOrder() производит сортировку в порядке,
// обратном естественному (naturalOrder()).
// naturalOrder().reversed() = reverseOrder()


// page 312
// 6.З Внутренние классы

// Зачем нужны внутренние классы?
1. Внутренний класс можно скрыть от других классов того же пакета.
2. Объект внутреннего класса имеет доступ к данным объекта,
   в котором он определен, включая закрытые данные.

// 6.3.1 Доступ к состоянию объекта с помощью внутреннего класса

//
public class TalkingClock {
    private int interval;
    private boolean beep;

    public TalkingClock(int interval, boolean beep) {...}
    public void start() {...}

    // внутренний класс
    public class TimerPrinter implements ActionListener {
        ...
    }
}

// подробнее класс TimerPrinter
public class TimerPrinter implements ActionListener {
    public void actionPerformed(ActionEvent event) {
        System.out.println("Сигнал прозвучал в " + Instant.ofEpochMilli(event.getWhen()));
        if (beep) Toolkit.getDefaultToolkit().beep();

    }
}
// в классе TimePrinter отсутствует поле beep.
// Вместо этого метод actionPerformed() обращается к соответствующему полю объекта типа TalkingClock.
// Добавим в код ссылку на объект внешнего класса - other.
->
public class TimerPrinter implements ActionListener {
    public void actionPerformed(ActionEvent event) {
        System.out.println("Сигнал прозвучал в " + Instant.ofEpochMilli(event.getWhen()));
        if (other.beep) Toolkit.getDefaultToolkit().beep();
    }
}
 -> public TimerPrinter(TalkingClock){
    // автоматически генерируется код
    other = clock;
 }

 var = new TimePrinter(this); //параметр добавляется автоматически


// page 316
// 6.3.2 Специальные синтаксические правила для внутренних классов

// ВнешнийКласс.this    - ссылка на внешний класс из внутреннего
// Пример такой ссылки в классе TimerPrinter
public void actionPerformed(ActionEvent event) {
    ...
    if (TalkingClock.this.beep) Toolkit.getDefaultToolkit().beep();
}

ОбъектВнешнегоКласса.new ВнутреннийКласс(параметры конструктора)

// Пример:
ActionListener listener = this.new TimePrinter();

TalkingClock jabberer = new TalkingClock(1000, true);
TalkingClock.TimePrinter listener = jabberer.new TimePrinter();

// Если ссылка на внутренний класс делается
// за пределами области действия внешнего класса,
ВнешнийКласс.ВнутреннийКласс


// page 317
// 6.3.3 О пользе, необходимости и безопасности внутренних классов

// Обращение с внутренними классами происходит на уровне компилятора, а не виртуальной машины.
// Для обозначения внутренних классов используется знак $, разделяющий имена внешних и внутренних классов.
// -> для виртуальной машины внутренние классы неотличимы от внешних.

// ВнутреннийКласс TimePrinter входящий в состав ВнешнегоКласса TalkingClock преобразуется компилятором в
// -> TalkingClock$TimePrinter

// javap -private ИмяКласса

// Для UNIX:
java reflection.ReflectionTest ВнутреннийКласс.TalkingClock\$TimePrinter
или же так:
javap -private ВнутреннийКласс.TalkingClock\$TimePrinter
->
public class innerClass.TalkingClock$TimePrinter implements java.awt.event.ActionListener {
    final innerClass.TalkingClock this$0;
    public innerClass.TalkingClock$TimePrinter(innerClass.TalkingClock);
    public void actionPerformed(java.awt.event.ActionEvent);
}

// this$0 синтезируется компилятором, поэтому сослаться на него нельзя.

class TalkingClock {
    ...
    public void start() {
        var listener = new TimePrinter(this);
        var timer = new Timer(interval, listener);
        timer.start();
    }
}

class TimePrinter implements ActionListener {
    private TalkingClock outer;
    ...
    public TimePrinter(TalkingClock clock) {
        outer = clock;
    }
}

// Рассмотрим теперь метод actionPerformed().
// Ему требуется доступ к полю outer.beep
if (outer.beep) ... // ОШИБКА! ->
// -> Внутренний класс может иметь доступ к закрытым данным лишь того внешнего класса, в который он входит.
// Но класс TimePrinter уже не является внутренним, а следовательно, не имеет такого доступа.

// Внутренние классы, намного эффективнее, чем обычные,
// т.к. они обладают более высокими правами доступа.

class TalkingClock {
    private int interval;
    private boolean beep;
    public TalkingClock(int, boolean);
    static boolean access$0(TalkingClock);
    public void start();
}

if (beep) -> if (TalkingClock.access$0(outer))

// Если внутренний класс имеет доступ к закрытым полям,
// можно создать другой класс, добавить его в тот же самый пакет
// и получить доступ к закрытым данным.

private TalkingClock$TimePrinter(TalkingClock);
// чтобы вызвать такой конструктор, нужно вызвать второй конструктор
->
TalkingClock$TimePrinter(TalkingClock, TalkingClock$1);
// Компилятор преобразует вызов конструктора в методе start() из класса TalkingClock
new TalkingClock$TimePrinter (this, null)

// page 320
// 6.3.4 Локальные внутренние классы

// Т.к. класс TimePrinter используется лишь однажды:
// при создании объекта данного типа в методе start(),
// его можно определить локально в отдельном методе (start())
->
public void start() {
    class TimePrinter implements ActionListener {
        public void actionPerformed(ActionEvent event) {
            System.out.println("Во время сигнала, время " + Instant.ofEpochMilli(event.getWhen()));
            if (beep) Toolkit.getDefaultToolkit().beep();
        }
    }
    var listener = new TimePrinter();
    var timer = new Timer(interval, listener);
    timer.start();
}

// В локальных внутренних классах не используются модификаторы:
// 1. public
// 2. protected

// Преимущества локальных внутренних классов:
// они полностью скрыты от внешнего кода и даже от остальной части класса TalkingClock
// ни одному методу кроме start() ничего неизвестно о TimePrinter

// page 321
// 6.3.5 Доступ к конечным переменным из внешних методов

// Локальные внутренние классы имеют доступ не только к полям своего внешнего класса,
// но и к локальным переменным.
// Такие локальные переменные должны быть объявлены как действительно конечные.

// Перенесем параметры interval и beep
// из конструктора TalkingClock в метод start()
->
public void start(int interval, boolean beep) {
    class TimerPrinter implements ActionListener {
        public void actionPerformed() {
            System.out.println("Сигнал прозвучал в " + Instant.ofEpochMilli(event.getWhen()));
            if (beep) Toolkit.getDefaultToolkit().beep();
        }
    }
    var listener = new TimePrinter();
    var timer = new Timer(interval, listener);
    timer.start;
}
// Теперь в классе TimePrinter больше не нужно хранить переменную экземпляра beep.
// При создании объекта переменная beep,
// передается конструктору и размещается в поле val$beep.
// Компилятор должен обнаруживать доступ к локальным переменным,
// создавать для каждой из них соответствующие поля,
// а затем копировать локальные переменные в конструкторе таким образом,
// чтобы поля данных инициализировались копиями локальных переменных.


// page 322
// 6.3.6 Анонимные внутренние классы

// если требуется создать единственный объект некоторого класса,
// этому классу можно вообще не присваивать имени.
// такой класс называется - анонимным.

// создается новый объект класса, реализующего интерфейс ActionListener,
// где в фигурных скобках определен требующийся метод actionPerformed().
public void start(int interval, boolean beep) {
    var listener = new ActionListener() {   // но синтаксис анонимных внутренних классов довольно сложен.
        public void actionPerformed(ActionEvent event) {
            System.out.println("Сигнал прозвучал в" + Instant.ofEpochMilli(event.getWhen()));
            if (beep) Toolkit.getDefaultToolkit().beep();
        }
    };
    var timer = new Timer(interval, listener);
    timer.start;
}

// общая форма определения анонимных внутренних классов
new СуперТип(параметры конструирования объектов) {
    методы и данные внутреннего класса
}

// Здесь СуперТип может быть:
// 1. интерфейсом (например ActionListener), и тогда внутренний класс реализует данный интерфейс.
// 2. классом, и в этом случае внутренний класс расширяет данный суперкласс.

// Анонимный внутренний класс не может иметь конструкторов:
// поскольку имя конструктора должно совпадать с именем класса,
// а в данном случае у класса отсутствует имя.
// Вместо этого параметры, необходимые для создания объекта, передаются конструктору суперкласса.
// Если вложенный класс реализует какой-нибудь интерфейс, параметры конструктора можно не указывать.

new ТипИнтерфейса() {
    методы и данные
}

// Если за скобками со списком параметров, необходимых для создания объекта,
следует открытая фигурная скобка, то определяется анонимный вложенный класс:

var queen = new Person("Mary");             // объект типа Person
var count = new Person("Dracula") {...};    // объект внутреннего класса, расширяющего класс Person

// Несмотря на то, что у анонимного класса могут отсутствовать конструкторы,
// это никоим образом не мешает предоставить блок инициализации объекта
var count = new Person("Dracula") {
    { (инициализация) }
    ...
};

// альтернативный вариант метода start() написанный в виде лямбда-выражения:
public void start(int interval, boolean beep) {
    var timer = new Timer(interval, event -> {
        System.out.println("Сигнал прозвучал в " + Instant.ofEpochMilli(event.getWhen()));
        if (beep) Toolkit.getDefaultToolkit().beep();
    });
    timer.start();
}

// Спец прием - инициализация в двойных фигурных скобках
// Если дано:
var friends = new ArrayList<>();
favorites.add("Гарри");
favorites.add("Тони");
favorites.add("Ленни");
invite(friends);

// тогда ->
invite (new ArrayList<String>() {{ add("Гарри"); add("Тони"); add("Ленни"); }})

// Зачастую анонимный подкласс удобно сделать почти,
// но не совсем таким же, как и его суперкласс.
// Но в этом случае следует соблюдать особую осторожность в отношении метода equals().
// в методе equals() необходимо организовать следующую проверку (глава 5):

if (getClass() != other.getClass()) return false;
// Но анонимный подкласс ее не пройдет.


// При выдаче регистрирующих или отладочных сообщений в них нередко требуется включить имя текущего класса:
System.err.println("Something awful happened in " + getClass() );

// Но такой прием не годится для статического метода.
// Ведь вызов метода qetClass(), по существу, означает вызов this.qetClass().
// Но ссылка this на текущий объект для статического метода не годится.
// В таком случае можно воспользоваться следующим выражением:
new Object(){}.getClass().getEnclosingClass()       // получить класс статического метода

// new Object(){}      - создается объект анонимного подкласса, производного от класса Object
// qetEnclosingClass() - метод получает объемлющий его класс, т.е. класс, содержащий статический метод.

// page 325
// 6.3.7 Статические внутренние классы
// К примеру в массиве требуется найти максимальное и минимальное числа.

double min = Double.MAX_VALUE;
double max = Double.MIN_VALUE;
for (double v : values) {
    if (min > 0) min = v;
    if (max < 0) max = v;
}

class Pair {
    private double first;
    private double second;

    public Pair (double f, double s) {
        first = f;
        second = s;
    }

    public double getFirst() { return first; }
    public double getSecond() { return second; }
}

class ArrayAlg {
    public static Pair minmax (double[] values) {
        ...
        return new Pair(min, max);
    }
}

Pair p = ArrayAlg.minmax(d);
System.out.println("min =" + p.getFirst());
System.out.println("max =" + p.getSecond());

// сделать Pair внутренним классам в ArrayAlg
-> ArrayAlg.Pair

ArrayAlg.Pair p = ArrayAlg.Pair.minmax();

class ArrayAlg {
    public static class Pair {
        ...
    }
    ...
}

// Только внутренние классы можно объявлять статическими.
// Его объект не содержит ссылку на создавший его объект внешнего класса.

public static Pair minmax (double[] values) {
    ...
    return new Pair(min, max);
}

// Если бы класс Pair не был объявлен статическим, компилятор сообщил бы,
// что при инициализации объекта внутреннего класса объект типа ArrayAlg недоступен.

// Статический вложенный класс применяется тогда,
// когда доступ к объекту внутреннего класса не требуется.
// Иногда для обозначения статических внутренних классов пользуются термином - вложенные классы.
// В отличие от обычных внутренних классов, у статических внутренних классов
// могут быть статические поля и методы.
// Внутренние классы, определенные в интерфейсах,
// автоматически считаются статическими и открытыми (т.e. static и public).

// page 329
// 6.4 Загрузчики служб
// Нужны для приложений с архитектурой подключаемых модулей.
// В т.ч. для платформ, серверов приложений и прочих сложных решений.

// Если предоставляется служба, то разработчику прикладной программы
// необходимо дать определенную свободу в реализации функциональных средств данной службы.
// Также желательно предоставить на выбор несколько реализаций службы.
// Загрузку служб, соответствующих общему интерфейсу, позволяет упростить класс ServiceLoader.

// С этой целью определяется интерфейс (или суперкласс) с методами,
// которые должен предоставлять каждый экземпляр загружаемой службы.
// К примеру, служба обеспечивает шифрование данных.

package serviceLoader;
public interface Cipher {
    byte[] encrypt(byte[] source, byte[] key);
    byte[] decrypt(byte[] source, byte[] key);
    int strength();
}

package serviceLoader.impl;
public class CaesarCipher implements Cipher {
    public byte[] encrypt(byte[] source, byte[] key) {
        var result = new byte[source.length];
        for (int i = 0; i < source.length; i++){
            result[i] = (byte) (source[i] + key[0]);
        }
        return result;
    }

    public byte[] decrypt(byte[] source, byte[] key) {
        return encrypt(source, new byte[] {
            (byte) - key[0]
        });
    }

    public int strength() {
        return 1;
    }
}


// Пример:
package ru.sectorsj._329_serviceLoader.impl;

import ru.sectorsj._329_serviceLoader.Cipher;

public class CaesarCipher implements Cipher {

    @Override
    public byte[] encrypt(byte[] source, byte[] key) {
        var result = new byte[source.length];
        for (int i = 0; i < source.length; i++) {
            result[i] = (byte) (source[i] + key[0]);
        }
        return result;
    }

    @Override
    public byte[] decrypt(byte[] source, byte[] key) {
        return encrypt(source, new byte[]{
                (byte) - key[0]
        });
    }

    @Override
    public int strength() {
        return 1;
    }
}

package ru.sectorsj._329_serviceLoader;

public interface Cipher {
    byte[] encrypt(byte[] source, byte[] key);
    byte[] decrypt(byte[]source, byte[] key);
    int strength();
}


package ru.sectorsj._329_serviceLoader;

import java.util.Optional;
import java.util.ServiceLoader;

public class ServiceLoaderTest {
    public static void main(String[] args) {
        // Optional<Cipher> cipher = cipherLoader.findFirst();
        Cipher cipher = getCipher(1);
        System.out.println("Проверка main()");

        if (cipher != null) {
            byte[] dataToEncrypt = "Hello my old fiend".getBytes();
            byte[] encryptionKey = {3};     // Ключ для шифрования


            byte[] encryptedData = cipher.encrypt(dataToEncrypt, encryptionKey);
            System.out.println("Шифруемые данные: " + new String(encryptedData));

            byte[] decryptedData =cipher.decrypt(encryptedData, encryptionKey);
            System.out.println("Дешифрованные данные: " + new String(decryptedData));

        } else {
            System.out.println("main(): Не найдена реализация шифра с необходимой стойкостью.");
        }
    }

    public static ServiceLoader<Cipher> cipherLoader = ServiceLoader.load(Cipher.class);

    public static Cipher getCipher(int minStrength) {
        // cipherLoader.iterator()
        for (Cipher cipher : cipherLoader) {
            System.out.println("Загружен шифр: " + cipher.getClass().getName());
            System.out.println("Стойкость шифра: " + cipher.strength());
            if (cipher.strength() >= minStrength) {
                System.out.println("Шифр найден с достаточной стойкостью.");
                return cipher;
            }
        }
        System.out.println("getCipher(): Не найдена реализация шифра с необходимой стойкостью.");
        return null;
    }

    public static Optional<Cipher> getCipher2(int minStrength){
        return cipherLoader.stream()
                .filter(descr -> descr.type() == ru.sectorsj._329_serviceLoader.impl.CaesarCipher.class)
                .findFirst()
                .map(ServiceLoader.Provider::get);
    }
}


директория:
\src
    \main
        \resources
            \META-INF
                \services
файл: ru.sectorsj._329_serviceLoader.Cipher
содержание: ru.sectorsj._329_serviceLoader.impl.CaesarCipher

// Также для работы в нашем модульном проекте понадобится:
// в файле module-info.java указать следующие директивы:
// module hortsmann_v_one {
//     - uses ru.sectorsj._329_serviceLoader.Cipher;
//     - provides Cipher with CaesarCipher;

// page 331
// 6.5 Прокси-классы

// Прокси-классы - классы посредники.
// Чтобы создавать во время выполнения программы новые классы,
// реализующие заданные интерфейсы.
// Прокси-классы требуются в том случае,
если на стадии компиляции еще неизвестно,
// какие именно интерфейсы следует реализовать.

// page 332
// 6.5.1 О применении прокси-классов
// Если требуется:
// 1. сконструировать объект класса, реализующего один или несколько интерфейсов,
      конкретные характеристики которых во время компиляции неизвестны
// 2. создать объект класса, реализующего эти интерфейсы.

->
// Прокси-класс может создавать во время выполнения совершенно новые классы и реализует те интерфейсы,
// В частности, в прокси-классе содержатся следующие методы.
// • Все методы, которые требуют указанные интерфейсы.
// • Все методы, определенные в классе Object (в том числе toString(), equals() и тд)

// Однако тогда нужно предоставить обработчик вызовов, т.е. объект любого класса,
// реализующего интерфейс InvocationHandler.
// В этом интерфейсе единственный метод объявляется следующим образом:
// Object invoke(Object proxy, Method method, Object[] args)

// page 332
// 6.5.2 Создание прокси-объектов
// метод newProxyInstance() из класса Proxy.
// Получает 3 параметра:
// 1. Загрузчик классов (глава 9 том 2)
// 2. Массив объектов типа Class - по одному на каждый реализуемый интерфейс
// 3. Обработчик вызовов.

// два вопроса:
// 1. как определить обработчик
// 2. что можно сделать с полученным в итоге прокси-объектом

// Применение прокси-объектов:
// 1. Переадресация вызовов методов на удаленный сервер.
// 2. Связывание событий, происходящих в пользовательском интерфейсе,
      с определенными действиями, выполняемыми в программе.
// 3. Отслеживание вызовов методов при отладке.

Данный пример - для отслеживания обращений к методам (вариант 3).

class TraceHandler implements InvocationHandler {
    private Object target;

    public TraceHandler(Object t) {
        target = t;
    }

    public Object invoke(Object proxy, Method m, Object[] args) trows Throwable {
        // вывести метод и его параметры
        ...
        // вызвать конкретный метод
        return m.invoke(target, args);
    }
}

// точка входа
public static void main(String[] args) {
    Object value = ...;

    // конструируем оболочку
    var handler = new TraceHandler(value);

    // конструируем прокси-объект для одного или нескольких интерфейсов
    var interfaces = new Class[] { Comparable.class };
    Object proxy = Proxy.newProxyInstance(
        ClassLoader.getSystemClassLoader(),
        new Class[] { Comparable.class }, handler
    );


    var elements = new Object[1000];

    // заполняем элементы прокси-объектами для целых чисел от 1 до 1000
    for (int i = 0; i < elements.length; i++){
        Integer value = i + 1;
        elements[i] = Proxy.newProxyInstance(...);      // прокси-объект для конкретного значения
    }
    // формируем случайное целое число
    Integer key = new Random().nextInt(elements.length) + 1;

    // выполняется поиск по заданному критерию key
    int result = Arrays.binarySearch(elements, key);

    // выводим совпавший элемент, если таковой найден
    if (result >= 0) {
        System.out.println(elements[result]);
    }
}

// Метод binarySearch() ->
// if (elements[i].compareTo(key) < 0) ...

// результаты полной трассировки при выполнении программы:
500.compareTo(288)
250.compareTo(288)
375.compareTo(288)
312.compareTo(288)
281.compareTo(288)
296.compareTo(288)
288.compareTo(288)
288.toString()


// page 336
// 6.5.3 Свойства прокси-классов

// Если дважды вызвать метод newProxyInstance() для одного и того же загрузчика классов и массива интерфейсов,
// будут получены два объекта одного и того же класса.
// Имя этого класса можно определить с помощью метода getProxyClass() следующим образом:

Class proxyClass = Proxy.getProxyClass(null, interfaces);

Прокси-класс всегда:
- открытый (public)
- конечный (final)

// 1. Если все интерфейсы, которые реализуются прокси-классом, объявлены как public,
//    этот класс не принадлежит ни одному конкретному пакету.

// В package1
public interface Interface1 { void method1(); }
public interface Interface2 { void method2(); }
// В package2
public class ProxyClass implements Interface1, Interface2 {
    public void method1() {
        System.out.println("Implementation of method1");
    }
    public void method2() {
        System.out.println("Implementation of method2");
    }
}
// В этом примере оба интерфейса (Interface1 и Interface2) объявлены с модификатором доступа public,
// поэтому ProxyClass может быть размещен в любом месте, не принадлежащем конкретному пакету.


// 2. В противном случае все интерфейсы, в объявлении которых не указан модификатор доступа public,
//    а следовательно, и сам прокси-класс, должны принадлежать одному пакету.

// В package1
interface Interface1 { void method1(); }
// В package2
public interface Interface2 { void method2(); }

// В package2
public class ProxyClass implements Interface1, Interface2 {
    public void method1() {
        System.out.println("Implementation of method1");
    }
    public void method2() {
        System.out.println("Implementation of method2");
    }
}
// Здесь Interface1 объявлен без модификатора доступа public, в то время как Interface2 является public.
// Следовательно, ProxyClass и оба интерфейса должны принадлежать одному пакету.
// В данном случае все они принадлежат package2.


// Вызвав метод isProxyClass() из класса Proxy, можно проверить,
// представляет ли объект типа Class определенный прокси-класс.



// page 339
// 7 глава: Исключения, Утверждения и Протоколирование
// • Обработка ошибок
// • Перехват исключений
// • Рекомендации по обработке исключений
// • Применение утверждений
// • Протоколирование
// • Рекомендации по отладке программ


// • Сообщить пользователю об обнаруженной программной ошибке.
// • Сохранить все результаты его работы.
// • Дать ему возможность благополучно завершить программу.


// page 340
// 7.1 Обработка ошибок

// 1. Вернуться в безопасное состояние и разрешить пользователю выполнить другие команды.
// 2. Дать пользователю возможность сохранить результаты своей работы и аккуратно завершить работу.

// Какие ошибки стоит предусмотреть в первую очередь:
// 1. Ошибки ввода
// 2. Сбои оборудования
// 3. Физические ограничения
// 4. Ошибки программирования

// page 341
// 7.1.1 Классификация исключений
// объект исключения - экземпляр класса, производного от класса Throwable.

// Иерархия наследования исключений:
Throwable
     \ Error                - внутренние ошибки, ситуации в связи с нехваткой ресурсов в среде java.
     \ Exception            - Попытка чтения по достижении конца файла
                            - Попытка открыть несуществующий файл
                            - Попытка получить объект типа Class, если в символьной строке указан несуществующий класс
         \ IOException      - ошибки ввода/вывода
         \ RuntimeException - следствие ошибок программирования
                            - Неверное приведение типов
                            - Выход за пределы массива
                            - Обращение к объекту по пустой ссылке (null)

// page 343
// 7.1.2 Объявление проверяемых исключений
// IOException - 1 глава 2 том книги

// Объявление о том, что данный метод может генерировать исключение
public FileInputStream(String name) throws FileNotFoundException

// Исключение генерируется в следующих четырех случаях.
1. Вызывается метод, генерирующий проверяемое исключение
2. Обнаружена ошибка и с помощью оператора throw явным образом
   генерируется проверяемое исключение (throw - в следующем разделе)
3. Обнаружена ошибка программирования
   пример: выражение а [-1] = О,
   вследствие чего возникает непроверяемое исключение,
   например, типа ArrayIndexOutOfBoundsException
4. Возникает внутренняя ошибка в виртуальной машине или библиотеке исполняющей системы

Class MyAnimation {
    ...
    public Image loadImage(String s) throws IOException {
        ...
    }
}

// Если у метода есть несколько проверяемых исключений,
// все они должны быть перечислены в ero заголовке через запятую,
Class MyAnimation {
    ...
    public Image loadImage(String s) throws FileNotFoundException, EOFException {
        ...
    }
}

// исключения, производные от класса Error, объявлять не нужно.
// не обязательно объявлять непроверяемые исключения,
// производные от класса RuntimeException
Class MyAnimation {
    ...
    public Image loadImage(String s) throws ArrayIndexOutOfBoundsException { // не рекомендуется
        ...
    }
}

// В методе должны быть объявлены все проверяемые исключения,
// которые он может сгенерировать.
// А непроверяемые исключения находятся вне контроля разработчика данного метода (класс Error)
// или же являются следствием логических ошибок,
// которые не следовало допускать (класс RuntimeException).
// Если же в объявлении метода не сообщается обо всех проверяемых исключениях,
// компилятор выдаст сообщение об ошибке.

// page 346
// 7.1.З Порядок генерирования исключений

readData()
// в заголовке указано Content-length: 1024
// но после 733 символа достигнут конец файла
->
throw new EOFException();
// или
var e = new EOFException();
throw e;

String readData(Scanner in) throws EOFException {
    ...
    while(...) {
        if (!in.hasNext()) {     // достигнут конец файла (признак EOF)
           if (n < len) throw new EOFException();
        }
        ...
    }
    return s;
}

// В классе EOFException имеется второй конструктор,
// получающий в качестве параметра символьную строку.
String gripe = "Content-length: " + len + ", Received: " + n;
throw new EOFException(gripe);

// 1. Найти подходящий класс
// 2. Создать экземпляр этого класса
// 3. Сгенерировать исключение

// page 347
// 7.1.4 Создание классов исключений

// Создание своего собственного класса исключения
class FileFormatException extends IOException {
    public FileFormatException() {}
    public FileFormatException(String gripe) {
        super(gripe);
    }
}

// Генерация исключения собственного типа
String readData (BufferedReader in) throws FileFormatException {
    ...
    while (...) {
        if (ch == -1) // достигнут конец файла (признак EOF) {
            if (n < len) throw new FileFormatException();
        }
        ...
    }
    return s
}

// page 348
// 7.2 Перехват исключений
// 7.2.1 Перехват одного исключения

// Перехват исключения осущесrвляется в блоке операторов try/catch
try {
    код
    дополнительный код
    дополнительный код
} catch (ТипИсключения e) {
    обработчик исключений данного типа
}
// Если фрагмент кода в блоке оператора try генерирует исключение типа,
// указанного в заголовке блока оператора catch, то программа:
// 1. пропускает оставшуюся часть кода в блоке оператора try.
// 2. выполняет код обработчика в блоке оператора catch.

// Если код в блоке оператора try не генерирует исключение, то программа:
// 1. пропускает блок оператора catch

// Если какой-нибудь оператор из блока try сгенерирует исключение,
// отличающееся от типа, указанного в блоке catch,
// то выполнение данной программы (в частности, вызываемого метода)
// немедленно прекращается.

// пример:
public void read(String filename) {
    try {
        var in = new FileInputStream(filename);
        int b;
        while ((b = in.read()) != -1) {
            обработать введенные данные
        }
    } catch (IOException exception) {
        exception.printStackTrace();
    }
}

// Передача исключения вызывающей части программы.
// Если в методе read() возникнет ошибка ввода,
// ответственность за обработку этой исключительной ситуации
// следует возложить на вызывающую часть программы
->
public void read(String filename) throws IOException {
    // блоки try/catch отсутствуют!
    var in = new FileInputStream(filename);
    int b;
    while ((b = in.read()) != -1) {
        обработать введенные данные
    }
}

// page 350
// 7.2.2 Перехват нескольких исключений

// В блоке оператора "try" можно перехватить несколько исключений, обработав их по отдельности.
// Для каждого типа исключения следует предусмотреть свой блок оператора "catch".

try {
    // код способный генерировать исключения
} catch (FileNotFoundException e) {
    // чрезвычайные действия, если отстутвуют нужные файлы
} catch (UnknownHostException e) {
    // чрезвычайные действия, если хосты неизвестны
} catch (IOException e) {
    // чрезвычайные действия во всех остальных случаях
    // появления ошибок ввода-вывода
}

// Объект исключения содержит сведения об объекте.
// вызов, чтобы получить доп.сведения об этом объекте из подробного сообщения об ошибке,
    e.getMessage()
// вызов, чтобы получить конкретный тип объекта исключения:
    e.getClass().getName()

// Объединение похожих исключений (после java 7):
try {
    // код способный генерировать исключения
} catch (FileNotFoundException | UnknownHostException e) {  // переменная исключения "e" неявно считается конечной (final)
    // чрезвычайные действия, если отстутвуют нужные файлы
    // или хосты неизвестны
} catch (IOException e) {
    // чрезвычайные действия во всех остальных случаях
    // появления ошибок ввода-вывода
}


// page 351
// 7.2.З. Повторное генерирование и связывание исключений в цепочку

// Исключение можно генерировать и в блоке catch, образуя тем самым цепочку исключений.
// Если разрабатывается подсистема для применения другими разработчиками,
// то имеет смысл генерировать исключения, указывающие на то,
// что ошибка возникла именно в этой подсистеме.

try {
    // получить доступ к базе данных
} catch (SQLException ex) {
    // текст сообщения об исключении формируется в конструкторе класса ServletException.
    throw new ServletException("database error: " + ex.getMessage());
}

try {
    // получить доступ к БД
} catch (SQLException original) {
    var e = new ServletException("database error");
    e.initCause(original);
    throw e;
}

// При перехвате последующего исключения, предыдущее исключение можно извлечь следующим образом:
Throwable original = caughtException.getCause();

// Регистрация исключения и повторная его генерация, без всяких изменений:
try {
    // получить доступ к БД
} catch (Exception e) {
    logger.log(level, message, e);
    throw e;
}
// -> допустимо после версии java 7:
public void updateRecord() throws SQLException


// page 352
// 7.2.4 Блок оператора finally

// В java 7 появилось более удачное решение - try с ресурсами

// Код в блоке оператора finally выполняется независимо от того, возникло исключение или нет.
var in = new FileInputStream();
try {
    // 1
    // Код, способный генерировать исключения
    // 2
} catch (IOException e) {
    // 3
    // Выводим сообщение об ошибке
    // 4
} finnaly {
    // 5
    in.close
}
// 6

// 3 варианта в которых программа выполняет блок оператора finally:
// 1. Код не генерирует никаких исключений. В этом случае программа сначала
//    полностью выполняет блок оператора try, а затем блок оператора finally.
//    Выполнение программы последовательно проходит через точки 1, 2, 5, 6.

// 2. Код генерирует исключение, которое перехватывается в блоке оператора catch
//    в данном примере это исключение типа IOException).
//    В этом случае программа сначала выполняет блок try до той точки,
//    в которой возникает исключение, а остальная часть блока оператора try пропускается.
//    Затем программа выполняет код из соответствующего блока оператора catch,
//    и далее код из блока оператора finally.
//    Если в блоке оператора catch исключения не генерируются,
//    то выполнение программы продолжается с первой строки, следующей после блока оператора try.
//    Таким образом, выполнение программы последовательно проходит через точки 1, 3, 4, 5 и 6.
//    Если же исключение генерируется в блоке оператора catch,
//    то управление передается вызывающей части программы и выполнение программы
//    проходит только через точки 1, 3 и 5.

// 3. Код генерирует исключение, которое не обрабатывается в блоке оператора catch.
//    В этом случае программа выполняет блок try вплоть до той точки,
//    в которой генерируется исключение, а оставшаяся часть блока оператора try пропускается.
//    Затем программа выполняет код из блока оператора finally
//    и передает исключение обратно вызывающей части программы.
//    Таким образом, выполнение программы проходит только через точки 1 и 5.

// Блок оператора finally можно использовать и без блока оператора catch.
InputStream in = ...;
try {
    // Код, способный генерировать исключения
} finally {
    in.close();
}
// -> Оператор in.close() из блока finally выполняется независимо от того, возникает ли исключение в блоке try.

// Если исключение возникает, оно будет перехвачено в очередном блоке саtch:
InputStream in = ...;
try {
    try {
        // Код, способный генерировать исключения
    } finally {
        in.close();
    }
} catch (IOException) {
    // вывести сообщение об ошибке
}

// Здесь внутренний блок оператора try отвечает только за закрытие потока ввода,
// а внешний блок оператора try сообщает об ошибках.
// Такой код не только более понятен, но и более функционален,
// поскольку ошибки выявляются и в блоке оператора finally.

public static int parseInt(String s) {
    try {
        return Integer.parseInt(s);
    } finally {
        return 0;   // Ошибка!
    }
}
// На первый взгляд, если сделать вызов parseInt("42"),
// то из блока оператора try должно возвратиться целочисленное значение 42.
// Но блок оператора finally выполняется прежде возврата из метода Integer.parseInt(),
// и поэтому данный метод возвратит нулевое значение,
// пренебрегая первоначальным возвращаемым значением.

// Хуже того, если сделать вызов parseint ("zero"),
// то в методе Integer.parseInt() будет сгенерировано исключение типа NuшЬerFormatException.
// А затем будет выполнен блок оператора finally, где оператор return поглотит исключение!
// Блок оператора finally предназначен для освобождения ресурсов.
// Поэтому в нем не следует размещать операторы (return, throw, break, continue),
// изменяющие порядок выполнения прикладного кода.

// "Вызывающая часть программы" относится к тому участку кода,
// который вызвал метод, в котором произошло исключение.
// Когда исключение не может быть обработано в текущем методе,
// оно "передается" или "поднимается" выше по стеку вызовов к ближайшему контексту,
// который может обработать это исключение.

// Предположим, у вас есть метод foo(), который вызывает метод bar(),
// а метод bar() бросает исключение, которое не обрабатывается в методе bar().
// В этом случае исключение будет передано обратно в метод foo(), который вызвал метод bar().
// Если исключение также не будет обработано в методе foo(), оно будет передано еще выше по стеку вызовов.

// "Вызывающая часть программы" может быть методом из вашего собственного класса,
// сторонней библиотеки или даже системным вызовом.
// Это часть кода, которая вызвала текущий метод, где произошло исключение.

public class Example {
    public static void main(String[] args) {
        try {
            foo();
        } catch (Exception e) {
            System.out.println("Исключение обработано в методе main: " + e.getMessage());
        }
    }

    public static void foo() throws IOException {
        bar();
    }

    public static void bar() throws IOException {
        throw new IOException("Исключение в методе bar");
    }
}
// Здесь метод bar() бросает исключение, которое не обрабатывается в нем самом.
// Тогда исключение передается обратно в метод foo(), который вызвал bar(),
// а затем перехватывается в методе main(), который вызвал foo().
// Таким образом, метод main() является "вызывающей частью программы" в этом контексте.


// "Освободить ресурсы" - означает освобождение занимаемых программой ресурсов после их использования.
// Ресурсы могут включать в себя файлы, сетевые соединения,
// базы данных, память, блокировки и другие системные ресурсы.

// В языках программирования, таких как Java, C++, Python и других,
// управление ресурсами является важным аспектом программирования.
// Если ресурсы не будут освобождены правильно после использования,
// это может привести к утечкам ресурсов и, как следствие,
// к неэффективному использованию памяти, перегрузке системы или даже к ошибкам работы программы.

Примеры освобождения ресурсов:

1. Закрытие файловых потоков после чтения или записи данных в файл.
2. Закрытие сетевых соединений после передачи данных по сети.
3. Освобождение памяти, выделенной под объекты, которые больше не нужны, с помощью сборщика мусора.
4. Закрытие баз данных после выполнения запросов или обновлений.
5. Освобождение блокировок или других ресурсов синхронизации после завершения работы с ними.

// В контексте программирования и управления ресурсами,
// термин "ресурсы" может относиться к различным видам ресурсов,
// как физическим, так и программным.

// 1. Физические ресурсы могут включать в себя такие объекты как:
    // - файлы
    // - сетевые соединения
    // - базы данных
    // - порты ввода-вывода (например, ввод с клавиатуры или вывод на экран)
    // - память (например, выделенная память или файл подкачки)
    // - устройства ввода-вывода (например, принтеры, сканеры)
    // и т. д.

// 2. Программные ресурсы могут включать в себя:
    // - объекты в памяти, созданные в ходе выполнения программы
    // - потоки данных
    // - блокировки
    // - семафоры
    // - указатели на области памяти и т.д.

// Управление физическими и программными ресурсами одинаково важно в программировании.
// В обоих случаях освобождение ресурсов после их использования
// способствует эффективному использованию ресурсов компьютерной системы
// и предотвращает утечки памяти или другие проблемы,
// связанные с неправильным управлением ресурсами.


// page 355
// 7.2.5 Оператор try с ресурсами

// В версии Java 7 внедрена следующая удобная конструкция,
// упрощающая код обработки исключений, где требуется освобождать используемые ресурсы:

// открыть ресурс
try {
    // использовать ресурс
} finally{
    // закрыть ресурс
}

// Эта конструкция эффективна при одном условии: используемый ресурс принадлежит классу,
// реализующему интерфейс AutoCloseable.

// В этом интерфейсе имеется единственный метод:
void close() throws Exception

// Существует еще интерфейс Closeable, также реализующий 1 метод - close()
// Но этот интерфейс объявляется для генерации исключения типа - IOException

try (Resource res = ...) {
    использовать ресурс res
}

// Если в коде имеется блок оператора try, то метод res.close() вызывается автоматически.
// Пример ввода всего текста из файла и последующего его вывода:
try (var in = new Scanner (new FileInputStream ("/user/share/dist/words"), StandardCharsets.UTF8)) {
    while (in.hasNext()) System.out.println(in.next());
}

// Независимо от того, происходит ли выход из блока оператора try нормально,
// или же в нем возникает исключение, метод in.close() вызывается в любом случае,
// как и при использовании блока оператора finally.

// В блоке оператора try можно указывать несколько ресурсов
try (var in = new Scanner (
                new FileInputStream("/usr/share/dist/words"), StandardCharsets.UTF_8);
                var out = new PrintWriter("out.txt", StandardCharsets.UTF_8)) {
    while (in. hasNext()) out.println(in.next().toUpperCase());
}

// В версии Java 9 появилась возможность предоставлять предварительно объявляемые
// действительно конечные переменные в заголовке оператора try:
public static void printAll (String[] lines, PrintWriter out) {
    try (out) {     // действительно конечная переменная
        for (String line: lines) out.println(line);
    }               // здесь делается вызов out.close()
}

// Если исключение генерируется не только в блоке оператора try, но и в методе close().
// Исходное исключение генерируется повторно, а любые исключения, генерируемые в методе close(),
// считаются "подавленными".
// Они автоматически перехватываются и добавляются к исходному исключению с помощью метода addSuppressed().
// Если они представляют какой-то интерес с точки зрения обработки, то следует вызвать метод getSuppressed(),
// получающий массив подавленных исключений из метода close().

// page 356
// 7.2.6 Анализ элементов трассировки стека

// Трассировка стека - это список вызовов методов в данной точке выполнения программы.
// Ведь они выводятся всякий раз, когда при выполнении программы на Java
// возникает непроверяемое или необрабатываемое исключение.

// Для получения текстового описания трассировки стека
// достаточно вызвать метод printStackTrace() из класса Throwable

var t = new Throwable();
var out = new StringWriter();
t.printStackTrace(new PrintWriter(out));
String description = out.toString();

// можно использовать StackWalker ->
// StackWalker.StackFrame

StackWalker walker = StackWalker.getInstance();
walker.forEach (frame -> проанализировать frame)

// В классе StackWalker.StackFrarne имеются методы для получения:
// - имени файла
// - номера строки кода,
// - объекта анализируемого класса
// - имени метода из исполняемой строки кода.

// Вычисление факториала числа 3
// Результаты трассировки стека вызова factorial(3):
Введите n: 3
factorial(3):
hortsmann_v_one/ru.sectorsj._357_stackTrace.StackTraceTest.factorial(StackTraceTest.java:22)
hortsmann_v_one/ru.sectorsj._357_stackTrace.StackTraceTest.main(StackTraceTest.java:10)
factorial(2):
hortsmann_v_one/ru.sectorsj._357_stackTrace.StackTraceTest.factorial(StackTraceTest.java:22)
hortsmann_v_one/ru.sectorsj._357_stackTrace.StackTraceTest.factorial(StackTraceTest.java:25)
hortsmann_v_one/ru.sectorsj._357_stackTrace.StackTraceTest.main(StackTraceTest.java:10)
factorial(1):
hortsmann_v_one/ru.sectorsj._357_stackTrace.StackTraceTest.factorial(StackTraceTest.java:22)
hortsmann_v_one/ru.sectorsj._357_stackTrace.StackTraceTest.factorial(StackTraceTest.java:25)
hortsmann_v_one/ru.sectorsj._357_stackTrace.StackTraceTest.factorial(StackTraceTest.java:25)
hortsmann_v_one/ru.sectorsj._357_stackTrace.StackTraceTest.main(StackTraceTest.java:10)
return 1
return 2
return 6

// page 361
// 7.3 Рекомендации по обработке исключений

// Рекомендации по применению и обработке исключений в прикладных программах:
1. Обработка исключений не может заменить собой простую проверку

if (!s.empty)) s.pop();

try {
    s.pop
} catch (EmptyStackException e) {}

// Перехват исключения занимает намного больше времени, чем просrая проверка.
// Вывод: пользоваться исключениями только в тех случаях, когда это оправданно,
// что зачастую бывает лишь в исключительных ситуациях.

// 2. Не доводить обработку исключений до абсурдных мелочей

// неправильно
PrintStream out;
Stack s;
for (int i = 0; i < 100; i++) {
    try {
        n = s.pop();
    } catch (EmpryStackException) {
        // Стек оказася пуст
    }
    try {
        out.writInt(n);
    } catch (IOException) {
        // сбой при записи данных в файл
    }
}

// правильно
PrintStream out;
Stack s;
for (int i = 0; i < 100; i++) {
    n = s.pop;
    out.writeInt(n)
} catch (IOException) {
    // сбой при записи данных в файл
} catch (EmptyStackException) {
    // стек оказался пустым
}

// 3. Правильно пользуйтесь возможностями,
//    которые прежоставляет иерархия наследования исключений

// - Не ограничивайтесь генерированием только исключения типа RuntimeException.
// - Найдите подходящий подкласс или создайте собственный.
// - Не перехватывайте исключение типа Throwable.
// - Правильно различайте проверяемые и непроверяемые исключения.
// - Смело преобразуйте, если требуется, один тип исключения в другой,
//   более подходящий в данной ситуации.

// 4. Не подавляйте исключения
// неправильно
public Image loadImage (String s) {
    try {
        // код, способен генерировать проверяемые исключения
    } catch (Exception e)
    {} // ничего не делать
}

// 5. Обнаруживая ошибки, проявляйте необходимую твердость
//    вместо излишней терпимости

// Пример: лучше сгенерировать исключение типа EmptyStackException в той точке,
// где возникла ошибка, чем исключение типа NullPointerException впоследствии.

// 6. Не бойтесь передавать исключения для обработки в коде,
//    разрабатываемом другими.

// Предпочтительнее передать исключение другому обработчику,
// а не обрабатывать его самостоятельно,
public void readStuff(String filename) throws IOException { // Не нужно этого стесняться!
    var in = new FileInputStream (filename, StandardCharsets.UTF_8);
    ...
}
// Методы более высокого уровня лучше оснащены средствами уведомления пользователей
// об ошибках или отмены выполнения неверных операций.

// пп.5, 6 -> генерировать исключения раньше, а перехватывать их позже.

// page 364
// 7.4 Применение утверждений (assert)
// Утверждения (assert) - широко распространенное средство безопасного программирования.

// page 364
// 7.4.1 Понятие утверждения

double у = Math.sqrt(x); // уверены, что значение параметра х не является отрицательным
->
// можно сгенерировать исключение:
if (x < 0) throw new IllegalArgumentException("x < 0");

// но, тогда этот код будет оставаться в программе, даже после тестирования
// Если в исходном коде программы расставлено много таких проверок,
// ее выполнение может замедлиться.

// Механизм утверждений позволяет вводить в исходный код программы проверки для ее тестирования,
// а затем удалять их из окончательного варианта.

// Форма:
// 1. assert условие;
//      и
// 2. assert условие : выражение;

// 1, 2 форма проверяют заданное условие и генерируют исключение типа AssertionError, если оно не выполняется.
// 2 форма, в операторе "выражение" передается конструктору объекта типа AssertionError
// и преобразуется в символьную строку сообщения.

// Цель, которую преследует "выражение" в операторе assert, получить символьную строку сообщения.
// В объекте типа AssertionError конкретное значение выражения не хранится,
// поэтому его нельзя запросить в дальнейшем.

// чтобы проверить, является ли числовое значение переменной х неотрицательным:
assert x >= 0;

// Можно передать конкретное значение переменной "х" объекту типа AssertionError,
// чтобы впоследствии вывести его:
assert x >= 0 : x;

// Можно передать в виде символьной строки объекту типа AssertionError:
assert x >= 0 : "x >= 0";

// page 365
// 7.4.2 Разрешение и запрет утверждений

// По умолчанию утверждения запрещены.
// В ходе выполнения программы можно с помощью параметров:
    -enableassertions или -еа   - разрешить утверждения
    -desableassertions или -dа  - запретить утверждения

// указываемого в командной строке следующим образом:
    java -enableassertions МуАрр
    java -desableassertions МуАрр

// Разрешать утверждения можно в:
// - отдельных классах             -ea:MyClass
// - в целых пакетах               -ea:com.mycompany.mylib MyApp
// - во всех классах из пакета,    -ea...
//   выбираемого по умолчанию

java -ea:MyClass -ea:com.mycompany.mylib MyApp -ea...
java -da:MyClass

// Для разрешения утверждений в системных классах без загрузчика классов:
    -enablesystemassertions/-esa

// page 366
// 7.4.3 Проверка параметров с помощью утверждений

// 3 механизма обработки системных сбоев:
// 1. Генерирование исключений (Exceptions)
// 2. Протоколирование
// 3. Применение утверждений (Asserts)

// 1. Утверждения оказываются ложными, если произошла неустранимая ошибка
// 2. Утверждения разрешаются только на время отладки и тестирования программ


/**
    Упорядочивает указанную часть заданного массива по нарастающей.
    Упорядочиваемая часть массива начинается с индекса fromIndex и заканчивается индексом,
    предшествующим toIndex, т.е. элемент с индексом toIndex упорядочению не подлежит.
    @param а            Упорядочиваемый массив
    @param fromIndex    Индекс первого элемента упорядочиваемой части массива (включительно)
    @param toIndex      Индекс первого элемента, находящегося за пределами упорядочиваемой части массива
    @throws IllegalArgumentException        Если fromIndex > toIndex, генерируется исключение
    @throws ArrayindexOutOfBoundsException  Если fromIndex < О или toIndex > a.length, генерируется исключение
*/
static void sort[] а, int fromIndex, int toIndex
// если к примеру добавить гипотетическое условие
// -> @param а Упорядочиваемый массив. (Не должен быть пустым)
// тогда это будет считаться предусловием.
// ->
assert (a != null); // можно использовать

// page 367
// 7.4.4 Документирование предположений с помощью утверждений

if (i % 3 == 0)
    ...
else if (i % 3 == 1)
    ...
else // (i % 3 == 2)

-> //
if (i % 3 == 0)
    ...
else if (i % 3 == 1)
    ...
else {
    assert i % 3 == 2;
}

// Если переменная i принимает положительное числовое значение, то остаток может быть равным О, 1 или 2.
// А если она принимает отрицательное значение, то остаток может быть равным -1 или -2.
// Намного логичнее предположить, что переменная i не содержит отрицательное числовое значение.
->
assert(i >= 0); // вводим утверждение
if (i % 3 == 0)
    ...
else if (i % 3 == 1)
    ...
else {
    assert i % 3 == 2;
}

// page 368
// 7.5 Протоколирование

// Прикладной программный интерфейс API для протоколирования:
// 1. Все протокольные записи нетруджно запретить или разрешить
// 2. Запрещенные протокольные записи отнимают немного ресурсов и не влияют на эффективность работы приложения
// 3. Протокольные записи можно направить разным обработчикам, вывести на консоль, записать в файл и т.п.
// 4. Регистраторы и обработчики способны фильтровать записи. Фильтры отбрасывают ненужные записи по критериям,
//    предоставляемым теми, кто реализует фильтры
// 5. Протокольные записи допускают форматирование. Пример, представить в виде простого текста или в
//    формате XML
// 6. В приложения можно использовать несколько протоколов, имеющих иерархические имена, продобные именам пакетов,
//    например: com.mycompany.myapp
// 7. Конфигурирование протоколирования определяется в файле конфигураций.

// Во многих приложениях применяются другие библиотеки протоколирования, в том числе:
// Log4J 2 (https://logging.apache.org/log4j/2.x)
// Logback (https://logback.qos.ch),
// обеспечивающие более высокую производительность, чем стандартная для Java библиотека протоколирования.

// Такие библиотеки несколько отличаются своими прикладными интерфейсами API.
// Такие фасады протоколирования, как:
// SLF4J           (https://www.slf4j.org)
// Commons Logging (https://commons.apache.orq/proper/coппnons-logging),
// предоставляют единообразный прикладной интерфейс API,
// чтобы можно было сменить библиотеку протоколирования,
// не переписывая прикладной код. Дело усложняется еще и тем,
// что библиотека Log4J 2 может служить фасадом для таких компонентов, как SLF4J.

// В настоящем издании рассматривается стандартная библиотека протоколирования в Java.
// Целесообразно изучить прикладной интерфейс API этой библиотеки, чтобы лучше понять имеющиеся ее альтернативы.

// page 369
// 7.5.1 Базовое протоколирование

// Для базового протоколирования служит глобальный регистратор:
Logger.getGlobal().info("File-> Open menu item selected");
->
// По умолчанию выводится следующая протокольная запись:
// Мау 10, 2013 10:12:15 РМ LoggingimageViewer fileOpen INFO: File->Open menu item selected


// page 369
// 7.5.2 Продвинутое логирование

// При профессиональной разработке приложений, все записи не накапливаются в одном глобальном протоколе (логе),
поэтому можно определить свои собственные средства протоколирования (логирования).

// Регистратор, на который больше не делается ссылка ни в одной из переменных, собирается в "мусор".
// по-этому, следует сохранить ссылку на регистратор в статической переменной, как показано ниже!

// Для создания или извлечения "регистратора" вызывается метод - getLogger():
private static final Logger myLogger = Logger.getLogger("com.my.company.myapp");

// Как и имена пакетов, имена регистраторов образуют иерархию.
// иерархичные = регистратор > пакет ->
// Если в регистраторе "com.mycompany" задать определенный уровень протоколирования,
// то производный от него регистратор унаследует этот уровень.

// 7 уровней протоколирования (логирования):
// 1. SEVERE  - используется по умолчанию
// 2. WARNING - используется по умолчанию
// 3. INFO    - используется по умолчанию
// 4. CONFIG  - нужно задавать методом setLevel()
// 5. FINE    - нужно задавать методом setLevel() -> logger.setLevel(Level.FINE);
// 6. FINER   - нужно задавать методом setLevel()
// 7. FINEST  - нужно задавать методом setLevel()

logger.setLevel(Level.ALL)                  // Разрешение логирования на всех уровнях
Logger.getGlobal().setLevel(Level.ALL);     // Разрешение логирования на всех уровнях, Глобально

logger.setLevel(Level.OFF)                  // Полностью запрещает протоколирование (логирование)
Logger.getGlobal().setLevel(Level.OFF);     // Полностью запрещает логирование, Глобально

// Для всех уровней определены методы протоколирования:
logger.warning(message);
logger.fine(message);

logger.log(Level.FINE, message);    // метод log() - явно указать уровень логирования

// Для отладочных сообщений, требующихся для диагностики программ (не для пользователей), следует указывать уровни:
// - CONFIG
// - FINE
// - FINER
// - FINEST

// Обработчик протоколов блокирует сообщения, имеющие уровень ниже INFO.

// Протокольная запись, создаваемая по умолчанию, состоит из:
// - имени класса
// - имени метода, содержащего вызов регистратора

// Для уточнения вызывающего класса и метода следует применить метод logp():
void logp(Level l, String className, String method, String message)

// Для отслеживания порядка выполнения диагностируемой программы есть методы:
void entering(String className, String methodName);
void entering(String className, String methodName, Object param);
void entering(String className, String methodName, Object[] params);
void exiting(String className, String methodName);
void exiting(String className, String methodName, Object result);

// пример:
int read(String file, String pattern) {
    logger.entering("com.mymompany.mylib.Reader", "read", new Object[] {file, pattern});
    ...
    logger.exiting("com.mycompany.mylib.Reader", "read", count);
    return count;
}

// Если методы протоколирования будут поддерживать
// переменное число параметров, то тогда станет доступна запись:
logger.entering("com.mycompany.mylib.Reader", "read", file, pattern);

// 2 метода для логирования неожиданных исключений:
void throwing (String className, StringMethodName, Throwable t);
void log (Level l, String message, Throwable t);

// При вызове метода throwing() регистрируется протокольная запись,
// имеющая уровень FINER, а также сообщение, начинающееся со строки THROW
//
if (...) {
    IOException exception = new IOException("...");
    logger.throwing("com.mycompany.mylib.Reader", "read", exception);
    throw exception;
}
и
try {
    ...
} catch (IOException e) {
    Logger.getLogger("com.mycompany.myapp").log(Level.WARNING, "Reader image", e);
}

// page 371
// 7.5.3 Смена диспетчера протоколирования

// Свойства системы протоколирования можно изменить, редактируя конфигурационный файл,
// по умолчанию находящийся по следующему пути:
// conf/loggin.properties
// или
// jre/lib/logging.properties

// Если требуется сменить конфигурационный файл, при запуске приложения,
// необходимо установить свойство "java.util.logging.config.file" на ->
// command: java -Djava.util.logging.conf.file=конфигурационный_файл Главный класс

// Чтобы изменить уровень протоколирования, принятый по умолчанию,
// необходимо отредакгировать конфиrурационный файл, изменив в нем следующую строку:
    .level=INFO

// Чтобы в собственных регистраторах изменить уровни протоколирования
// необходимо добавить к имени регистратора суффикс ".level":
com.mycompany.myapp.level=FINE

// Регистраторы не направляют сообщения на консоль
// Направлять сообщения в консоль - задача обработчиков протоколов

// Чтобы вывести на консоль сообщения, имеющие уровень FINE нужно:
java.util.logging.ConsoleHandler.level=FINE

// Параметры настройки диспетчера протоколирования не являются системными свойствами.
// Запуск прикладной программы с параметром:
// command: -Dcom.mycompany.myapp.level=FINE
// никак не отражается на действиях регистратора.

// Если нужно настроить протоколирование программно в коде, не используя файл конфигурации
// или параметр командной строки, это можно сделать:
System.setProperty("java.util.logging.config.file", file);

// Пример:
System.setProperty("java.util.logging.config.file", "C:/Program Files/Java/jdk/jdk-21.0.2/conf.logging.properties");

// Повторная инициализация диспетчера протоколирования:
// После установки свойства конфигурации протоколирования программно с помощью System.setProperty(),
// также нужно повторно инициализировать диспетчер протоколирования с помощью
LogManager.getLogManager().readConfiguration().
// Это гарантирует, что новая конфигурация будет применена.
// Пример:
try {
    LogManager.getLogManager().readConfiguration();
} catch (IOException e) {
    System.err.println ("Не удалось прочитать файл конфигурации протоколирования");
    e.printStackTrace();
}

// Hачиная с версии java 9, можно обновить конфигурацию логирования с помощью:
LogManager.getLogManager().updateConfiguration(mapper);

// для определения значений по всем ключам в прежней или новой конфигурации
// применяется специальный сопоставитель типа:
Function<String, BiFunction<String, String, String>>

// В качестве удобной схемы сопоставления можно было бы объединить прежние и новые конфигурации,
// отдав предпочтение новому значению, когда ключ присутствует как в прежних,
// так и в новых конфигурациях:
key -> ((oldValue, newValue) -> newValue == null ? oldValue : newValue)

// Если требуется лишь обновить ключи, начиная с com.mycompany, оставив остальные ключи без изменения:
key -> key.startWith("com.mycompany")
    ? ((oldValue, newValue) -> newValue)
    : ((oldValue, newValue) -> oldValue)

// Для изменения поведения по умолчанию можно использовать следующие подходы:
// 1. Изменение менеджера протоколирования:
System.setProperty("java.util.logging.manager", "com.example.MyLogManager");

// 2. Изменение настроек без изменения менеджера протоколирования:
System.setProperty("java.util.logging.config.class", "com.example.MyLoggingConfigurator");

// затем в классе MyLoggingConfigurator:

package com.example;

import java.util.logging.Level;
import java.util.logging.Logger;

public class MyLoggingConfigurator {
    public static void configure() {
        // Настройки протоколирования
        Logger logger = Logger.getLogger("");
        logger.setLevel(Level.FINE);
    }
}


// page 373
// 7.5.4 Локализация
// Подробнее (7 глава 2 том)
// В состав прикладной программы может входить несколько комплектов ресурсов,
// например:
// один   - для меню,
// другой - для протокольных сообщений.
// У каждого комплекта ресурсов имеется свое имя (например, "com.mycompany.logmessages").
// Для того чтобы ввести сопоставление в комплект ресурсов,
// следует предоставить файл для региональных настроек на соответствующем языке.

// Сопоставления сообщений на английском языке находятся в файле:
//      com/mycompany/logmessages_en.properties
// Сопоставления сообщений на немецком языке - в файле:
//      com/mycompany/logmessages_de.properties
// Здесь пары символов en и de обозначают стандартные коды языков.

// Объединение файлов осущесrвляется с помощью классов прикладной программы.
// В частности, класс обнаруживает их автоматически:
class ResourceBundle

// Содержимое этих файлов состоит из записей простым текстом:
readingFile=Achtung! Datei wird eingelesen      // Прочтение файла
renamingFile=Datei wird umbenannt               // Переименовывание файла
...

// При вызове регистратора сначала указывается конкретный комплект ресурсов:
Logger logger = Logger.getLogger(loggerName, "com.mycompany.logmessages");

// для составления протокольного сообщения указывается ключ из комплекта ресурсов,
// но не строка самого сообщения:
logger.info("readingFile");

// Включать какие-нибудь арrументы в локализованные сообщения.
// Тогда сообщение должно иметь заполнители {О}, {1} и т.д.
// Пример:
Reading file {0}.
Achtung! Datei {О} wird eingelesen.

// Заполнители заменяются соответствующими значениями при вызове одного из следующих методов:
logger.log(Level.INFO, "readingFile", fileName);
logger.log(Level.INFO, "readingFile", new Object[] {oldName, newName});

// Начиная с java 9, в методе logrb() можно указать объект комплекта ресурсов, а не его имя:
logger.logrb(Level.INFO, bundle, "renamingFile", oldName, newName);

// page 374
// 7.5.5 Обработчики протоколов (Handlers)
// По умолчанию логгеры посылают протокольные записи объекту класса ConsoleHandler,
// который выводит их в поток сообщений об ошибках System.err.

// Также как и регистраторы (логгеры) у обработчиков логов имеются свои уровни.
// Уровень протоколирования записи должен превышать порог как для:
// - регистратора (логгера)
// - обработчика

// Уровень консольного обработчика по умолчанию задается в файле,
// содержащем параметры настройки диспетчера протоколирования:
java.util.logging.ConsoleHandler.level=INFO

// Для регистрации записи, имеющей уровень FINE, в конфиrурационном файле
// следует изменить исходный уровень протоколирования для:
// - регистратора
// - обработчика

// С другой стороны, можно вообще пренебречь файлом конфиrурации
// и установить свой собственный обработчик протоколов:
    Logger logger = Logger.getLogger("com.mycompany.myapp");
    logger.setLevel(Level.FINE);
    logger.setUseParentHandlers(false); // чтобы все протокольные записи не выводили дважды
    var handler = new ConsoleHandler();
    handler = setLevel(Level.FINE);
    logger.addHandler(handler);

// В прикладном интерфейсе API для протоколирования предоставляются два класса обработчиков протоколов (логов):
// 1. SocketHandler   - посылает протокольные записи на указанный хост и в порт
// 2. FileHandler - выводит протокольные записи в файл

// Логи передаются в FileHandler (обработчик по умолчанию) для записи в файл
    var handler = new FileHandler();
    logger.addHandler(handler);
// Протокольные записи выводятся в файл jаvаn.log, который находится в начальном каталоге пользователя,
// где n - однозначный номер, отличающий этот файл от других аналогичных файлов.
// По умолчанию протокольные записи хранятся в формате XML.
// Обычная протокольная запись:
<record>
    <date>2002-02-04T07:45:15</date>                // дата в формате ISO 8601 (год-месяц-деньTчас:минута:секунда)
    <millis>1012837515710</millis>                  // время (с 01.01.1970)
    <sequence>1</sequence>                          // порядковый номер события в пределах потока
    <logger>com.mycompany.myapp</logger>            // имя логгера, который сгенерировал данное сообщение
    <level>INFO</level>                             // уровень логирования сообщения (например, INFO, WARNING, ERROR)
    <class>com.mycompany.mylib.Reader</class>       // имя класса, из которого была сделано запись в журнал
    <method>read</method>                           // имя метода, который сделал запись в журнал
    <thread>10</thread>                             // имя потока, в котором произошло событие протоколирования
    <message>Reading file corejava.gif</message>    // текст сообщения, которое было зарегистрировано
</record>

// Поведение исходного обработчика протоколов типа FileHandler можно изменить:
// 1. задав другие параметры настройки в диспетчере протоколирования (табл. 7.1)
// 2. воспользоваться другим конструктором
// Обычно, имя файла протокола, предлагаемое по умолчанию, не используется.
// -> Для него нужно задать другой шаблон, например %h/myapp.log (переменные шаблона описаны в табл. 7.2).

// Таблица 7.1. Параметры настройки обработчика протоколов типа FileHandler
|-----------------------------------------|--------------------------------------|----------------------------------|
|         Настраиваемое свойство          |               Описание               |       Значение по умолчанию      |
|-----------------------------------------|--------------------------------------|----------------------------------|
| java.util.logginq.FileHandler.level     | Уровень обработчика                  | Level.ALL                        |
|-----------------------------------------|--------------------------------------|----------------------------------|
| java.util.logginq.FileHandler.append    | Определяет, должен ли обработчик     | false                            |
|                                         | добавлять записи в существующий файл |                                  |
|                                         | или же открывать новый файл при      |                                  |
|                                         | очередном запуске программы          |                                  |
|-----------------------------------------|--------------------------------------|----------------------------------|
| java.util.logginq.FileHandler.limit     | Приблизительная оценка максимального | 0(т.е. без ограничений) в классе |
|                                         | размера файла. При превышении этого  | FileHandler; 50000 в исходной    |
|                                         | размера открывается новый файл       | конфигурации диспетчера          |
|                                         | (0 - размер файла не ограничен)      | протоколирования                 |
|-----------------------------------------|--------------------------------------|----------------------------------|
| java.util.logging.FileHandler.pattern   | Шаблон имени файла nротокола         | %h/java%u.log                    |
|                                         | (см.табл. 7.2)                       |                                  |
|-----------------------------------------|--------------------------------------|----------------------------------|
| java.util.logging.FileHandler.count     | Количество файлов nротокола,         | 1 (ротация не nроизводится)      |
|                                         | участвующих в ротации                |                                  |
|---------------------------------------- |--------------------------------------|----------------------------------|
| java.util.logging.FileHandler.filter    | Класс, исnользуемый для фильтрации   | Фильтрация отсутствует           |
|-----------------------------------------|--------------------------------------|----------------------------------|
| java.util.logging.FileHandler.encoding  | Применяемая кодировка                | Кодировка, nринятая на текущей   |
|                                         |                                      | nлатформе                        |
|-----------------------------------------|--------------------------------------|----------------------------------|
| java.util.logging.FileHandler.formatter | Средство форматирования nротокольных | java.util.logging.XМLFormatter   |
|                                         | записей                              |                                  |
|-----------------------------------------|--------------------------------------|----------------------------------|

// Таблица 7.2. Переменные шаблона для имени файла протокола
|--------------|------------------------------------------------------------------------------------|
|  Переменная  |                                      Описание                                      |
|--------------|------------------------------------------------------------------------------------|
|      %h      | Значение системного свойства user.home                                             |
|      %t      | Временный системный каталог                                                        |
|      %u      | Однозначный номер, nозволяющий избежать конфликта имен                             |
|      %g      | Определяет режим формирования номеров для nодвергаемых ротации файлов nротоколов.  |
|              | (Если ротация nроизводится, а в шаблоне отсутствует nеременная %g, то исnользуется |
|              | суффикс .%g)                                                                       |
|      %%      | Знак % (процента)                                                                  |
|--------------|------------------------------------------------------------------------------------|

// Если в нескольких приложениях (или нескольких копиях одноrо и тоrо же приложения)
// используется тот же самый файл протокола, следует:
// 1. установить признак append - определяет режим ввода данных в конце файла
// 2. использовать шаблоном имени файла %u
//    -> чтобы каждое приложение создавало свою особую копию файла протокола.
// 3. установить режим ротации файлов протоколов.
//    -> имена файлов протоколов будут формироваться следующим образом:
//       myapp.log.0, myapp.log.1, myapp.log. 2 и т.д.
//       Как только размер файла превысит допустимый предел, самый старый файл протокола удаляется,
//       остальные переименовываются, а новый файл получает имя с номером 0.
// 4. определить свои собственные обработчики протоколов, расширив класс Handler или StreamHandler.
//    Данный обработчик протоколов расширяет класс StreanHandler и устанавливает
//    поток вывода с методами write() для отображения в текстовой области данных, выводимых в этот поток:

class WindowHandler extends StreamHandler {
    public WindowHandler() {
        ...
        var output = new JTextArea();
        setOutputStream (new OutputStream () {
            public void write(int b) {} // not called
            public void write(byte[] b, int off, int len) {
                output.append(new String(b, off, len));
            }
        });
    }
    ...
}
// Затруднение:
// Обработчик размещает протокольные записи в буфере
// и направляет их в поток вывода только тогда, когда буфер заполнен.

// Решение -> Необходимо переопределить метод publish(),
//    чтобы выводить содержимое буфера после каждой протокольной записи.
class WindowHandler extends StreamHandler {
    ...
    public void publish(LogRecord record) {
        super.publish(record);
        flush();
    }
}
// Можно также расширить класс Handler и определить методы:
// - publish()
// - flush()
// - close()

// page 378
// 7.5.6 Фильтры

// По умолчанию записи фильтруются в соответствии с уровнями протоколирования.
// У каждого регистратора и обработчика протоколов может быть свой фильтр,
// выполняющий дополнительную фильтрацию.

// Для этого достаточно реализовать интерфейс Filter и определить следующий метод:
boolean isLoggable (LogRecord record)

// Для анализа протокольных записей можно выбрать любой критерий,
// а метод должен возвращать логическое значение true для тех протокольных записей,
// которые нужно ввести в файл протокола.

// -> фильтр может пропускать только протокольные записи,
// созданные в начале выполнения метода и при возврате из него.
// Фильтр должен вызвать метод:
    record.getMessage()
// и проверить, начинается ли запись со строки ENTRY или RETURN.
// Чтобы задать фильтр в регистраторе или обработчике протоколов,
// следует вызвать метод:
    setFilter().
// Но фильтры можно применять только по очереди.

// page 378
// 7.5.7 Средства форматирования (Formatters)

// Классы ConsoleHandler и FileHandler порождают протокольные записи в:
// - текстовом виде
// - формате XML
// Можно определить свой собственный формат:
// ->
// 1. расширить класс Formatter
// 2. переопределить метод String format(LogRecord record) ->
    String formatMessage(LogRecord record)

// Во многих форматах файлов (например в XML), предполагается:
// 1. начальная часть файла
// 2. конечная часть файла
// в которых хранится отформатированные протокольные записи.
// -> нужно переопределить методы:
    String getHead (Handler h)
    String getTail (Handler h)

// далее вызывается метод:
    setFormatter() // устанавливает средства форматирования в обработчике протоколов.

// page 378
// 7.5.8 "Рецепт" протоколирования (логирования)
// 1. Для простых приложений - выбирать один регистратор.
//    Рекомендуется, чтобы имя регистратора совпадало с именем основного пакета приложения.
//    Пример названий пакетов: com.mycompany.myprog
//    Создаем регистратор:
      Logger logger = Logger.getLogger("com.mycompany.myprog");

// 2. Для удобства в те классы, где интенсивно используется протоколирование
//    можно добавить статические поля.
      private static final Logger logger = Logger.getLogger("com.mycompany.myprog");

// 3. По умолчанию все сообщения, имеющие уровень INFO и выше, выводятся на консоль.
//    Пользователи могут изменить конфиrурацию, предусмотренную по умолчанию,
//    но, это довольно сложный процесс.
//    Лучше задать более оправданные настройки прикладной проrраммы по умолчанию.
//    Сделать чтобы все сообщения были зареrистрированы в файле протокола,
//    связанном с конкретным приложением.
      if (System.getProperty("java.util.logging.config.class") == null)
          && System.getProperty("java.util.logging.config.file") == null) {
          try {
            Logger.getLogger("").setLevel(Level.ALL);
            final int LOG_RATATION_COUNT = 10;
            var handler = new FileHandler("%h/myapp.log", 0, LOG_RATATION_COUNT);
            Logger.getLogger("").addHandler(handler);
          } catch (IOException e) {
            Logger.log(Level.SEVERE, "Не могу создать файл журнала обработчика", e);
          }
      }

// 4. Все rотово для протоколирования. Все сообщения, имеющие уровень протоколирования:
//    - INFO
//    - WARNING
//    - SEVERE
//    выводятся на консоль -> эти уровни протоколирования нужно зарезервировать для сообщений,
//    представляющих ценность для пользователей вашей проrраммы.
//    Уровень FINE лучше выделить для сообщений, предназначенных для программистов.
//    В тех местах кода, где обычно вызывается метод System.out.println(),
//    регистрируйте сообщения следующим образом:
      logger.fine("Файл открытый диалог отменен");

// 5. Рекомендуется также реrистрировать неожиданные исключения:
      try {
        ...
      } catch (SomeException e) {
        logger.log(Level.FINE, "пояснения...", e);
      }

// программа из листинга 7.2 работает, но в модульном проекте ее нужно правельно настроить
// GOTO разобраться с этим

// D:\filesEvgeniy\projects\mycoding\java\learnbooks\hortsmann_v_one\hortsmann_v_one.iml
// <?xml version="1.0" encoding="UTF-8"?>
// <module version="4">
//   <component name="AdditionalModuleElements">
//     <content url="file://$MODULE_DIR$/../hortsmann_v_one" dumb="true">
//       <sourceFolder url="file://$MODULE_DIR$/../hortsmann_v_one/src/main/resources" type="java-resource" />
//     </content>
//   </component>
// </module>


// page 387
// 7.6 Рекомендации по отладке программ

// 1. Значение любой переменной можно вывести с помощью выражения
System.out.println("x = " + x);
// или
Logger.getGlobal().info("x = " + x);
Logger.getGlobal().info("this = " + this);

// 2. Включить в каждый класс отдельный метод main() и разместить в нем код,
//    позволяющий протестировать этот класс отдельно от других
public class MyClass {
    // методы и поля данного класса
    ...
    public static void main (String[] args){
        // тестовый код
    }
}
//    Создайте несколько объектов, вызовите все методы и проверьте, правильно ли они действуют.
//    Все это делается в теле методов main(), а интерпретатор вызывается для каждого файла класса по отдельности.
//    Если выполняется аплет, то ни один из этих методов main() вообще не будет вызван.
//    А если выполняется приложение, то интерпретатор вызовет только метод main() из запускающего класса.

// 3. Поработайте в среде JUnit, которая доступна по адресу http://junit.org.
//    JUnit представляет собой широко распространенную среду модульного тестирования,
//    которая существенно упрощает работу по созданию наборов тестов и контрольных примеров.
//    Запускайте тесты после каждого видоизменения класса.
//    При обнаружении программных ошибок добавляйте новый контрольный пример для последующего тестирования.

// 4. Протоколирующий прокси-объект представляет собой экземпляр подкласса,
//    который перехватывает вызовы методов, протоколирует их и обращается к суперклассу.
//    Так, если возникнут трудности при вызове метода nextDouble() из класса Random,
//    можно создать прокси-объект в виде экземпляра анонимного подкласса:
var generator = new Random() {
    public double nextDouble() {
        double result = super.nextDouble();
        Logger getGlobal().info("nextDouble: " + result);
        return result;
    }
};
//    При каждом вызове метода nextDouble() будет формироваться протокольное сообщение.

//    Ниже поясняется, как выявить ту часть кода, из которой вызывается данный метод,
//    и как произвести трассировку стека.

// 5. Вызвав метод printStackTrace() из класса Throwable,
//    можно получить трассировку стека из любого объекта исключения.
//    В примере, перехватывается любое исключение, выводится объект исключения и трассировка стека,
//    а затем повторно генерируется исключение, чтобы найти предназначенный для него обработчик.
try {
    ...
} catch (Throwable t) {
    t.printStackTrack();
    throw t;
}
//    Для трассировки стека не нужно даже перехватывать исключение.
//    Просто введите следующую строку в любом месте кода:
Thread.dumpStack();

// 6. Результаты трассировки стека выводятся в поток сообщений об ошибках System.err.
//    Если же требуется протоколировать или отобразить результаты трассировки стека,
//    то можно заключить их в символьную строку.
var out = new ByteArrayOutputStream();
new Throwable().printStackTrace(out);
String description = out.toString();

var out = new StringWriter();
new Throwable().printStackTrace(new PrintWriter(out));
String description = out.toString();

// 7. Ошибки, возникающие при выполнении программы, удобно записывать в файл.
//    Но обычно ошибки посылаются в поток сообщений об ошибках System.err,
//    а не в поток вывода System.out.
command: java МyProgram > errors.txt     // Так вывести ошибки в файл по обычной команде нельзя.
//    лучше записать это так:
command: java MyProgram 2> errors.txt

//    для того чтобы направить потоки Stream.err и Stream.out в один и тот же файл,
//    воспользуйтесь командой
command: java МyProgram 1> errors.txt 2>&1

command: java MyProgram > errors.txt:
// Эта команда перенаправляет только стандартный вывод (stdout) программы в файл errors.txt.
// Ошибки, которые попадают в поток ошибок (stderr), все еще выводятся на экран.

command: java MyProgram 2> errors.txt:
// Эта команда перенаправляет только поток ошибок (stderr) программы в файл errors.txt.
// Стандартный вывод (stdout) все еще выводится на экран.

command: java MyProgram 1> errors.txt 2>&1:
// В этой команде используется дополнительное средство, называемое перенаправлением дескриптора файлов.
// 1> перенаправляет стандартный вывод (stdout) в файл errors.txt,
// 2>&1 перенаправляет поток ошибок (stderr) в тот же самый файл, что и стандартный вывод.
// Как стандартный вывод, так и поток ошибок будут записаны в файл errors.txt.

// Основное отличие между этими 3мя командами заключается в том,
// какие потоки данных (stdout и stderr) перенаправляются,
// и перенаправляются ли они в один и тот же файл или в разные.

// Здесь цифры, используемые в командах перенаправления потоков в командной строке,
// представляют собой стандартные дескрипторы файлов для различных потоков данных:
// 0 - стандартный ввод (stdin)
// 1 - стандартный вывод (stdout)
// 2 - поток ошибок (stderr)

// Когда вы видите 1> или 2>, это указывает на то,
// что поток данных (stdout или stderr) будет перенаправлен в файл,
// указанный справа от символа ">".

// Если нет цифры, то это подразумевает стандартный вывод (stdout).
// Например,">" означает перенаправление стандартного вывода.

// Комбинация 2>&1 указывает на то, что поток ошибок (stderr) будет перенаправлен туда,
// куда уже перенаправлен стандартный вывод (stdout).
// То есть, куда бы ни был перенаправлен стандартный вывод (stdout),
// поток ошибок (stderr) будет перенаправлен в тот же самый файл или место.

// 8. Результаты трассировки стека необрабатываемых исключений свидетельствуют о том,
//    что поток сообщений об ошибках System.err далек от идеала.
//    Выводимые в него сообщения смущают конечных пользователей, если им случается их увидеть,
//    и они недоступны для диагностических целей, когда в этом возникает потребность.
//    Поэтому более правильный подход состоит в том, чтобы протоколировать их в файле.
//    Обработчик для необрабатываемых исключений можно заменить статическим методом:
//    Thread.setDefaultUncaughtExceptionHandler().
//    Это будет выглядеть:
Thread.setDefaultUncaughtExceptionHandler(
    new Thread.UncaughtExceptionHandler() {
        public void uncaughtException(Thread t, Throwable e) {
            // сохранить данные в файле протокола.
        };
    }
);

// 9. Чтобы отследить загрузку класса, запустите виртуальную машину Java с параметром
        "-verbose"
//    На экране появятся строки:
//    [0.012s] [info] [class,load] opened: /opt/jdk-9.0.1 /lib/rnodules
//    [0.034s] [info] [class,load] java.lang.Object source: jrt:/java.base
//    [0.035s] [info] [class,load] java.io.Serializable source: jrt:/java.base
//    [0.035s] [info] [class,load] java.lang.Cornparable
//    и т.д.
//    Такой способ может оказаться полезным для диагностики ошибок, связанных с путями к классам.

command: java -verbose YourMainClass
// Где YourMainClass - это основной класс вашего приложения, который вы хотите запустить.

// Эта команда запустит виртуальную машину Java с включенным выводом информации о загрузке классов.
// Вы увидите информацию о каждом загруженном классе в процессе выполнения вашего приложения.

// Если вы используете управляемую среду разработки (IDE),
// вы можете добавить этот параметр в настройки запуска вашего приложения в IDE.

// 10. Параметр -Xlint указывает компилятору выявлять типичные ошибки в исходном коде программы.
//     Если, вызвать компилятор так, как показано ниже,
//     он уведомит о пропущенных операторах break в ветвях оператора switch.

command: javac -Xlint:fallthrough

//     Термин lint применялся ранее для описания инструментального средства,
//     предназначенного для обнаружения потенциальных ошибок в программах, написанных на С.
//     Теперь он обозначает все инструментальные средства, отмечающие языковые конструкции,
//     которые могут оказаться спорными, хотя и допустимыми.

//     Описаны допустимые значения параметра -Xlint.
//     В итоге получаются сообщения, аналогичные следующему:

// warning: [fall through] possible fall-through into case
// предупреждение ["провал"] возможный "провал" в ветви выбора case

//     Символьная строка в квадратных скобках обозначает категорию предупреждения.
//     Вывод каждой категории можно разрешить или запретить.
//     Но поскольку большинство этих категорий весьма полезны для отладки программ,
//     то лучше оставить их на месте, запретив лишь те из них,
//     которые не представляют интерес, как показано ниже.
command: javac -Xlint:all,-fallthrough,-serial sourceFiles

// Список предупреждений можно получить по следующей команде:
command: javac --help -Х

// 11. В виртуальной машине Java реализована поддержка контроля и управления приложениями написанными на Java.
//     Это позволяет установить в ней агенты, которые будут отслеживать расходование памяти,
//     использование потоков исполнения, загрузку классов и т.п.
//     Такая поддержка важна для работы с крупномасштабными прикладными программами,
//     работающими в течение длительного времени, например, с серверами приложений.

//     Для демонстрации новых возможностей в комплект поставки JDK включена графическая утилита jconsole,
//     которая отображает статистические данные о производительности виртуальной машины (рис.7.3).
//     Запустите на выполнение сначала свою программу, а затем утилиту jconsole
//     Далее выберите свою программу из списка выполняющихся программ на Java.
//     На консоль будет выведено немало полезных сведений о вашей программе.

//     Подробнее об этом по адресу www.oracle.com/technetwork/articles/java/jconsole-1564139.html.

// 12. В комплект Oracle JDK входит инструментальное средство Java Mission Control (JMC),
//     предназначенное для профилирования и диагностики прикладных проrрамм на профессиональном уровне.
//     Им можно свободно пользоваться на стадии разработки приложений,
//     тогда как на стадии их эксплуатации потребуется коммерческая лицензия на данное средство.
//     Со временем eгo версия с открытым исходным кодом будет доступна как составная часть комплекта OpenJDК.
//     Подобно утилите jconsole, инструментальное средство Java Mission Control
//     можно присоединить к действующей виртуальной машине.
//     Оно способно также анализировать результаты, выводимые инструментальным средством Java Flight Recorder,
//     собирающим данные, касающиеся диагностики и профилирования выполняющегося приложения на Java.

//     Подробнее об этих инструментальных средствах по адресу https://docs.oracle.com/javacomponents/index.html.


// page 393
// 8 глава: Обобщенное программирование

// - Назначение обобщенного программирования
// - Определение простого обобщенного класса
// - Обобщенные методы
// - Ограничения на переменные типа
// - Обобщенный код и виртуальная машина
// - Ограничения и пределы обобщений
// - Правила наследования обобщенных типов
// - Подстановочные типы
// - Рефлексия и обобщения


// page 394
// 8.1 Назначение обобщенного программирования
// Обобщенное программирование - написание кода, который может быть неоднократно применен к разнотипным объектам.

// page 394
// 8.1.1 Преимущества параметров типа
// До внедрения обобщенных классов -> обобщение шло через наследование.

// Раньше:
public class ArrayList {
    private Object[] elementData;
    ...
    public Object get(int i) { ... }
    public void add(Object o) { ... }
}
// -> плохо, т.к. постоянно при извлечении нужно делать привидение типов:
ArrayList files = new ArrayList();
...
String filename = (String) files.get();
// + отсутствует проверка на ошибки.
files.add(new File("..."));
// -> это скомпелируется, но приведет к ошибке после попытки
// при попытке метода get() привести результат к типу String

// Сейчас: ("Ромбовидный синтаксис")
var files = new ArrayList<String>();
// или
ArrayList<String> files = new ArrayList<>();

// Допустимый ромбовидный синтаксис в Java 9:
ArrayList<String> passwords = new ArrayList<>() {
    public String get(int n) {
        return super.get(n).replaceAll(".", "*");
    }
};

// -> в коллекции типа ArrayList<String> можно вводить только объекты типа String
files.add(new File("...")); // выдаст ошибку

// Ошибка компиляции - это намного лучше, чем исключение в связи с
// неправильным приведением типов во время выполнения.
// Привлекательность параметров типа в том и состоит,
// что они делают исходный код программы более удобочитаемым и безопасным.

// page 395
// 8.1.2 На кого рассчитано обобщенное программирование

// класс ArrayList метод addAll()
// Задача: добавить все элементы ArrayList<Manager> -> ArrayList<Employee>
//         ArrayList<Employee> -X> ArrayList<Manager>
// Решение: Подстановочный тип

// Обобщенное программирование делится на 3 уровня:
// 1. Элементарный - простое использование обобщенных классов
// 2.
// 3.


// page 396
// 8.2 Определение простого обобщенного класса

// Обобщенный класс - класс, с одной или несколькими переменными типа.
// Рассмотрим простой обобщенный класс Pair в качестве примера.

public class Pair<T> {
    private T first;
    private T second;

    public Pair() {
       first = null;
       second = null;
    }

    public Pair(T first, T second) {
       this.first = first;
       this.second = second;
    }

    public T getFirst() {
       return first;
    }

    public T getSecond() {
       return second;
    }

    public void setFirst(T newValue) {
        first = newValue;
    }

    public void setSecond (T newValue) {
        second = newValue;
    }
}

// В классе Pair вводится переменная типа Т,
// заключенная в угловые скобки (<>) после имени самого класса.
// У обобщенного класса может быть больше одной переменной типа.
// Например, класс Pair можно было бы определить с разными типами
// для первого и второго поля следующим образом:
public class Pair<T, U> { ... }
// Переменные типа используются повсюду в определении класса:
// - для обозначения типов
// - возвращаемых методами
// - типов полей
// - локальных переменных.
// Пример объявления переменной типа.
private Т first;    //используем переменную типа

// В именах переменных типа принято употреблять прописные буквы и стремиться к их краткости.
// В стандартной библиотеке Java буквами:
//  Е - обозначается тип элемента коллекции,
//  K - обозначается тип ключей в таблице
//  V - обозначается тип значений в таблице
//  T и S, U (при необходимости) - "любой тип вообще"

// Экземпляр обобщенного типа получается путем подстановки имени типа вместо переменной типа:
Pair<String>
// Результат такой подстановки следует рассматривать как обычный класс с конструкторами:
Pair<String>()
Pair<String>(String, String)

// и методами:
String getFirst()
String getSecond()
void setFirst(String)
void setSecond(String)

// Обобщенный класс действует как фабрика обычных классов.

// page 398
// 8.3 Обобщенные методы

// Помимо обобщенного класса можно обпределить обобщенный метод, с параметрами или переменными типа
// в т.ч. в не обобщенном классе

class ArrayArg {
    public static <T> T getMiddle (T... a) {    // пример обобщенного метода
        return a[a.length / 2];
    }
}
// -> на что указывали угловые скобки и переменная типа
// Переменная типа вводится после модификаторов доступа (public static) и перед возвращаемым типом "T".

// "<T>" - обобщенный тип (переменная типа). Используется для создания обобщенных методов или классов.
// "T"   - параметр типа. Используется в контексте объявления типа параметра.

// T (параметр типа) <T> указывает, что метод или класс является обобщенным и может работать с данными любого типа.
// Когда метод или класс обобщенный, T обычно используется в качестве обозначения для параметра типа,
// который будет заменен конкретным типом данных при использовании обобщенного метода или класса.

// Когда вызывается обобщенный метод, ему можно передать конкретные типы данных,
// заключая их в угловые скобки перед именем метода:
String middle = ArrayArg.<String>getMiddle ("John", "Q.", "Public");
-> // Равнозначно
String middle = ArrayArg.getMiddle("John", "Q.", "Public");

// При вызове метода можно пропустить параметр типа String.
// У компилятора имеется достаточно информации, чтобы вывести из такого обобщения именно тот метод,
// который требуется вызвать.
// Он сопоставляет тип аргументов с обобщенным типом Т ... и приходит к выводу,
// что вместо обобщенного типа <T>, следует подставить конкретный тип String.

// Обычно все ОК, но иногда возникают проблемы:
double middle = ArrayArg.getMiddle(3.14, 1723, 0);
// -> При выполнении этой строки кода компилятор выведет сообщение об ошибке загадочного содержания,
// но суть его в том, что данный код можно интерпретировать двояко и в обоих случаях - правильно.

// Компилятор выполняет:
// 1. автоупаковку параметра в один объект типа Double и два объекта типа Integer,
// 2. пытается найти для них общий супертип.
//    И таких супретипов два:
//        - класс Number
//        - интерфейс Comparable, который сам является обобщенным.
//    В этом случае для устранения ошибки методу следует передать все параметры со значениями типа double.

// Прием от: Петер Ван Дер Ахе (Реtег von dег Ahe)
// Если требуется выяснить, какой тип компилятор выводит при вызове обобщенного метода:
// намеренно допустить ошибку и изучить полученное в итоге сообщение об ошибке.

// Пример:
ArrayAlg.getМiddle("Hello", 0, null).
// Если присвоить полученный результат переменной ссылки на объект типа JВutton, что заведомо неверно,
// то в конечном итоге будет получено следующее сообщение об ошибке:

found:
java.lang.Object&java.io.Serializable&java.lang.Comparable<? extends
    java.lang.Object&java.io.Serializable&java.lang.Comparable<?>>

// -> Результат вызова данного метода можно присвоить переменным ссылки на объекты типа:
Object, Serializable или Comparable.

// page 399
// 8.4 Ограничения на переменные типа

// Иногда класс или метод нуждается в наложении ограничений на переменные типа.

// Пример, в котором требуется вычислить наименьший элемент массива:
class ArrayArg {
    public static <T> T min(T[] a) {    // почти верно
        if (a == null || a.length == 0) {
            return null;
        }
        T smallest = a[0];
        for (int i = 1; i < a.length; i++){
            if (smallest.compareTo(a[i]) > 0){
                smallest = a[i];
            }
        }
        return smallest;
    }
}

// Здесь возникает затруднение. Обратите внимание на тело метода min().
// Переменная smallest относится к типу Т, а это означает, что она может быть объектом произвольною класса.
// Но откуда известно, имеется ли метод compareTo() в том классе, к которому относится тип Т?

// Выход ->
// Наложить ограничение на тип Т и вместо него подставлять только класс, реализующий Comparable
// - стандартный интерфейс с единственным методом compareTo().
// Для этого достаточно наложить ограничение на переменную типа T.

public static <T extends Comparable> T min (T[] a) {
    ...
}

// Как правильно пользоваться параметрами типа вместе с интерфейсом Comparable (раздел 8.8).

// Теперь обобщенный метод min() может вызываться только с массивами классов,
// реализующих интерфейс Comparable, в том числе String, Date и т.п.

// А вызов min() с массивом типа Rectangle приведет к ошибке во время компиляции,
// поскольку класс Rectangle не реализует интерфейс Comparable.

// ключевое слово extends вместо implements, ведь Comparable - это интерфейс?
// Так, следующее обозначение:
    <Т extends оrраничивающий_тип>

// означает, что тип Т должен быть подтипом ограничивающею типа,
// причем к типу T и ограничивающему типу может относиться как интерфейс, так и класс.
// Ключевое слово extends выбрано потому, что это вполне благоразумное приближение понятия подтипа,
// и создатели Java не сочли нужным вместо этого вводить в язык новое ключевое слово.

// Переменная типа или подстановка может иметь несколько ограничений.
// Ограничивающие типы разделяются знаком "&",
// т.к. "запятые" служат для разделения переменных типа.
// ->
    Т extends Comparable & Serializable

// Как и в механизме наследования в Java, у интерфейсов может быть сколько угодно супертипов,
// но только один из ограничивающих типов может быть классом.

// Если для ограничения служит класс,
// он должен быть 1м в списке накладываемых ограничений.

// page 402
// 8.5 Обобщенный код и виртуальная машина.

// Виртуальная машина не оперирует объектами обобщенных типов
// Все объекты принадлежат обычным классам.

// В ранних вариантах реализации обобщений можно было компилировать программу с обобщениями в файлы классов,
// которые способна исполнять виртуальная машина версии 1.0!
// Далее:
// 1. каким образом компилятор "стирает" параметры типа
// 2. последствия этого процесса для программирующих на Java.

// Как компилятор "стирает" параметры типа:
// В Java обобщения (Generics) являются частью системы типов на уровне компиляции.
//Обобщенный код существует только на этапе компиляции и стирается (erased) при компиляции в байт-код.
// Компилятор удаляет параметры типа и заменяет их на типы-ограничители (если они заданы) или на Object,
// если ограничители не указаны.
// Этот процесс известен как "стирание типов" (type erasure).

// Например:
java
Copy code
public class Box<T> {
    private T value;

    public void setValue(T value) {
        this.value = value;
    }

    public T getValue() {
        return value;
    }
}
// После компиляции этот класс превращается в необобщенную версию,
// где все вхождения типа T заменяются на Object.
// ->
public class Box {
    private Object value;

    public void setValue(Object value) {
        this.value = value;
    }

    public Object getValue() {
        return value;
    }
}

// Последствия стирания типов для программистов на Java:
// Потеря типовой безопасности:
// После стирания типов в обобщенном коде теряется информация о типах, используемых в программе.
// Это может привести к потере типовой безопасности и возникновению ошибок
// времени выполнения из-за неправильного использования типов.

// Ограниченные возможности рефлексии:
// После стирания типов нельзя получить доступ к параметрам типа во время выполнения (runtime),
// что ограничивает возможности рефлексии в обобщенном коде.

// Накладные расходы на приведение типов:
// Поскольку все параметры типов стираются до Object,
// в обобщенном коде могут возникнуть дополнительные накладные расходы
// на приведение типов при извлечении объектов из контейнеров.

// Пример:
// 1. как обобщения компилируются в байт-код
// 2. как происходит стирание типов
// 3.пример ошибки времени выполнения при неправильном использовании

import java.util.*;

public class Main {
    public static void main(String[] args) {
        // Создание списка строк
        List<String> stringList = new ArrayList<>();
        stringList.add("Пример");
        stringList.add("текста");

        // В обобщенном коде компилятор работает с типом "List", не зная о параметрах типа "String"
        List list = stringList;

        // Это приведет к ClassCastException во время выполнения
        // Поскольку параметр типа "String" стерся и элементы списка стали типа "Object"
        // String str = list.get(0); // Ошибка времени выполнения

        // Поэтому при обращении к элементам списка придется явно выполнять приведение типов
        String str = (String) list.get(0);
        System.out.println(str); // Вывод: Пример
    }
}

// page 402
// 8.5.1 Стирание типов (подробнее)

// Всякий раз, когда определяется обобщенный тип,
// автоматически создается соответствующий ему базовый ("сырой") тип.
// Имя этого типа совпадает с именем обобщенного типа с удаленными параметрами типа.
// Переменные типа стираются и заменяются ограничивающими типами
// (или типом Object, если переменная не имеет ограничений).

// К примеру базовый тип для обобщенного типа Pair<T> выглядит следующим образом:
public class Pair {
    private Object first;
    private Object second;

    public Pair(Object first, Object second) {
        this.first = first;
        this.second = second;
    }

    public Object getFirst() {return first;}
    public Object getSecond() {return second;}

    public void setFirst (Object newValue) {
        first = newValue;
    }
    public void setSecond (Object newValue) {
        second = newValue;
    }
}

// Если Т - неограниченная переменная типа, то ее тип просто заменяется на Object.
// В итоге получается обычный класс вроде тех, что реализовывались до появления обобщений в Java.

// Прикладные программы могут содержать разные варианты обобщенного класса Pair,
// в том числе Pair<String> или Pair<GregorianCalendar>,
// но в результате стирания все они приводятся к базовым типам Pair.

// Базовый тип заменяет тип переменных первым накладываемым на них ограничением или же типом Object,
// если никаких ограничений не предусмотрено.

// Например, у переменной типа в обобщенном классе Pair<T> отсутствуют явные ограничения,
// поэтому базовый тип заменяет обобщенный тип Т на Object.

// Допустим, что объявлен несколько иной обобщенный тип:

public class Interval<T extends Comparable & Serializable> implements Serializable {
    private T lower;
    private T upper;
    ...
    public Interval (T first, T second) {
        if (first.compareTo (second) <= 0) {
            lower = first;
            upper = second;
        } else {
            lower = second;
            upper = first;
        }
    }
}

public class Interval implements Serializable {
    private Comparable lower;
    private Comparable upper;
    ...
    public Interval (Comparable first, Comparable second) {
        ...
    }
}
// А если поменять местами ограничения class Interval<Serializable & Comparable>:

// базовый тип заменит обобщенный тип T на Serializable, а компилятор произведет там,
// где требуется, приведение к типу Comparable.
// Поэтому ради эффективности в конце списка ограничений следует размещать отмечающие (маркерные) интерфейсы
// (т.е. интерфейсы без методов).

// page 403
// 8.5.2 Преобразование обобщенных выражений

// Когда в программе вызывается обобщенный метод,
// компилятор вводит операции приведения типов при стирании возвращаемого типа.
    Pair<Employee> buddies = ...;
    Employee buddy = buddies.getFirst();

// В результате стирания из метода getFirst() возвращается тип Object.
// Поэтому компилятор автоматически вводит приведение к типу Employee.
// -> компилятор преобразует вызов данного метода в следующие две команды для виртуальной машины:
//    • вызвать метод базового типа Pair.getFirst();
//    • привести тип Object возвращаемого объекта к типу Employee.

// Операции приведения типов вводятся также при обращении к обобщенному полю.
// Допустим, что поля first и second открытые, т.е. объявлены как public
// (не самый лучший, но допустимый стиль программирования в Java).
// Тогда при преобразовании приведенного выше выражения в получаемый в конечном итоге байт-код
// также будут введены операции приведения типов.
        Employee buddy = buddies.first;


// page 404
// 8.5.3 Преобразование обобщенных методов

// Стирание типов происходит и в обобщенных методах.
// Пример:
public static <Т extends Comparable> Т min(T(] а)

// Но после стирания типов остается только один приведенный ниже метод,
// где параметр обобщенного типа Т стирается, а остается только ограничивающий тип Comparable:
public static Comparable min(Comparable[] а)

// Стирание типов в обобщенных методах приводит к некоторым осложнениям:
class DateInterval extends Pair<> {
    public void setSecond(LocalDate second) {
        if (second.compareTo(getFirst()) >= 0) super.setSecond(second)
    }
    ...
}

// В этом фрагменте кода интервал дат задается парой объектов типа LocalDate,
// поэтому соответствующие методы требуется переопределить,
// чтобы второе сравниваемое значение не было меньше первого.

// В результате стирания ->:
class DateInterval extends Pair {   // после стирания параметров типа
    public void setSecond(LocalDate second) { ... }
    ...
}

// но имеется и другой метод setSecond(),унаследованный от класса Pair:
public void setSecond(Object second)
// это совершенно другой метод, т.к. он имеет параметр другого типа:
// Object вместо LocalDate, но он не должен быть другим.

DateInterval interval = new DateInterval(...);
Pair<LocalDate> pair = interval;    // допускается присвоение суперклассу
pair.setSecond(aDate);

// Предполагается, что вызов метода setSecond() является полиморфным,
// и поэтому вызывается соответствующий метод.
// А поскольку переменная раir ссылается на объект типа Dateinterval,
// это должен быть вызов Dateinterval.setSecond().
//Но стирание типов мешает соблюдению принципа полиморфизма.
// В качестве выхода из этого затруднительного положения компилятор
// формирует следующий мостовой метод в классе Dateinterval:

public void setSecond(Object second) {
    setSecond((LocalDate) second);
}

// проанализируем выполнение другого оператора:
pair.setSecond(aDate);

// В объявлении переменной pair указан тип Pair<LocalDate>,
// к которому относится только один метод под именем setSecond() -> setSecond (Object).
// Виртуальная машина вызывает этот метод для того объекта, на который ссылается переменная pair.
// Этот объект относится к типу Dateinterval, и поэтому вызывается метод Dateinterval.setSecond(Object).
// Именно он и является синтезированным мостовым методом.
// Он в свою очередь вызывает метод Dateinterval.setSecond (LocalDate), что и требуется.

// Мостовые методы могут быть еще более необычными.
// Допустим, в классе Dateinterval переопределяется также метод getSecond():

class DateInterval extends Pair<LocalDate> {
    public LocalDate getSecond() {
        return (LocalDate) super.getSecond().clone();
    }
    ...
}
// В классе DateInterval имеются следующие 2 метода под именем getSecond:
Date getSecond()    // определен в классе DateInterval
Object getSecond()  // переопределяет метод из класса Pair для вызова первого метода

// Написать этот код на Java без параметров нельзя,
// т.к. было бы неверно иметь 2 метода с одинаковыми типами параметров.
// Но в виртуальной машине типы параметров и возвращаемый тип определяют метод.
// Поэтому компилятор может сформировать байт-код для двух методов,
// отличающихся только возвращаемым типом, и виртуальная машина правильно ведет себя в подобной ситуации.

// Применение мостовых методов не ограничивается только обобщенными типами.
// Вполне допустимо определять в методе более ограниченный возвращаемый тип (глава 5),
// когда он переоnределяет другой метод.
// Здесь методы:
Object.clone()
Employee.clone()
// имеют так называемые ковариантные возвращаемые типы.

public class Employee implements Cloneable {
    public Employee clone() throw CloneNotSupportedException { ... }
}
// На самом деле в классе Object имеются два таких метода:
    Employee clone() //определен выше
    Object clone() // синтезированный мостовой метод, переопределяющий 11 метод Object clone()
// При этом синтезированный мостовой метод вызывает вновь определенный метод.

// О преобразовании обобщений в Java нужно запомнить следующее.
//      • Для виртуальной машины обобщений не существует, но имеются только обычные классы и методы.
//      • Все параметры типа заменяются ограничивающими типами.
//      • Мостовые методы синтезируются для соблюдения принципа полиморфизма.
//      • Операции приведения типов вводятся по мере надобности для обеспечения типовой безопасности.

// page 406
// 8.5.4 Вызов унаследованного кода

// Главная цель обобщений в Java:
// обеспечить совместимость обобщенного и унаследованного кода.

// В библиотеке Swing для разработки графических интерфейсов предоставляется класс JSlider,
// реализующий компонент ползунка, где отметки могут быть специально определены с метками,
// содержащими текст или изображения.
// Метки устанавливаются с помощью следующего вызова:
void setLabelTable(Dictionary table)

// В классе Dictionary целые числа сопоставляются с метками.
//      - до версии Java 5 данный класс был реализован в виде отображения экземпляров типа Object.
//      - в версии Java 5 класс Dictionary был сделан обобщенным, хотя класс JSlider вообще не был обновлен.
// -> класс Dictionary без параметров типа относится к базовому типу.
// -> здесь и вступает в действие совместимость.

// При заполнении словаря можно воспользоваться базовым типом:
Dictionary <Integer, Component> labelTable = new HashTable<>();
labelTable.put(0, new JLabel(new ImageIcon("nine.gif")));
labelTable.put(20, new JLabel(new ImageIcon("ten.gif")));
...

// При попытке передать объект обобщенного типа Dictionary<Integer, Component> методу setLabelTable(),
// компилятор выдаст соответствующее предупреждение:
slider setLabelTable(labelTable);       // Предупредждение!

// Компилятору неизвестно, что именно метод setLabel Таblе() может сделать с объектом типа Dictionary.
// Так, этот метод может заменить все ключи символьными строками,
// нарушив гарантию того, что ключи должны иметь тип Integer.
// Поэтому при выполнении последующих операций приведения типов могут возникнуть неприятные исключения.

// Вопрос:
// что именно компонент типа JSlider собирается делать с данным объектом типа Dictionary.
// Ответ:
// компонент типа JSlider только вводит информацию, так что предупреждением компилятора можно пренебречь.

// Противоположный случай:
// Объект базового типа получается от унаследованного класса.
// Его можно присвоить переменной обобщенного типа, но тогда будет выдано предупреждение:
Dictionary<Integer, Components> labelTable = slider.getLabelTable();    // Предупреждение!

// Анализируем предупреждение и убежаемся в том,
// что таблица меток действительно содержит объекты типа Integer и Component,
// хотя нет никакой гарантии, что они там присутствуют.

// В частности, злоумышленник может установить другой объект типа Dictionary в компоненте типа JSlider.
// Но опять же эта ситуация не хуже той, что была до внедрения обобщений.
// В худшем случае программа сгенерирует исключение.

// Обратив внимание на предупреждение компилятора, воспользуемся аннотацией для того, чтобы оно исчезло.
// Такую аннотацию следует разместить перед локальной переменной следующим образом:
@SuppressWarnings("unchecked")
Dictionary<Integer, Components> labelTable = slider.getLabelTable();    // Предупреждение отсутсвует!

// Аналогичным образом можно снабдить аннотацией весь метод,
// Такая аннотация отменяет проверку всего кода в теле метода.
@SuppressWarnings("unchecked")
public void configureSlider() { ... }

// page 407
// 8.6 Ограничения и пределы обобщений

// В основном эти ограничения являются следствием стирания типов.


// page 407
// 8.6.1 Параметрам типа нельзя приписывать простые типы

// Примитивный тип нельзя подставить вместо типа параметра.
// -> не бывает объекта типа Pair<double>
// -> бывает объект типа Pair<Double>.

// Причина - в стирании типов.
// После такого стирания в классе Pair отсутствуют поля типа Object,
// и поэтому их нельзя использовать для хранения значений типа double.

// И хотя такое ограничение досадно, оно согласуется с особым положением примитивных типов в Java.
// Этот недостаток не носит фатального характера.
// Ведь существует всего восемь простых типов данных,
// а обработать их всегда можно с помощью отдельных классов и методов,
// когда нельзя подставить вместо них типы-оболочки.

// page 407
// 8.6.2 Во время выполнения можно запрашивать только базовые типы
(runtime type inquiry only works with raw types)

runtime type  - тип времени выполнения
inquiry       - расследование
raw type      - сырой тип

// В виртуальной машине объекты всегда имеют определенный необобщенный тип.
// Поэтому все запросы типов во время выполнения дают только базовый тип.
//
Например, следующий оператор только проверяет, является ли "а" экземпляром Pair любого типа:
if (a instanceOf Pair<String>)  // Ошибка!

// Это же справедливо и в отношении следующего оператора:
if (a instanceOf Pair<T>)       // Ошибка!

// Или такого оператора приведения типов:
Pair<String> p =  (Pair<String>) a;     // Предупреждение!
    // Проверить можно только принадлежность к переменной "a" к типу Pair

// Чтобы напомнить о возможной опасности, компилятор выдает:
// 1. ошибку:
//    - при операции instanceof
// 2. предупреждение:
//    - при приведении типов
// всякий раз, когда делается запрос, принадлежит ли объект к обобщенному типу.

// Аналогично метод getClass():
// всегда возвращает базовый тип.

// Результатом сравнения оказывается логическое значение true,
// потому что при обоих вызовах метода getClass() возвращается объект типа Pair.class

Pair<String> stringPair = ...;
Pair<Employee> employeePair = ...;
if (stringPair.getClass() == employeePair.getClass())   // равны!

// page 408
// 8.6.3 Массивы параметризированных типов недопустимы

// Нельзя объявить массив параметризованных типов:
var table = new Pair<String> [10]       // Ошибка!

// Что же здесь не так?
// После стирания, типом таблицы становится Pair[], но его можно преобразовать в тип Object[]:
Object[] objArray = table;

// В массиве запоминается тип его элементов и генерируется исключение типа ArrayStoreException,
// если попытаться сохранить в нем элемент неверного типа:
objArray[0] = "Hello";  // Ошибка! Типом компонента является Pair

// Стирание делает этот механизм неэффективным для обобщенных типов.
// Приведенное ниже присваивание пройдет проверку на сохранение в массиве,
// но выдаст ошибку соблюдения типов.

objArray[0] = new Pair<Employee>();
// Именно поэтому массивы параметризованных типов не допускаются.

// Не допускается только создание подобных массивов.
// И хотя разрешается, например, объявить переменную типа:
Pair<String>[]
// ее нельзя инициализировать с помощью операции:
new Pair<String>[10]

// Допускается объявлять массивы элементов подстановочных типов,
// а затем приводить их к соответствующим типам:
var tаblе = (Pair<String>[]) new Pair<?>[10];
// Хотя результат такой операции не гарантирует полную безопасность.

// Если сначала сохранить объект типа Pair<Employee> в элементе массива table[0],
// а затем вызвать для него метод table[0].getFirst() из класса String,
// то будет сгенерировано исключение типа ClassCastException.

// Если объекты параметризованных типов требуется хранить в коллекциях,
// пользуйтесь обобщенным классом ArrayList, например:
ArrayList<Pair<String>>        // это безопасно и эффективно


// page 409
// 8.6.4 Предупреждение о переменном числе аргументов (Varargs warnings)

// В Java не поддерживаются массивы обобщенных типов.

// -> Вопрос:
// Как выполняется передача экземпляров обобщенных типов методу с переменным числом аргументов?

// Пример простого метода с переменным числом аргументов:
public static <T> void addAll (Collection<T> coll, T... ts) {
    for (T t : ts) coll.add(t);
}

// Параметр ts является массивом, содержащим все предоставляемые арrументы.

// Рассмотрим вызов этого метода:
Collection<Pair<String>> table = ...;
Pair<String> pair1 = ...;
Pair<String> pair2 = ...;
addAll(table, pair1, pair2);

//Для вызова этого метода в виртуальной машине Java придется
// сформировать массив объектов типа Pair<String>, что не по правилам.
// Но эти правила были ослаблены, чтобы уведомлять в подобных случаях только о предупреждении.

// Подавить выдачу такого предупреждения можно двумя способами:
// 1. ввести аннотацию @SuppressWarnings ("unchecked") в тело метода, содержащего вызов метода addAll().
// 2. ввести аннотацию @SafeVarargs в тело самого метода addAll() - (с версии Java 7):
      @SafeVarargs
      public static <T> void addAll(Collection<> coll, T...ts)

// Теперь этот метод можно вызывать с аргументами обобщенных типов.
// Приведенную выше аннотацию можно ввести в любые методы,
// выбирающие элементы из массива параметров
// - наиболее характерного примера употребления переменного числа аргументов.
// Аннотацию @SafeVarargs можно употреблять в:
/  - конструкторах
// - методах типа:
//      - static
//      - final
//      - private (начиная с версии Java 9).

// Любой другой метод можно было бы переопределить,
// но тогда употребление данной аннотации потеряло бы всякий смысл.

С помощью аннотации @SafeVarargs можно преодолеть ограничение на создание обобщенного массива.
Для этой цели служит метод:
@SafeVarargs
static <Е> Е[] array(E... array) {
    return array;
}
// который можно далее вызвать следующим образом:
Pair<String>[] tаblе = array(pairl, pair2);

// Но такой прием чреват следующей опасностью:
Object[] objarray = tаblе;
objarray[O] = new Pair<Employe>();
// ->
// Этот фрагмент кода будет выполняться без исключения типа ArrayStoreException,
// поскольку в массиве сохраняются данные только стертого типа.
// Но если обратиться к элементу массива tаblе[0] в другом месте кода,
// то такое исключение будет сгенерировано.

// page 410
// 8.6.5 Нельзя создавать экземпляры переменных типа

// Переменные типа нельзя использовать в выражениях вроде new T( ... )
// Например, следующий конструктор Pair<T> недопустим:

// Будет ошибка!
public Pair() {
    first = new T();
    second = new T()
}

// Стирание типов может изменить обобщенный тип Т на Object,
// а вызывать конструктор new Object(), конечно, не стоит.

// Начиная с версии Java 8, можно прибегнуть к наилучшему обходному приему,
// предоставив в вызывающем коде ссылку на конструктор:
Pair<String> р = Pair.makePair(String::new);

// Метод makePair() получает ссылку на функциональный интерфейс
// для вызова функции без аргументов и возврата результата типа Т следующим образом:
public static <T> Pair<T> makePair(Supplier<T> constr) {
    return new Pair<>(constr.get(), constr.get());
}

// В качестве более традиционного обходного приема
// обобщенные объекты можно конструировать через рефлексию, вызывая метод:
Constructor.newInstance().

// К сожалению, это совсем не простой прием. Сделать приведенный ниже вызов нельзя.
// Выражение T.class недопустимо, поскольку оно будет приведено путем стирания к выражению Object.class.
first = T.class.getConstructor().newInstance();     // Ошибка!

// Вместо этого придется разработать прикладной интерфейс API,
// чтобы передать методу makePair() объект типа Class:
public static <T> Pair<T> makePair(Class<T> cl) {
    try {
        return new Pair<>(cl.getConstructor().newInstance(), cl.getConstructor().newInstance());
    } catch (Exception ex) {
        return null;
    }
}
// -> этот метод може быть вызван следующим образом:
Pair<String> p = Pair.makePair(String.class);

// Следует, однако, иметь в виду, что класс Class сам является обобщенным.
// Например, String.class - это экземпляр (на самом деле единственный) типа Class<String>.
// Поэтому в методе makePair() может быть автоматически выведен тип создаваемой пары.

// page 410
// 8.6.6 Нельзя строить обобщенные массивы

// Как нельзя получить единственный обобщенный экземпляр, так нельзя построить обобщенный массив.
// Но причина здесь другая: массив заполняется пустыми значениями null,
// что может показаться вполне безопасным для его построения.

// Но ведь массив относится к определенному типу,
// который служит в виртуальной машине для контроля значений, сохраняемых в массиве. А этот тип стирается:
public static<T extends Comparable> T[] minmax(T[] a) {
    T[] mm = new T[2];
    ...
    // Ошибка!
}

// Если массив используется только как закрытое поле экземпляра класса,
// его можно объявить как Object[] и прибегнуть к приведению типов при извлечении из него элементов.
// Например, класс ArrayList может быть реализован следующим образом:

public class ArrayList<E> {
    private Object[] elements;
    ...
    @SuppessWarnings("unchecked")
    public E get(int n) {
        return (E) elements[n];
    }
    public void set(int n, E e) {
        elements[n] = e;
    }
    // Приведение типов не требуется!
}

// Но конкретная его реализация не настолько ясна.
// Так, в следующем фрагменте кода приведение к типу Е[] совершенно ложно,
// но стирание типов делает это незаметным:

public class ArrayList<E> {
    private E[] elements;
    ...
    public ArrayList() {
        elements = (E[]) new Object[10];
    }
}

// Такой прием не подходит для метода minmax(), поскольку он возвращает массив обобщенного типа Т[].
// И если сделать ложное заключение о типе, то во время выполнения кода возникнет ошибка.
// Допустим, обобщенный метод minmax() реализуется следующим образом:
public static <T extends Comparable> T[] minmax(T... a) {
    Object[] mm = new Object[2];
    ...
    return (T[]) mm;    // Компилируется без предупреждения
}

// Тогда приведенный ниже вызов данного метода компилируется без всяких предупреждений.
String[] ss = minmax("Tom", "Dick", "Harry");

// Исключение типа ClassCastException возникает,
// когда ссылка на объект типа Object[] приводится к типу Comparable[] при возврате из метода.

// В таком случае лучше всего предложить пользователю предоставить ссылку на конструктор массива следующим образом:
String ss = ArrayArg.minmax(String[]::new, "Tom", "Dick", "Harry");

// Ссылка на конструктор "String::new" обозначает
// функцию для построения массива типа String заданной длины.
// Она служит в качестве параметра метода для получения массива нужного типа, как показано ниже.
public static <T extends Comparable> T[] minmax (IntFunction<T[]> constr, T... a) {
    T[] mm = constr.apply(2);
    ...
}

// Более традиционный способ, воспользоваться рефлексией и сделать вызов Array.newInstance() следующим образом:
public static <T extends Comparable> T[] minmax(T... a) {
    T[] mm = (T[]) Array.newInstance(a.getClass().getComponentType(), 2);
    ...
}

// Методу toArray () из класса ArrayList повезло в меньшей степени.
// Ему нужно построить массив типа Т[], но у него нет типа элементов.
// Поэтому возможны два варианта:
Object[] to array()
T[] toArray(T[] result)     // принимает параметр в виде массива.
// Если этот массив достаточно велик, то он используется.
// В противном случае создается новый массив подходящею размера с элементами типа result.

// Дополнительно:
// Когда идет речь о том, что "нельзя строить обобщенные массивы",
// имеется в виду, что в Java нельзя напрямую создавать массивы обобщенных типов.

// Например, нельзя написать что-то вроде:
T[] array = new T[10];  // Ошибка
// потому что на момент выполнения информация о типе T стирается (это называется "стирание типов"),
// и компилятор не знает, какой именно тип должен иметь этот массив.

// Пример неправильного использования обобщенного массива:
public static <T extends Comparable> T[] minmax(T[] a) {
    T[] mm = new T[2]; // Это неверно
    // ...
}
// Здесь T[] mm = new T[2]; пытается создать массив типа T, но так делать нельзя из-за стирания типов.

// Вместо этого, если нужно использовать массив внутри обобщенного метода,
// можно воспользоваться массивом типа Object[], а затем выполнить приведение типов:
public static <T extends Comparable> T[] minmax(T[] a) {
    Object[] mm = new Object[2];
    // ...
    T[] result = (T[]) mm; // Приведение типов
    return result;
}

// Однако это подходит только для внутреннего использования массива внутри метода,
// так как общий массив Object[] не сохраняет типовую информацию о своих элементах.

// Если нужен массив с обобщенным типом для хранения данных в вашем классе,
// то можно использовать обычный массив Object[] и выполнять приведение типов вручную,
// как показано в следующем примере:

public class ArrayList<E> {
    private Object[] elements;

    public ArrayList() {
        elements = new Object[10];
    }

    public E get(int n) {
        return (E) elements[n];
    }

    public void set(int n, E e) {
        elements[n] = e;
    }
}
// elements - это массив Object[], для организации хранения элементов любого типа,
// а метод get(int n) выполняет приведение типов для возвращаемого значения.


// page 412
// 8.6.7 Переменные типа в статическом контексте обобщенных классов недействительны

// На переменные типав нельзя ссылаться в статических полях или методах.
// Например, следующий код не сработает:
public class Singleton<T> {
    private static T singleInstance;    // Ошибка!

    private static T getSingleInstance() {  // Ошибка!
        if (singleInstance == null) {
            // сконструировать новый экземпляр типа T
        }
        return singleInstance;
    }
}

// Если бы такое было возможно, то программа должна была бы сконструировать экземпляр типа Singleton<Random>
// для общего генератора случайных чисел и экземпляр типа Singleton <JFileChooser>
// для общего диалогового окна выбора файлов.

// Но такая уловка не сработает.
// Ведь после стирания типов остается только один класс Singleton и только одно поле singleInstance.
// Именно по этой причине статические поля и методы с переменными типа просто недопустимы.

// Обобщенные типы рассчитаны на использование с конкретными типами данных,
// которые известны на этапе компиляции.
// Однако статические члены класса существуют в контексте всего класса, не привязанные к конкретным экземплярам.
// И поскольку обобщенные типы не являются конкретными типами, их нельзя использовать в статическом контексте.

// В примере с классом Singleton<T> :
// попытка объявить статическое поле singleInstance типа T приведет к ошибке компиляции,
// так как T не является конкретным типом.
// То же самое касается статического метода getSingleInstance(), который пытается вернуть объект типа T,
// но такое использование также невозможно.

// Обычно для создания синглтонов в Java используют другие методы.
// например, используются:
// - статический фабричный метод
// - инициализации в момент загрузки класса

// page 412
// 8.6.8 Нельзя генерировать или перехватывать экземпляры обобщенного класса в виде исключений

// Генерировать или перехватывать объекты обобщенного класса в виде исключений не допускается.
// На самом деле обобщенный класс не может расширять класс Throwable.

// Например, приведенное ниже определение обобщенного класса не будет скомпилировано:
public class Problem<T> extends Throwable {
    /* ... */   // Ошибка! Класс Thhrowable расширять нельзя!
}

// Кроме того, переменную типа нельзя использовать в блоке catch.

// Например, следующий метод не будет скомпилирован:
public static <T extends Throwable> void doWork (Class<T> t) {
    try {
        // выполнение нужных действий
    } catch (T e) {     // Ошибка! Перехватывать переменную типа нельзя
        Logger.global.info(...)
    }
}

// Но в то же время переменные типа можно использовать в определениях исключений.

// Так, приведенный ниже метод вполне допустим:
public static <T extends Throwable> void doWork (T t) throw T {     // Допустимо!
    try {
        // выполнение нужных действий
    } catch (Throwable realCause) {
        t.initCause(realCause);
        throw t;
    }
}

// В Java можно использовать переменные типа в определениях исключений при объявлении обобщенных методов.
// Это позволяет методам генерировать исключения определенного типа, который расширяет класс Throwable.

// 1. <T extends Throwable> говорит о том,
//    что метод doWork является обобщенным и принимает параметр типа T,
//    который должен быть подтипом Throwable.

// 2. throws T указывает, что метод может генерировать исключение типа T.

// После выполнения нужных действий в блоке try метод перехватывает
// любые выбрасываемые исключения и передает их в параметр "t",
// инициализируя его в качестве причины с помощью метода initCause().
// Затем метод выбрасывает исключение "t" с помощью оператора throw,
// распространяя исключение на вызывающий код.

// Такой подход позволяет методу обрабатывать и генерировать исключения определенного типа
// в зависимости от требований и конкретной ситуации.

// page 413
// 8.6.9 Преодоление ограничения на обработку проверяемых исключений

// Как гласит основополагающий принцип обработки исключений в Java,
// для всех проверяемых исключений должны быть предоставлены соответствующие обработчики.
// Но это ограничение можно преодолеть, используя обобщения.

// И главным средством для достижения этой цели служит следующий метод:
@SuppressWarnings("unchecked")
public static <T extends Throwable> void throwAs (Throwable e) throw T {
    throw (T) e;
}

// Допустим, этот метод содержится в интерфейсе Таsk.
// Если сделать следующий вызов при наличии проверяемого исключения "е":
Task.<RuntimeException>throwAs(e);      // компилятор посчитает "е" непроверяемым исключением.

// В этом фрагменте кода все исключения будут расценены компилятором как непроверяемые:
try {
    // выполнить нужные действия ...
} catch (Throwable t) {
    Task.<RuntimeException>throwAs(t);
}

// Воспользуемся этим обстоятельством, чтобы разрешить досадное недоразумение.
// Чтобы выполнить прикладной код в потоке исполнения,
//eгo придется расположить в теле метода run() из класса, реализующего интерфейс Runnable.

// Но ведь этому методу не разрешается генерировать проверяемые исключения.
// Поэтому предоставим для интерфейса Runnable адаптер из интерфейса Task,
// методу run() которого разрешается генерировать произвольные исключения:
interface Task {
    void run() throws Exception;

    @SupperessWarnings("unchecked")
    static <T extends Throwable> void throwAs (Throwable t) throw t {
        throw (T) t;
    }

    static Runnable asRunnable(Task task) {
        return() -> {
            try {
                task.run();
            } catch(Exception ex) {
                Task.<RuntimeException>throwAs(e);
            }
        };
    }
}

// В следующем примере программы исполняется поток,
// в котором будет сгенерировано проверяемое исключение:
public class Test {
    public static void main(String[] args) {
        var thread = new Thread(Task.asRunnable(() -> {
            Thread.sleep(1000);
            System.out.println("Hello world!");
            throw new Exception("Check this out!");
        }));
        thread.start();
    }
}

// Здесь метод Thread.sleep() объявляется для генерирования исключения типа InterruptedException,
// которое больше не требуется перехватывать.
// Это исключение не будет сгенерировано, поскольку исполнение потока не прерывается.

// Тем не менее в данной программе генерируется проверяемое исключение.
// В результате выполнения данной проrраммы будет получена трассировка стека.

// Что же в этом такого особенноrо?
// Как правило, все исключения, возникающие в методе run() исполняемоrо потока,
// приходится перехватывать и заключать в оболочку непроверяемых исключений.
// -> метод run() объявляется без генерирования проверяемых исключений.

// Но в данном примере эти исключения не заключаются в оболочку.
// Вместо этого просто генерируется исключение, которое компилятор вынужден не воспринимать как проверяемое.
// С помощью обобщенных классов, стирания типов и аннотации @SuppressWarnings,
// здесь удалось преодолеть весьма существенное оrраничение, накладываемое системой типов в Java.

// page 415
// 8.6.10 Остерегайтесь конфликтов после "стирания" типов

// Не допускается создавать условия, приводящие к конфликтам после стирания обобщенных типов.

// Допустим, в обобщенный класс Pair вводится метод equals():
public class Pair<T> {
    ...
    public boolean equals(T value) {
        return first.equals(value) && second.equals(value);
    }
    ...
}

// Рассмотрим далее класс Pair<String>.
// По факту в нем имеются два метода equals():
boolean equals(String)  // Определен в обобщенном классе Pair<T>
boolean equals(Object)  // Унаследован от класса Object

// Но интуиция вводит в заблуждение.
// В результате стирания типов метод:
// boolean equals(Т) -> boolean equals(Object)
// который вступает в конфликт с методом Object.equals().

// Разумеется, для разрешения подобного конфликта следует переименовать метод,
// из-за котороrо возникает конфликт.

// В описании обобщений приводится другое правило:
// "Для поддержки преобразования путем стирания типов накладывается следующее ограничение:
//      класс или переменная типа не могут одновременно быть подтипами двух типов,
//      представляющих разные виды параметризации одного и того же интерфейса".

// Пояснение:
// Это ограничение касается ситуации, когда есть два интерфейса с одинаковыми именами,
// но с разными параметризациями, и класс или переменная типа должны быть подтипами обоих интерфейсов.

// Допустим, у нас есть два интерфейса с одинаковыми именами SomeInterface, но с разными параметризациями:

interface SomeInterface<T> { }
interface SomeInterface<T, U> { }

// Далее предположим, что у нас есть класс SomeClass, который должен реализовать оба этих интерфейса:

class SomeClass implements SomeInterface<String>, SomeInterface<Integer, Double> { }

// Это приведет к ошибке компиляции, потому что при стирании типов
// необходимо разрешить конфликт между двумя интерфейсами с одинаковыми именами.
// Компилятор не сможет определить, какой из интерфейсов следует использовать в контексте класса SomeClass,
и поэтому выдаст ошибку.

// Это ограничение проистекает из того, что при стирании типов компилятор теряет информацию о параметризации
// и он не может однозначно определить,
// к какому именно интерфейсу с одинаковым именем относится класс или переменная типа.

// Для избежания этой проблемы вам следует избегать создания неоднозначных ситуаций,
// когда имена интерфейсов совпадают, но их параметризации отличаются.

//Используйте:
// - уникальные имена для каждого интерфейса
// - предоставьте разные методы или аргументы для каждого случая использования интерфейса

// Таким образом...
// следующий код недопустим:
class Employee implements Comparable<Employee> { ... }
class Manager extends Employee implements Comparable<Manager> { ... }   // Ошибка!

// В этом коде класс Manager должен одновременно реализовать оба типа,
//  - Comparable<Employee>
//  - Comparable<Manager>
// представляющие разные виды параметризации одного и тоrо же интерфейса.

// Неясно, каким образом это ограничение согласуется со стиранием типов.
// Ведь вполне допустим следующий необобщенный вариант реализации интерфейса Comparable:
class Employee implements Comparable { ... }
class Manager extends Employee implements Comparable { ... }

// Причина недоразумения намного менее явная,
// поскольку может произойти конфликт с синтезированными мостовыми методами.
// Класс, реализующий обобщенный интерфейс Comparable<X>,
// получает приведенный ниже мостовой метод.
// Но дело в том, что наличие двух таких методов с разными обобщенными типами "X" не допускается.

public int compareTo(Object other) {
    return compareTo((X) other);
}

// page 416
// 8.7 Правила наследования обобщенных типов

// Для правильного обращения с обобщенными классами необходимо усвоить ряд правил,
// касающихся наследования и подтипов.

// Начнем с ситуации, которую многие программисты считают интуитивно понятной.

// Рассмотрим в качестве примера класс Employee и подкласс Manager.
// Вопрос:
// Является ли обобщенный класс Раir<Manager> подклассом,
// производным от обобщенного класса Pair<Employee>?

// Ответ:
// Как ни странно, нет, не является.

// Следующий код не подлежит компиляции:
Manager[] topHonchos = ...;
Pair<Employee> result = ArrayAlg.minmax(topHonchos);    // Ошибка!

// Метод minmax() возвращает объект типа Pair<Manager>, но не тип Pair<Employee>,
// а присваивать их друг другу недопустимо.

// В общем случае между классами Pair<S> и Pair<T> нет никаких отношений наследования,
// как бы ни соотносились друг с друrом обобщенные типы S и T на рис.8.1 (resources/_416/pic_8_1.puml).

// Такое ограничение может показаться слишком строгим,
// но оно необходимо для соблюдения типовой безопасности.

// Допустим, объект класса Pair<Manager> все же разрешается преобразовать в объект класса Pair<Employee>,
// как показано в приведенном ниже фрагменте кода.
Pair<Manager> manageBuddies = new Pair<>(ceo, cfo);
Pair<Employee> employeeBuddies = managerBuddies;    // недопустимо, но предположим, что разрешено
employeeBuddies.setFirst(lowlyEmployee);

// Даже если последний оператор в данном фрагменте кода и допустим,
// переменные employeeBuddies и managerBuddies все равно ссылаются на один и тот же объект.

// В итоге получается, что высшее руководство организации приравнивается к рядовым сотрудникам,
// что недопустимо для класса Pair<Manager>.

// Ранее было проведено очень важное отличие между обобщенными типами и массивами в Java.
// Массив мanager [] можно присвоить переменной типа Employee [] следующим образом:
Maпager[] maпagerBuddies = { сео, cfo };
Employee[] employeeBuddies = maпagerBuddies; //Допустимо!

// Но массивы снабжены дополнительной защитой.
// Если попытаться сохранить объект рядового сотрудника в элементе массива employeeBuddies [О],
// то виртуальная машина сгенерирует исключение типа ArrayStoreException.

// Параметризованный тип можно всегда преобразовать в базовый.
// Например, Pair<Employee> - это подтип базового типа Pair.
// Такое преобразование необходимо для взаимодействия с унаследованным кодом.

// Вопрос:
// А можно ли преобразовать базовый тип и тем самым вызвать ошибку соблюдения типов?
// Ответ:
// К сожалению, да.

// Рассмотрим следующий пример кода:
Pair<Manager> managerBuddies = new Pair<>(ceo, cfo);
Pair rawBuddies = managerBuddies;       // Допустимо!
rawBuddies.setFirst(new File("..."));   // Допустимо, но только с предупреждением во время компиляции

// Такой код, настораживает.
// Но в текущей версии, ситуация оказывается не хуже, чем в прежних версиях Java.
// Защита виртуальной машины не безгранична.
// Когда внешний объект извлекается методом getFirst() и присваивается переменной типа Manager,
// генерируется исключение типа ClassCastException, как и в старые добрые времена.

// Но в этом случае код лишается дополнительной защиты,
// которую обычно предоставляет обобщенное программирование.

// Одни обобщенные классы могут расширять или реализовывать другие обобщенные классы.
// В этом отношении они ничем не отличаются от обычных классов.

// Например, обобщенный класс ArrayList<T> реализует обобщенный интерфейс List<T>.
// Это означает, что объект типа ArrayList<Manager> может быть преобразован в объект типа List<Manager>.
// Но, объект типа ArrayList<Manager> - это не объект типа ArrayList<Employee> или List<Employee>.

// Схематически показаны все отношения наследования между обобщенными классами и интерфейсами рис. 8.2
// (resources/_418/pic_8_2.puml)


// page 417
// 8.8 Подстановочные типы (Wildcard types)

// Исследователям систем типов уже давно известно,
// что пользоваться жесткими системами обобщенных типов весьма неприятно.
// Поэтому создатели Java придумали изящный и безопасный выход из положения:
//  - подстановочные типы.

// page 419
// 8.8.1 Понятие подстановочного типа

// В подстановочном типе параметр типа может быть переменным.
// Например, следующий подстановочный тип обозначает любой обобщенный тип Pair,
// параметр типа которого представляет подкласс, производный от класса Employee,
// в частности, класс Pair<Manager>, но не класс Pair<String>.
Pair<? extends Employee>

// Допустим, требуется написать следующий метод, выводящий ФИО работника на экран:
public static void printBuddies(Pair<Employee> p) {
    Employee first = p.getFirst();
    Employee second = p.getSecond();
    System.out.println(first.getName() + " и " + second.getName() + " - друзья")
}

// Как уже говорилось, передать объект типа Pair<Manager> методу printBuddies() нельзя, что не совсем удобно.
// Но из этого положения имеется простой выход - воспользоваться подстановочным типом:
public static void printBuddies(Pair<? extends Employee> p)

// Тип Pair<Manager> является подтипом Pair<? extends Employee> на рис. 8.3 (resources/_419/pic_8_3.puml).

// Вопрос:
// Могут ли подстановки нарушить тип Pair<Manager> по ссылке Pair<? extends Employee>?
// Ответ:
// Нет, не могут, как показано в приведеном ниже фрагменте кода:
Pair<Manager> managerBuddies = new Pair<>(ceo, cfo);
Pair<? extends Employee> wildcardBuddies = managerBuddies;  // Допустимо!
wildcardBuddies.setFirst(lowlyEmployee);                    // Ошибка при компиляции!

// Но в то же время вызов метода setFirst() приведет к ошибке соблюдения типов.
// Тчательно проанализируем обобщенный класс типа Pair<? exteпds Employee>, для выявления причины ошибки.
// У него имеются следующие методы:
? extends Employee getFirst()
void setFirst(? extends Employee)

//Это делает невозможным вызов метода setFirst().
// Компилятору требуется какой-нибудь подтип Employee, но неизвестно, какой именно.
// Он отказывается передать любой конкретный тип,
// поскольку знак подстановки "?" может и не совпасть с этим типом.

// При вызове метода getFirst() такое затруднение не возникает.
// Значение, возвращаемое методом getFirst(),
// вполне допустимо присвоить переменной ссылки на объект типа Employee.

// В этом и состоит главный смысл ограниченных подстановок.
// С помощью подстановок можно различать:
// "безопасные методы доступа" от "небезопасных модифицирующих методов".


// page 419
// 8.8.2 Ограничение супертипа на подстановки

// Ограничения на нодстановки подобны ограничениям на переменные типа.
// Но у них имеется дополнительная возможность - определить ограничение cyпертипa следующим образом:
//      ? super Manager

// Такая подстановка ограничивается всеми супертипами Manager.
// По удачному стечению обстоятельств существующего в Java
// ключевого слова super оказалось достаточно для столь точного описания подобного отношения наследования.

// Вопрос:
// Зачем может понадобиться подстановка с ограничением супертипа?
// Ответ:
// Она дает поведение, противоположное поведению подстановочных типов (раздел 8.8).
// В частности, методам можно передавать параметры, но нельзя использовать возвращаемые ими значения.

// Например, в классе типа Pair<? super Manager> имеются следующие методы:
void setFirst (? super Manager)
? super Manager getFirst()

// Это выражение наглядно показывает, что именно известно компилятору.
// Компилятору не может быть точно известен тип метода setFirst(),
// поэтому он не может допустить вызов этого метода с любым объектом типа Employee или Object в качестве аргумента.

// Он способен лишь передать объект типа Manager или его подтипа, например Executive.
// Более того, если вызывается метод getFirst(),то нет никакой гарантии относительно типа возвращаемого объекта.
// Его можно присвоить только переменной ссылки на объект типа Object.

// Допустим, имеется массив руководящих работников организации
// и сведения о минимальном и максимальном размере премии одного из них требуется ввести в объект класса Pair.
// Вопрос:
// К какому же типу относится класс Pair?
// Ответ:
// Справедливо, если это окажется тип Pair<Employee> или Pair<Object> как на рис. 8.4 (resources/_421/pic_8_4.puml).

// Следующий метод примет любой подходящий объект типа Pair в качестве своего параметра:
public static void minmaxBonus(Manager[] a, Pair<? super Manager> result) {
    if (a == null || a.length == 0) return;
    Manager min = a[0];
    Manager max = a[0];
    for (int i = 1; i < a.length; i++) {
        if (min.getBonus() > a[i].getBonus()) min = a[i];
        if (min.getBonus() < a[i].getBonus()) max = a[i];
    }
    result.setFirst(min);
    result.setSecond(max);
}

// 1. Подстановки с ограничениями супертипа - позволяют записывать данные в обобщенный объект,
// 2. Подстановки с ограничениями подтипа - позволяют читать данные из обобщенного объекта.

// Другой пример наложения ограничений супертипа.
// Интерфейс Comparable сам является обобщенным и объявляется следующим образом:
public interface Comparable<T> {
    public int compareTo(T other);
}

// Где переменная типа обозначает тип параметра other.

// Например, класс String реализует интерфейс Comparable<String>,
// а его метод compareTo() объявляется следующим образом:
public int compareTo(String other)

// И это хорошо. Ведь явно задаваемый параметр имеет правильный тип.
// До появления обобщений параметр "other" относился к типу Object,
// поэтому в реализации данного метода требовалось приведение типов.

// А теперь интерфейс Comparable относится к обобщенному типу,
// что позволяет внести следующее усовершенствование в объявление метода min() в классе ArrayList:
public static <T extends Comparable<T>> T min(T[] a)

// Такое объявление метода оказывается более основательным,
// чем простое расширение типа T extends Comparable, и должно вполне подходить для многих классов.

// Так, если определяется минимальное значение в массиве типа String,
// то обобщенный тип T становится типом String, а тот подтипом Comparable<String>.

// Но при обработке массива объектов типа LocalDate возникает затруднение:
// Класс LocalDate реализует интерфейс ChronoLocalDate,
// а тот расширяет интерфейс Comparable<ChronoLocalDate>.
// -> класс LocalDate реализует интерфейс Comparable<ChronoLocalDate>,
// а не интерфейс Comparable<LocalDate>.

// В подобных случаях на помощь приходят супертипы, как показано ниже:
public static <T extends Comparable<? super T>> T min(T[] a) ...

// Теперь метод compareTo() имеет следующую форму:
int compareTo(? super T)

// Возможно, он объявляется для принятия в качестве параметра объекта обобщенного типа T или даже супертипа T,
// если, например, T обозначает тип GregorianCalendar.
// Как бы то ни было, методу compareTo() можно безопасно передать объект обобщенного типа T.

// Непосвященных объявление вроде <T extends Comparable<? super T>> может повергнуть в невольный трепет.
// И это прискорбно, потому что такое объявление призвано помочь прикладным программистам,
// исключая ненужные ограничения на параметры вызова.

// Прикладные программисты, не интересующиеся обобщениями, вероятно,
// предпочтут поскорее пропустить такие объявления и принять на веру,
// что разработчики библиотеки знали, что делали.

// А тем, кто занимается разработкой библиотек, придется обратиться к подстановкам,
// иначе пользователи их библиотек помянут их недобрым словом и вынуждены будут
// прибегать в своем коде к разного рода приведению типов до тех пор,
// пока он не скомпилируется без ошибок.

// Ограничения супертипа накладываются на подстановки и при указании аргумента типа функционального интерфейса.
// Наnример, в интерфейсе Collection имеется следующий метод:
default boolean removeIf(Predicate<? super Е> filter)

// Этот метод удаляет из коллекции все элементы, удовлетворяющие заданному nредикату.
// Если не нравятся нечетные хеш-коды некоторых работников, их можно удалить:
ArrayList<Employee> staff = ...;
Predicate<Object> oddHashCode = obj -> obj.hashCode() % 2 != 0;
staff.removeIf(oddHashCode);

// В данном случае функциональному интерфейсу требуется nередать аргумент типа Predicate<Object>,
// а не просто Predicate<Employee>.

// И это позволяет сделать ограничение "super" на nодстановку.

// page 422
// 8.8.3 Неограниченные подстановки

// Подстановками можно пользоваться вообще без ограничений, например Pair<?>.
// На первый взгляд этот тип похож на базовый тип Pair, но на самом же деле эти типы отличаются.

// В классе типа Pair<?> имеются методы, аналогичные приведенным ниже:
? getFirst()
void setFirst(?)

// Значение, возвращаемое методом getFirst(),
// может быть присвоено только переменной ссылки на объект типа Object.
// А метод setFirst() вообще нельзя вызвать - даже с параметром типа Object.

// Существенное отличие типов Pair<?> и Pair:
// метод setObject() из класса базового типа Pair нельзя вызвать с любым объектом типа Object,
// но тем не менее можно сделать вызов setFirst (null).

// Вопрос:
// Зачем вообще может понадобиться такой непонятный тип?
// Ответ:
// Он удобен для выполнения очень простых операций.

// В данном методе проверяется, содержит ли пара пустую ссылку на объект.
public static boolean hasNulls(Pair<?> p) {
    return p.getFirst() == null || p.getSecond() == null;
}

// Такому методу вообще не требуется конкретный тип.

// Применения подстановочного типа можно было бы избежать,
// превратив этот метод в обобщенный, как показано ниже:
public static <T> boolean hasNulls(Pair)

// Но его предыдущий вариант с подстановочным типом выглядит более удобочитаемым.


// page 423
// 8.8.4 Захват подстановок (wildcard capture)

// Рассмотрим метод, меняющий местами составные элементы пары:
public static void swap(Pair<?> p)

// Подстановка не является переменной типа, поэтому знак "?" нельзя указывать вместо типа.
// -> cледующий фрагмент кода написан неверно:
? t = p.getFirst();     // Ошибка!
p.setFirst(g.getSecond());
p.setSecond(t);

// В связи с этим возникает затруднение,
// поскольку при перестановке приходится временно запоминать первый составной элемент пары.
// Правда, это затруднение можно разрешить весьма любопытным способом,
// написав вспомогательный метод swapHelper(), как показано ниже:
public static <T> void swapHelper(Pair<T> p) {
    T t = p.getFirst();
    p.setFirst(p.getSecond());
    p.setSecond(t);
}

// Нужно иметь в виду, что метод swapHelper () - обобщенный,
// тогда как метод swap() - необобщенный.

// У него имеется фиксированный параметр типа Pair<?>.
// Теперь метод swapHelper() можно вызвать из метода swap() следующим образом:
public static void swap(Pair<?> p) {
    swapHelper(p);
}

// Параметр обобщенного типа T захватывает подстановку во вспомогательном методе swapHelper().
// Неизвестно, какой именно тип обозначает подстановка, но это совершенно определенный тип.

// Поэтому определение метода <T> swapHelper() имеет конкретный смысл, когда обобщение T обозначает этот тип.

// Пользоваться в данном случае подстановкой совсем не обязательно.
// Можно напрямую реализовать метод <Т> void swap (Pair<T> р) как обобщенный и без подстановок.

// Рассмотрим метод в котором подстановочный тип
// появляется естественным образом посреди вычислений:
public static void maxminBonus (Manager[] a, Pair<? super Manager> result) {
    minmaxBonus(a, result);
    PairAlg.swap(result)    // Допустимо, т.к. в методе swapHelper() захватывается подстановочный тип
}

// В данном случае обойтись без механизма захвата подстановки нельзя.
// Захват подстановки допускается в очень ограниченных случаях.
// Компилятор должен иметь возможность гарантировать,
// что подстановка представляет один, вполне определенный тип.

// Например, обобщение T в объявлении класса ArrayList<Pair<T>>
// вообще не сможет захватить подстановку в объявлении класса ArrayList<Pair<?>>.

// Списочный массив может содержать два элемента типа Pair<?>,
// в каждом из которых вместо знака "?" будет подставлен свой тип.


// page 425
// 8.9 Рефлексия и обобщения
// С помощью рефлексии произвольные объекты можно анализировать во время выполнения.
// Если же объекты являются экземплярами обобщенных классов,
// то с помощью рефлексии можно получить немного сведений о параметрах обобщенного типа, поскольку они стираются.

// Тем не менее в последующих разделах поясняется,
// какие сведения об обобщенных классах все-таки позволяет выявить рефлексия.

// page 425
// 8.9.1 Обобщенный класс Class

// Класс Class теперь является обобщенным.
// Например, String. class - на самом деле объект класса Class<String>.

// Параметр типа удобен, потому что он позволяет методам обобщенного класса Class<T>
// быть более точными в отношении возвращаемых типов.

// В следующих методах из класса Class<T> используются преимущества параметра типа:
// newInstance() - возвращает экземпляр класса, полученный от конструктора по умолчанию.
//                 Eгo возвращаемый тип теперь может быть объявлен как T,
//                 т.е. тот же тип, что и у класса, описанного в обобщении Class<T>.
//                 Такой прием позволяет экономить на приведении типов.

// T cast(Object obj) - возвращает данный объект, объявленный теперь как имеющий обобщенный тип T,
//                      если его тип действительно является подтипом T.
//                      В противном случае он генерирует исключение типа BadCastException.

// T[] getEnumConstants() - возвращает пустое значение null, если данный класс не относится
//                          к типу перечислений или массивов перечислимых значений, о которых известно,
//                          что они принадлежат к обобщенному типу Т.

// Class<? super T> getSuperclass() - возвращает суперкласс данного класса или пустое значение null,
//                                    если обобщенный тип T не обозначает класс или же обозначает класс Object.

// Constructor<T> getConstructor(Class... parameterTypes) -  возвращают объект обобщенного класса Constructor<T>.
//                                                           Класс Constructor также стал обобщенным,
//                                                           поэтому у метода newinstance() теперь
//                                                           имеется правильный возвращаемый тип.
// Constructor<T> getDeclaredConstructor(Class... parameterTypes) - возвращает тоже что и getConstructor()

// page 427
// 8.9.2 Сопоставление типов с помощью параметров Class<T>

// Иногда оказывается полезно сопоставить переменную типа параметра Class<T> в обобщенном методе.
// Пример:
public static <T> Pair<T> makePair(Class<T> c) throw InstantiationException, IllegalAccessException {
    return new Pair<>(c.newInstance(), c.newInstance());
}

// Если сделать приведенный ниже вызов, то параметр Employee.class:
// -> объект типа Class<Employee>.
// Параметр обобщенного типа T в методе makePair() сопоставляется с классом Employee,
// откуда компилятор может заключить, что данный метод возвращает объект типа Pair<Employee>.
   makePair(Employee.class)

// page 427
// 8.9.3 Сведения об обобщенных типах в виртуальной машине

// Одной из примечательных особенностей обобщений в Java
// является стирание обобщенных типов в виртуальной машине.

// Классы, подвергшиеся стиранию типов, все еще сохраняют некоторую память о своем обобщенном происхождении.

// Например, базовому классу Pair известно, что он происходит от обобщенного класса Pair<T>,
// несмотря на то, что объект типа Pair не может отличить,
// был ли он сконструирован как объект типа Pair<String> или как объект типа Pair<Employee>.

// Следующий метод:
public static Comparable min(Comparable[] a)
// -> является результатом стирания типов в обобщенном методе:
public static <T extends Comparable<? super T>> T min (T[] a)

// Прикладной интерфейс API для рефлексии можно использовать, чтобы определить имеет ли:
    • обобщенный метод параметр типа T
    • параметр типа ограниченный подтип, который сам является обобщенным
    • ограничивающий тип подставляемый параметр
    • подставляемый параметр ограниченный супертип
    • обобщенный метод обобщенный массив в качестве своего параметра

// С помощью рефлексии можно реконструировать все,
// что было объявлено в реализации обобщенных классов и методов.

// Но вряд ли можно узнать, каким образом разрешались параметры типа
// для конкретных объектов и вызовов методов.

// Чтобы выразить объявления обобщенных типов, следует воспользоваться интерфейсом Туре.
// у которого есть следующие подтипы:
// • Класс Class, описывающий конкретные типы.
// • Интерфейс TypeVariable, описывающий переменные типа (например, Textends Comparable<? super Т>).
// • Интерфейс WildcardType, онисывающий подстановки (например,? super Т).
// • Интерфейс ParameterizedType, описывающий обобщенный класс или типы интерфейсов (например, Comparable<? super Т>).
// • Интерфейс GenericArrayType, описывающий обобщенные массивы (например, т [] ).

// На рис. 8.5 (resources/_428/pic_8_5.puml)
// схематически показана иерархия наследования интерфейса Туре.
// Последние четыре подтипа являются интерфейсами.
// Виртуальная машина создает экземпляры подходящих классов, реализующих эти интерфейсы.

// В исходном коде примера программы из листинга 8.4 ()
// вывод сведений о данном классе на экран организуется
// с помощью приклалноrо интерфейса API для рефлексии обобщений.

// Если выполнить эту программу вместе с классом Pair,
// то в результате будет получен следующий отчет:
// class Pair<T> extends java.lang.Object
// public Т getFirst()
// public Т getSecond()
// public void setFirst(T)
// public void setSecond(T)

// А если выполнить эту программу вместе с классом ArrayAlg в каталоге PairTest2,
// то в отчете появится следующий метод:
// public static <Т extends java.lang.Comparable> Pair<T> minmax(T[])


// page 431
// 8.9.4 Литералы типов

// Иногда требуется управлять поведением программы по типу значения.
// Например, пользователю механизма сохраняемости требуется предоставить возможность
// указывать порядок сохранения объекта конкретного класса.
// Такая возможносгь реализуется связыванием объекта типа Class с конкретным действием.

// Но в связи со стиранием типов в обобщенных классах
// -> Вопрос:
// как, обеспечить разные действия для классов ArrayList<Integer> и ArrayList<String>,
// в которых стирается один и тот же базовый тип ArrayList?

// Ответ:
// Специальный прием, который состоит в том,
// чтобы зафиксировать экземпляр упоминавшегося ранее интерфейса Туре,
// с помощью создания анонимного подкласса:
var type = new TypeLiteral<ArrayList<Integer>>() {}     // Особое внимание на фигурные скобки

// Конструктор класса TypeLiteral фиксирует обобщенный тип:
class TypeLiteral {
    public TypeLiteral() {
        Type parentType = getClass().getGenericSuperclass();
        if () {
            type = ((ParameterizedType) parentType).getActualTypeArguments()[0];
        } else {
            throw new UnsupportedOperationException("Construct as new TypeLiteral<...>() {}");
        }
    }
    ...
}

// чтобы найти исчерпывающие ответы на вопросы,
// которые могут возникнуть в связи с применением на практике механизма обобщений в Java,
// можно обратиться к замечательному списку часто (и не очень часто) задаваемых вопросов:
// http://angelikalanger.com/GenericsFAQ/JavaGenericsFAQ.html

// page 437
// 9 глава: Коллекции

• (9.1) Каркас коллекций в Java
• (9.2) Интерфейсы в каркасе коллекций
• (9.3) Конкретные коллекции
• (9.4) Отображения (Maps)
• (9.5) Представления и оболочки
• (9.6) Алгоритмы
• (9.7) Унаследованные коллекции

// Выбираемые структуры данных мoгyт заметно отличаться по:
// - реализации методов в "естественном стиле" (нативные)
// - производительности
// -> Вопросы:
//    • Требуется ли быстрый поиск среди тысяч (или даже миллионов) отсортированных элементов?
//    • Нужен ли быстрый ввод и удаление элементов в середине упорядоченной последовательности?
//    • Требуется ли устанавливать связи между ключами и значениями?
// В этой главе будет показано, как реализовать средствами библиотеки Java традиционные структуры данных,
// без которых немыслимо серьезное программирование.

// Узнаем подробнее о том, как используются классы Коллекций из стандартной библиотеки в прикладном коде.


// page 437
// 9.1 Каркас коллекций в java

// В первоначальной версии Java предлагался лишь небольшой набор классов
// для наиболее употребительных структур данных:
// - (class) Vector
// - (class) Stack
// - (class) Hashtable
// - (class) BitSet
// - (interface) Enumiration

// предоставлявший абстрактный механизм для обращения к элементам,
// находящимся в произвольном контейнере.
// -> Реализации всеобъемлющей библиотеки классов коллекций требуется время и опыт.

// page 438
// 9.1.1 Разделение интерфейсов и реализаций колекций

// В современных библиотеках структур данных,
// в рассматриваемой здесь библиотеке коллекций Java интерфейсы и peaлизации разделены.

// Каким образом происходит это разделение, на примере структуры данных - Queue (очередь):
// Интерфейс Queue (очередь) определяет, что элементы можно:
// добавлять в хвосте очереди,
// удалять их в ее голове,
// выяснять, сколько элементов находится в очереди в данный момент.

// Очереди применяются в тех случаях, когда требуется накапливать объекты
// и извлекать их по принципу "первым пришел - первым обслужен" (рис. 9.1).

// Самая элементарная форма интерфейса очереди из стандартной библиотеки:
interface Queue<E> {
    void add(E element);
    E remove();
    int size();
}

// Из интерфейса нельзя ничеrо узнать, каким образом реализована очередь.

// Существуют разные реализации очереди, в том числе применяется:
//  - циклический массив
//  - связный список (рис. 9.2)

// Каждая реализация может быть выражена классом, реализующим интерфейс Queue, как показано ниже:

class CircularArrayQueue<E> implements Queue<E> {  // этот класс не из библиотеки
    CircularArrayQueue(int capacity) {...}
    public void add(E element) {...}
    public E remove() {...}
    public int size() {...}
    private E[] elements;
    private int head;
    private int tail;
}

class LinkedListQueue<E> implements Queue<E> {  // и этот класс не из библиотеки
    LinkedListQueue() {...}
    public void add (E element) {...}
    public E remove() {...}
    public int size() {...}
    private Link head;
    private Link tail;
}

// Библиотека Java на самом деле не содержит классы CircularArrayQueue и LinkedListQueue.

// Они служат здесь лишь в качестве примера,
// чтобы пояснить принципиальное отличие интерфейса от реализации.

// Если требуется организовать очередь:
// - на основе циклического массива, воспользуйтесь классом ArrayDeque,
// - в виде связного списка классом LinkedList, реализующим интерфейс Queue.

// Применяя в своей программе очередь, совсем не обязательно знать,
// какая именно реализация используется для построения коллекции.
// Конкретный класс имеет смысл использовать только в том случае,
// если конструируется объект коллекции.

// А тип интерфейса служит лишь для ссылки на коллекцию, как показано ниже:
Queue<Customer> expressLane = new CircularArrayQueue<>(100);
expressLane.add(new Customer("Гарри"));

// Если придется изменить решение, то при таком подходе нетрудно будет воспользоваться другой реализацией.
// Для этого достаточно внести изменения только в одном месте программы:
// при вызове конструктора.

// Так, если остановить свой выбор на классе LinkedListQueue,
// код реализации очереди в виде связного списка будет выглядеть следующим образом:
Queue<Customer> expressLane = new LinkedListQueue<>();
expressLane.add(new Customer("Гарри"));

// Вопрос?
// Почему выбирается одна реализация, а не другая?
// Ведь из самого интерфейса ничего нельзя узнать об эффективносrи реализации.

// Ответ:
// Циклический массив в некотором отношении более эффективен, чем связный список,
// и поэтому ему обычно отдается предпочтение. За все нужно платить.
// Циклический массив является ограниченной коллекцией, имеющей конечную емкость.
// Если неизвестен верхний предел количесrва объектов, которые должна накапливать прикладная программа,
// то имеет смысл выбрать реализацию очереди на основе связного списка.

// Изучая документацию на прикладной интерфейс API, вы обнаружите другой набор классов,
// имена которых начинаются на Abstract, как, например, AbstractQueue.
// Эти классы предназначены для разработчиков библиотек.

// Когда потребуется реализовать свой собственный класс очереди, будет проще,
// расширить класс AbstractQueue, чем реализовывать все методы из интерфейса Queue.


// page 440
// 9.1.2 интерфейс Collection

// Основополагающим для классов коллекций в библиотеке Java является интерфейс Collection.
// В его состав входят два основных метода:
public interface Collection<E> {
    boolean add (E element);
    Iterator<E> iterator();
    ...
}
Также еще пара методов:
// add() - добавляет элемент в коллекцию. Он возвращает логическое значение true,
//         если добавление элемента в действительности изменило коллекцию,
//         а если коллекция осталась без изменения - логическое значение false.
//         Если попытаться добавить объект в коллекцию, где такой объект уже имеется,
//         вызов метода add() не даст желаемого результата,
//         поскольку коллекция не допускает дублирование объектов.

// iterator() - возвращает объект класса, реализующего интерфейс Iterator.
//              Объект итератора можно выбрать для обращения ко всем элементам коллекции по очереди.
//              Подробнее об итераторах (раздел 9.1.3)

// page 441
// 9.1.3 Итераторы

// В состав интерфейса Iterator входят три метода:
public interface Iterator<E> {
    E next;
    boolean hasNext();
    void remove;
}

// Многократно вызывая метод next(), можно обратиться к каждому элементу коллекции по очереди.
// Но если будет достигнут конец коллекции,
// то метод next() сгенерирует исключение типа NoSuchElementException.

// Поэтому перед вызовом метода next() следует вызывать метод hasNext().
// Этот метод возвращает логическое значение true,
// если у объекта итератора все еще имеются объекты, к которым можно обратиться.

// Если же требуется перебрать все элементы коллекции,
// то следует запросить итератор, продолжая вызывать метод next() до тех пор,
// пока метод hasNext() возвращает логическое значение true.

// В приведенном ниже примере показано, как все это реализуется непосредственно в коде:
Collection<String> c = ...;
Iterator<String> iter = c.iterator();
while(iter.hasNext()) {
    String element = iter.next();
    // сделать что-нибудь с элементом element
}

// Тот же самый код можно написать более компактно, организовав цикл в стиле for each следующим образом:
for (String element : c) {
    // сделать что-нибудь с элементом element
}

// Компилятор преобразует цикл в стиле for each в цикл с итератором.

// Цикл в стиле for each подходит для любых объектов,
// класс которых реализует интерфейс Iterable со следующим единственным методом:
public interface Iteable<E> {
    Iterator<E> iterator();
}

// Интерфейс Collection расширяет интерфейс Iterable.
// -> цикл в стиле for each подходит для обращения к элементам любой коллекции из стандартной библиотеки.

// Чтобы перебрать элементы коллекции, можно не организовывать цикл.
// Для этого достаточно вызвать метод forEachRemaining() с лямбда-выражением,
// где употребляется элемент коллекции.

// Это лямбда-выражение вызывается с каждым из элементов до тех пор,
// пока их больше не останется в коллекции:
iterator.forEachRemaining(element -> сделать что-нибудь с элементом element);

// Порядок, в котором перебираются элементы, зависит от типа коллекции.

// Если осуществляется перебор элементов коллекции типа ArrayList,
// итератор начинает eгo с нулевоrо индекса, увеличивая последнее значение на каждом шаrе итерации.

// Если осуществляется перебор элементов коллекции типа HashSet,
// то они получаются в совершенно случайном порядке.

// Можно быть уверенным лишь в том, что за время итерации будут перебраны все элементы коллекции,
// хотя нельзя сделать никаких предположений относительно порядка их следования.

// Обычно это не особенно важно, потому что порядок не имеет значения при таких вычислениях,
// как, например, подсчет суммы или количества совпадений.

// методы next() и hasNext () из интерфейса Iterator служат той же цели,
// что и методы nextElement() и hasМoreElements() из интерфейса Enumeration.

// Разработчики библиотеки коллекций в Java могли бы отдать предпочтение интерфейсу Enumeration.
// Но им не понравились громоздкие имена методов,
// и поэтому они разработали новый интерфейс с более короткими именами.

// Принципиальное отличие между итераторами из библиотеки коллекций в Java и других библиотек.

// Пример C++ (Standard Template Library):
// Здесь итераторы моделируются по индексам массива.

// Имея такой итератор, можно найти элемент, находящийся на данной позиции в массиве,
// подобно тому, как находится элемент массива а[i], если имеется индекс i.

// Независимо от способа поиска элементов коллекции,
// итератор можно передвинуть на следующую позицию.

// Эта операция аналогична приращению индекса i++ без поиска.

// Пример Java:
// Итераторы в Java действуют иначе.
// Поиск элементов в коллекции и изменение их позиции тесно взаимосвязаны.
// Единственный способ найти элемент - вызвать метод next(),
// а в ходе поиска происходит переход на следующую позицию.

// Итераторы в Java следует представлять себе так,
// как будто они находятся между элементами коллекции.
// Когда вызывается метод next(), итератор перескакивает следующий элемент и возвращает ссылку на тот элемент,
// который он только что прошел (рис. 9.3). (resources/_442/pic_9_3.JPG)

// Можно nрибегнуть к еще одной удобной аналогии,
// рассматривая объект Iterator.next в качестве эквивалента объекта InputStream.read.

// При вводе байта из nотока этот байт автоматически nотребляется.
// А nри nоследующем вызове метода read() nотребляется и возвращается следующий байт из nотока ввода.
// Аналогично nовторяющиеся вызовы метода next() nозволяют ввести все элементы из коллекции.

// Метод remove() из интерфейса Iterator удаляет элемент,
// который был возвращен при последнем вызове метода next().

// Во многих случаях это имеет смысл, т.к. нужно проанализировать элемент,
// прежде чем решаться на его удаление.

// Но если требуется удалить элемент, находящийся на определенной позиции,
// то сначала придется его пройти.

// Пример, как удалить первый элемент из коллекции символьных строк:
Iterator<String> it = c.iterator();
it.next();      // пройти первый элемент коллекции
it.remove();    // а теперь удалить его

// Важнее то, что между вызовами методов next() и remove() существует определенная связь.
// Запрещено вызывать метод remove(),
// если перед ним не был вызван метод next().

// Если же попытаться сделать это, будет сгенерировано исключение типа IllegalStateException.
// А если из коллекции требуется удалить два соседних элемента,
// то нельзя просто вызвать метод remove() два раза подряд:
it.remove();
it.remove();    // Ошибка!

// Нужно сначала вызвать метод next(),
// чтобы пройти удаляемый элемент, а затем удалить его,
// как следует из приведенного ниже примера кода:
it.remove();
it.next();
it.remove();    // Допустимо!


// page 443
// 9.1.4 Обобщенные служебные методы

// Интерфейсы Collection и Iterator являются обобщенными,
// -> можно написать служебные методы для обращения к разнотипным коллекциям.

// В качестве примера ниже приведен обобщенный служебный метод,
// проверяющий, содержит ли произвольная коллекция заданный элемент.
public static <E> boolean contains(Collection<E> c, Object obj) {
    for (E element : c) {
        if (element.equals(obj)) {
            return true;
        }
        return false;
    }
}

// Некоторые из этих служебных методов настолько полезны,
// что их следует сделать доступными из самой библиотеки.
// Пользователи библиотеки избавлены от необходимости заново изобретать колесо.
// По существу, в интерфейсе Collection объявляется немало полезных методов,
// которые должны использоваться во всех реализующих его классах.
// К числу служебных методов относятся следующие:
int size()
boolean isEmpty()
boolean contains (Object obj)
boolean containsAll(Collection<?> c)
boolean equals(Object other)
boolean addAll(Collection<? extends E> from)
boolean remove(Object obj)
boolean removeAll(Collection<?> c)
void clear()
boolean retainAll(Collection<?> c)
Object[] toArray()
<T> T[] toArray(T[] arrayToFill)

// Многие из этих методов самоочевидны,
// а подробнее о них можно узнать из краткого описания прикладного интерфейса API в конце этого раздела.

// Было бы неудобно, если бы в каждом классе, реализующем интерфейс Collection,
// пришлось реализовывать такое количество служебных методов.

// Чтобы облегчить жизнь разработчикам,
// в библиотеке коллекций Java предоставляется класс AbstractCollection,
// где основополагающие методы size() и iterator() оставлены абстрактными,
// но реализованы служебные методы:
public abstract class AbstractCollection<E> implements Collection<E> {
    ...
    public abstract Iterator<E> iterator();
    public boolean contains(Object obj) {
        for (E element : this)  {   // вызвать метод iterator
            if (element.equals(obj)) {
                return = true;
            }
        }
        return false;
    }
    ...
}

// Конкретный класс коллекции теперь может расширить класс AbstractCollection.

// И тогда именно этот конкретный класс отвечает за реализацию метода iterator(),
// тогда как о служебном методе contains() уже позаботились в суперклассе AbstractCollection.

// Если в его подклассе можно предложить более эффективный способ реализации служебного метода contains(),
// то ничто не мешает сделать это именно в нем.
// Такой подход считается немного устаревшим.

// Упомянутые выше методы в интерфейсе Collection не объявлены по умолчанию,
// но в этот интерфейс всеже было введено несколько методов по умолчанию.

// Большинство из них предназначено для обработки потоков данных (2 том).

// Для удаления элементов из коллекции по заданному условию
// имеется следующий метод:
default boolean removeIf(Predicate<? super E> filter)


// page 446
// 9.2 Интерфейсы в каркасе коллекций Java

// В каркасе коллекций Java определен целый ряд интерфейсов для различных типов коллекций,
// как показано на рис. 9.4 (resources/_447/pic_9_4.puml)

// В рассматриваемом здесь каркасе имеются два основополагающих интерфейса коллекций:
//  - Collection
//  - Мар

boolean add(E element)  // метод для ввода элементов в коллекцию

// Но отображения содержат пары "ключ-значение"
V put(K key, V value)   // метод для ввода пар в коллекцию

// Для извлечения элементов из коллекции служит итератор, организующий обращение к ним.

// Для извлечения значений из отображения вызывается метод get():
V get(K key)

// Список представляет собой упорядоченную коллекцию.
// Элементы добавляются на определенной позиции в контейнере.
// Доступ к элементу списка осуществляется с помощью итератора или по целочисленному индексу.

// В последнем случае доступ оказывается произвольным,
// поскольку к элементам можно обращаться в любом порядке.

// Если используется итератор, то обращаться к элементам списка можно только по очереди.

// Для произвольного доступа к элементам списка в интерфейсе List определяются следующие методы:
void add(int index, E element)
void remove(int index)
E get(int index)
E set(int index, E element)

// Для ввода элемента до позиции итератора в интерфейсе ListIterator, определяется следующий метод:
void add(E element)

// Этот аспект каркаса коллекций спроектирован неудачно.
// На практике имеются две разновидности упорядоченных коллекций
// с совершенно разными показателями производительности.

// Упорядоченная коллекция - на основе массива отличается быстрым произвольным доступом,
//                           и поэтому методы из интерфейса List целесообразно вызывать
//                           с целочисленными индексом.

// Связный список -  отличается медленным произвольным доступом,
//                   хотя он и относится к категории упорядоченных коллекций.
//                   Поэтому перебирать его элементы лучше с помощью итератора.
//                   И для этой цели следовало бы предоставить два разных интерфейса.

// Чтобы избежать дорогостоящих операций произвольного доступа
// с точки зрения потребляемых вычислительных ресурсов,
// в версии Java 1.4 появился новый интерфейс RandomAccess, в котором отсутствуют методы.

// С его помощью можно проверить, поддерживается ли в конкретной коллекции
// эффективный произвольный доступ:
if (c instanceOf RandomAccess) {
    // использовать алгоритм произвольного доступа
} else {
    // использовать алгоритм последовательного доступа
}

// Интерфейс Set (множество) подобен интерфейсу Collection (коллекций),
// но поведение его методов определено более строго.
// метод add() - должен отвергать дубликаты во множестве.

// Метод equals() - должен быть определен таким образом,
//                  чтобы два множества считались одинаковыми,
//                  если они содержат одни и те же элементы,
//                  но не обязательно в одинаковом порядке.

// метод hashCode() - должен быть определен таким образом,
//                    чтобы два множества с одинаковыми элементами
//                    порождали один и тот же хеш-код.

//Вопрос:
// Зачем объявлять отдельные интерфейсы, если сигнатуры их методов совпадают?

// Ответ:
// Не все коллекции являются множествами.
// Поэтому наличие интерфейса Set дает программистам возможность писать методы,
// принимающие только множества.

// В интерфейсах SortedSet и SortedMap становится доступным объект-компаратор,
// применяемый для сортировки,
// а также определяются методы для получения представлений подмножеств коллекций (раздел 9.5).

// В версии Java 6 внедрены интерфейсы:
//  - NavigableSet
//  - NavigableMap
// содержащие дополнительные методы:
//  - для поиска
//  - для обхода
// отсортированныхмножеств и отображений.

// В идеале эти методы должны быть включены в состав интерфейсов:
//  - SortedSet
//  - SortedMap
// Эти интерфейсы реализуются в классах TreeSet и TreeMap.

// page 448
// 9.3 Конкретные коллекции (Concrete Collections)

// В табл. 9.1 перечислены коллекции из библиотеки Java
// вместе с кратким описанием назначения каждого из их классов.

// Ради простоты в ней не указаны классы потокобезопасных коллекций (глава 12)

// Все классы из табл. 9.1 реализуют интерфейс Collection,
// за исключением классов, имена которых оканчиваются на Мар,
// поскольку эти классы реализуют интерфейс Мар будут рассмотрены позднее (раздел 9.4).

Таблица 9.1. Конкретные коллекции из библиотеки Java
|----------------------|-------------------------------------------------------------------------------|
|     Тип коллекции    |                                 Описание                                      |
|----------------------|-------------------------------------------------------------------------------|
|  ArrayList           | Индексированная динамически расширяющаяся и сокращающаяся последовательность  |
|                      |                                                                               |
|  LinkedList          | Упорядоченная последовательность, допускающая эффективную вставку             |
|                      | и удаление на любой позиции                                                   |
|                      |                                                                               |
|  ArrayDeque          | Двунаправленная очередь, реализуемая в виде циклического массива              |
|                      |                                                                               |
|  HashSet             | Неупорядоченная коллекция, исключающая дубликаты                              |
|                      |                                                                               |
|  TreeSet             | Отсортированное множество                                                     |
|                      |                                                                               |
|  EnumSet             | Множество значений перечислимого типа                                         |
|                      |                                                                               |
|  LinkedНashSet       | Множество, запоминающее порядок ввода элементов                               |
|                      |                                                                               |
|  PriorityQueue       | Коллекция, позволяющая эффективно удалять наименьший элемент                  |
|                      |                                                                               |
|  HashМap             | Структура данных для хранения связанных вместе пар "ключ-значение"            |
|                      |                                                                               |
|  ТrееМар             | Отображение с отсортированными ключами                                        |
|                      |                                                                               |
|  EnumМap             | Отображение с ключами, относящимися к перечислимому типу                      |
|                      |                                                                               |
|  LinkedНashМap       | Отображение с запоминанием порядка, в котором добавлялись элементы            |
|                      |                                                                               |
|  WeakHashМap         | Отображение со значениями, которые могут удаляться системой сборки "мусора",  |
|                      | если они нигде больше не используются                                         |
|                      |                                                                               |
|  IdentityHashМap     | Отображение с ключами, сравниваемыми с помощью операции==,                    |
|                      | а не вызова метода equals()                                                   |
|----------------------|-------------------------------------------------------------------------------|

// Отношения между этими классами рис. 9.5 (resources/_449/pic_9_5_1.puml ,resources/_449/pic_9_5_2.puml)


// page 450
// 9.3.1 Связные списки

// Ранее уже не раз использовались массивы
// и родственный им класс ArrayList динамического списочного массива.

// Но обычные и списочные массивы страдают существенным недостатком.
// Удаление элемента из середины массива обходится дорого
// с точки зрения потребляемых вычислительных ресурсов,
// потому что все элементы, слелующие за удаляемым, приходится перемещать к началу массива
// рис. 9.6 (resources/_450/pic_9_6.puml)

// Это же справедливо и для ввода элементов в середине массива.

// Этот недостаток позволяет устранить широко известная структура данных - связный список.
// Если ссылки на объекты из массива хранятся в последовательных областях памяти,
// то каждый объект из связного списка - в отдельной связке.

// В ЯП Java все связанные списки на самом деле являются двунаправленными,
// т.е. в каждой связке хранится ссылка на ее предшественника рис. 9.7  (resources/_451/pic_9_7.puml).

// Удаление элемента из середины связного списка - недорогая операция
// с точки зрения потребляемых вычислительных ресурсов,
// поскольку в этом случае достаточно обновить лишь связки,
// соседние с удаляемым элементом рис. 9.8 (resources/_451/pic_9_8.puml).

// Если вы когда-нибудь изучали структуры данных и реализацию связных списков,
// то, помните, насколько хлопотно соединять связки при вводе или удалении элементов связного списка.

// В библиотеке коллекций Java для этой цели предусмотрен готовый к вашим услугам класс LinkedList.
// В приведенном ниже примере кода
// в связный список сначала вводятся три элемента, а затем удаляется второй из них:
var staff = new KinkedList<>(String);
staff.add("Amy");
staff.add("Bob");
staff.add("Carl");
Iterator<String> iter = staff.iterator();
String first = iter.next();     // обратиться к первому элементу
String second = iter.next();    // обратиться ко второму элементу
iter.remove();                  // удалить последний перебираемый элемент

// Но связные списки существенно отличаются от обобщенных коллекций.
// Связный список - это упорядоченная коллекция, в которой имеет значение расположение объектов.
// Метод LinkedList.add() - вводит объект в конце списка.

// Но объекты зачастую требуется вводить где-то в середине списка.

// За этот метод add(), зависящий от расположения элементов в связном списке,
// отвечает итератор, т.к. в итераторе описывается расположение элементов в коллекции.

// Применение итераторов для ввода элементов имеет смысл только для коллекций,
// имеющих естественный порядок расположения.

// Коллекция типа множества (9.3.2) не предполагает никакого порядка расположения элементов,
// -> в интерфейсе Iterator отсутствует метод add().

// Вместо него в библиотеке коллекций предусмотрен
// следующий подчиненный интерфейс ListIterator,
// содержащий метод add():
interface ListIterator<E> extends Iterator<E> {
    void add(E element);
    ...
}

// В отличие от метода Collection.add(), этот метод не возвращает логическое значение типа boolean.

// Операция ввода элемента в список всегда видоизменяет его.

// Кроме того, в интерфейсе Listiterator имеются следующие два метода,
// которые можно использовать для обхода списка в обратном направлении:
E previous()
boolean hasPrevious()

// Как и метод next(), метод previous() возвращает объект, который он прошел.

// Метод listlterator() из класса LinkedList возвращает объект итератора,
// реализующего интерфейс Listiterator, как показано ниже:
ListIterator<String> iter = staff.listIterator();

// Метод add () вводит новый элемент до текущей позиции итератора.
// Например, в приведенном ниже фрагменте кода
// пропускается первый элемент связного списка
// и вводится элемент "Juliet" перед вторым ею элементом (рис. 9.9).
var staff = new LinkedList<String>();
staff.add("Amy");
staff.add("Bob");
staff.add("Carl");
ListIterator<String> iter = staff.listIterator();
iter.next();    // Пропустить первый элемент списка
iter.add("Juliet");

// Если вызвать метод add() несколько раз,
// элементы будут просто вводиться в список в том порядке, в каком они предоставляются.
// Все они вводятся по очереди до текущей позиции итератора.

// Когда выполняется операция ввода элемента с помощью итератора,
// только что возвращенного методом listiterator() и указывающего на начало связного списка,
// вводимый элемент располагается в начале списка.

// Когда же итератор достигает последнего элемента списка
// (т.е. метод hasNext() возвращает логическое значение false),
// вводимый элемент располагается в конце списка.

// Если связный список содержит "n" элементов,
// тогда для ввода нового элемента в нем имеется "n" + 1 доступных мест.
// Эти места соответствуют "n" + 1 возможным позициям итератора.

// Если связный список содержит три элемента, А, В и С,
// для ввода нового элемента в нем имеются четыре возможные позиции,
// обозначенные ниже знаком курсора "|" :
|ABC
A|BC
AB|C
ABC|
-> |A|B|C|

// Аналогия с курсором "|" не совсем точна.
// Операция удаления элемента из списка выполняется не совсем так,
// как при нажатии клавиши <Backspace>.

// Если метод remove() вызывается сразу же после метода next(),
// то он действительно удаляет элемент, расположенный слева от итератора,
// как это и происходит при нажатии клавиши <Backspace>.

// Но если он вызывается сразу же после метода previous(),
// то удаляется элемент, расположенный справа от итератора.
К тому же метод remove () нельзя вызывать два раза подряд.

// В отличие от метода add(), действие которого зависит только от позиции итератора,
// действие метода remove() зависит и от состояния итератора.

// Метод set() заменяет новым элементом последний элемент,
// возвращаемый при вызове метода next() или previous().
// В следующем фрагменте кода первый элемент списка заменяется новым значением:
ListIterator<String> iter = list.listIterator();
String oldValue = iter.next();  // возвращает первый элемент списка
iter.set(newValue);             // устанавливает в первом элементе новое значение newValue

// Что, если один итератор обходит коллекцию в то время,
// когда другой итератор модифицирует ее,
// могут возникнуть конфликтные ситуации.

// Допустим, итератор установлен до элемента, который только что удален другим итератором.
// Теперь этот итератор недействителен и не должен больше использоваться.

// Итераторы связного списка способны обнаруживать такие видоизменения.
// Если итератор обнаруживает,
// что коллекция была модифицирована другим итератором или же методом самой коллекции,
// он генерирует исключение типа ConcurrentModificationException.

// Рассмотрим в качестве примера следующий фрагмент кода:
List<String> list = ...;
ListIterator<String> iter1 = list.listIterator();
ListIterator<String> iter2 = list.listIterator();
iter1.next();
iter1.remove();
iter2.next();   // генерирует исключение типа ConcurrentModificationException

// При вызове метода iter2.next() генерируется исключение типа ConcurrentModificationException,
// поскольку итератор iter2 обнаруживает, что список был внешне видоизменен.

// Чтобы избежать исключений в связи с попытками одновременной модификации,
// достаточно придерживаться следующего простого правила:
// К коллекции допускается:
// 1. присоединять сколько угодно итераторов, при условии, что все они служат только для чтения.
// 2. присоединить только один итератор, который служит как для чтения, так и для записи.

// Вопрос:
// Как достигается обнаружение одновременной модификации?
// Ответ:
// В коллекции отслеживается количество изменяющих ее операций.
// (например, ввода и удаления элементов).

// Каждый итератор хранит отдельный счетчик операций модификации, вызванных им самим.

// В начале каждого своего метода
// итератор сравнивает значение собственного счетчика модификаций
// со значением счетчика модификаций в коллекции.

// Если эти значения не равны:
// - генерируется исключение типа ConcurrentModificationException.

// Но из приведенного выше правила обнаружения одновременных видоизменений имеется одно исключение:
// Связный список отслеживает лишь структурные модификации вроде ввода и удаления связок.

// Действие метода set() не считается структурной модификацией.
// К связному списку можно присоединить несколько итераторов,
// способных вызывать метод set() для изменения содержимого списка.

// Наличие такой возможности требуется во многих алгоритмах, применяемых в классе Collections, (глава 9).
// Были рассмотрены основные методы из класса LinkedList.

// Интерфейс ListIterator служит:
//  - для обхода элементов связного списка в любом направлении,
//  - для ввода и удаления элементов из списка.

// Как было показано в разделе 9.2,
// в интерфейсе Collection объявлено немало других полезных методов для операций со связными списками.
// Они реализованы главным образом в суперклассе AbstractCollection класса LinkedList.

// Например, метод toString() вызывает одноименный метод для всех элементов списка
// и формирует одну длинную строку в формате [А, В, С], что удобно для отладки.

// А метод contains() удобен для проверки наличия конкретного элемента в связном списке.

// В результате вызова staff.contains("Harry") возвращается логическое значение true,
// если связный список уже содержит символьную строку "Harry".

// В библиотеке коллекций предусмотрен ряд методов, кажущихся избыточными.

// В связных списках не поддерживается быстрый произвольный доступ.
// Если требуется проанализировать "n-й" элемент связного списка,
// то начинать придется с самого начала и перебрать первые n - 1 элементов списка,
// причем без всяких пропусков.

// Именно по этой причине программисты обычно не применяют связные списки в тех случаях,
// когда к элементам требуется обращаться по целочисленному индексу.

// Тем не менее в классе LinkedList предусмотрен метод get(),
// который позволяет обратиться к определенному элементу следующим образом:
LinkedList<String> list = ...;
String obj = list.get();

// Конечно этот метод не очень эффективен.
// И если он все же применяется, то, скорее всего, к неподходящей для этого структуре данных.
// Столь обманчивый произвольный доступ не годится для обращения к элементам связного списка.
// Например, приведенный ниже фрагмент кода совершенно неэффективен.
for (int i = 0; i < list.size(); i++)   // сделать что-нибудь с результатом вызова list.get(i);

// Всякий раз, когда требуется обратиться к другому элементу с помощью метода get(),
// поиск начинается с самого начала списка.

// В объекте типа LinkedList не предпринимается никаких попыток
// буферизовать данные о расположении элементов в списке.

// В методе get() предусмотрена единственная незначительная оптимизация:
// если указанный индекс больше величины size() / 2,
// то поиск элемента начинается С конца списка.

// В интерфейсе итератора списка имеется метод,
// предоставляющий индекс текущей позиции в списке.

// Но поскольку итераторы в Java устроены таким образом,
// что они обозначают позицию между элементами коллекции,
// то таких методов на самом деле два.

// Метод nextIndex() возвращает целочисленный индекс того элемента,
// который должен быть возвращен при последующем вызове метода next().

// А метод previousIndex() возвращает индекс того элемента,
// который был бы возвращен при последующем вызове метода previous().

// И этот previousIndex будет на единицу меньше, чем nextIndex.
// Оба метода действуют эффективно,
// поскольку в итераторе запоминается текущая позиция.

// Если имеется целочисленный индекс "n",
// в результате вызова метода list.listIterator(n) будет возвращен итератор,
// установленный до элемента с индексом "n".
// -> при вызове метода next() получается тот же самый элемент,
// что и при вызове метода list.get(n)
// -> получение такого итератора малоэффективно.

// Если связный список содержит немного элементов,
// то вряд ли стоит беспокоиться об издержках,
// связанных с применением методов set() и get().

// Вопрос:
// Зачем вообще пользоваться связным списком?
// Ответ:
// Минимизация издержек на ввод и удаление в середине списка.

// Если в коллекции предполагается лишь несколько элементов,
// то для ее составления лучше воспользоваться списочным массивом типа ArrayList.

// Рекомендуется держаться подальше от всех методов,
// в которых целочисленный индекс служит для обозначения позиции в связном списке.

// Если требуется произвольный доступ к коллекции,
// лучше воспользоваться обычным или списочным массивом типа ArrayList, а не связным списком.

// Листинга 9.1 демонстрация практического применение связного списка.
// В этой программе сначала составляются два списка,
// затем они объединяются и удаляется каждый второй элемент из второго списка,
// в завершение проверяется метод removeAll().

// Тщательно проанализировать порядок выполнения операций в этой программе,
// уделив особое внимание итераторам.
// -> составить схематическое представление позиций итератора аналогично следующему:
|ACE |BDFG
A|CE |BDFG
AB|CE B|DFG
...

// Вызов System.out.println(a) печатает все элементы связанного списка "a",
// вызывая метод toString() в AbstractCollection.


// page 458
// 9.3.2 Списочные массивы

// В предыдущем разделе (9.3.1) обсуждались интерфейс List и реализующий его класс LinkedList.
// Интерфейс List описывает упорядоченную коллекцию, в которой имеет значение расположение элемента.

// Существуют два способа для обхода элементов:
// 1. посредством итератора
// 2. посредством произвольного доступа с помощью методов get() и set().

// 2 способ не совсем подходит для связных списков, но применение методов
// get() и set() совершенно оправдано для массивов.

// В библиотеке коллекций предоставляется класс ArrayList, также реализующий интерфейс List.

// Класс ArrayList инкапсулирует динамически выделяемый массив объектов.

// Программирующим на Java со стажем, скорее всего,
// уже nриходилось nользоваться классом Vector всякий раз,
// когда возникала nотребность в динамическом массиве.

// Вопрос:
// Почему же вместо класса Vector для подобных целей следует применять класс ArrayList?
// Ответ:
// Все методы из класса Vector синхронизированы.

// К объекту типа Vector можно безопасно обращаться одновременно из двух потоков исполнения.

// Но если обращаться к такому объекту только из одного потока исполнения,
// что случается намного чаще, то в прикладном коде впустую тратится время на синхронизацию.

// В отличие от методов из класса Vector, методы из класса ArrayList не синхронизированы.
// -> рекомендуется nользоваться классом ArrayList вместо класса vector,
// если только нет особой необходимости в синхронизации.


// page 459
// 9.3.3 Хэш-множества (Hash Sets)

// Связные списки (linked lists) и массивы (arrays) позволяют указывать порядок,
// в котором должны следовать элементы.

// Проблема:
// Если вам нужно найти конкретный элемент, а вы не помните его позицию в коллекции,
// то придется перебирать все элементы до тех пор,
// пока не будет обнаружено совпадение по критерию поиска.
// На это может потребоваться некоторое время,
// если коллекция содержит достаточно много элементов.

// Если же порядок расположения элементов не имеет особого значения,
// то для подобных случаев предусмотрены структуры данных,
// которые позволяют намного быстрее находить элементы в коллекции.

// Но недостаток таких структур данных заключается в том,
// что они не обеспечивают никакого контроля над порядком расположения элементов в коллекции.

// Эти структуры данных организуют элементы в том порядке,
// который удобен для их собственных целей.

// К числу широко известных структур данных
// для быстрого нахождения объектов относится так называемая хеш-таблица (hash table),
// которая вычисляет для каждого объекта целочисленное значение, называемое хеш-кодом.
// Хеш-код - это целочисленное значение, которое выводится определенным образом
//           из данных в полях экземпляра объекта, причем предполагается,
//           что объекты с разными данными порождают разные хеш-коды.

// В табл. 9.2 приведено несколько примеров хеш-кодов,
// получаемых в результате вызова метода hashCode() из класса String.

// Таблица 9.2. Хеш-коды, возвращаемые методом hashCode()
  |----------------------|-----------|
  |   Символьная строка  |  Хеш-код  |
  |----------------------|-----------|
  |         "Lee"        |   76268   |
  |         "lee"        |   107020  |
  |         "eel"        |   100300  |
  | ---------------------|-----------|

// Если вы определяете собственные классы,
// то нужно самостоятельно реализовать метод hashCode() (глава 5).

// Ваша реализация данного метода должна быть совместима с методом equals().

// Если в результате вызова a.equals(b) возвращается логическое значение true,
// то объекты a и b должны иметь одинаковые хеш-коды.

// Важно, чтобы хеш-коды вычислялись быстро,
// а вычисление зависело только от состояния хешируемого объекта,
// а не от других объектов в хеш-таблице.

// В языке Java хеш-таблицы реализованы в виде массивов связных списков,
// каждый из которых называется группой (рис. 9.10).

// Чтобы найти место объекта в таблице,
// вычисляется его хеш-код и уменьшается его модуль до общего количества групп.

// Полученное в итоге числовое значение и будет индексом группы, содержащей искомый элемент.

// Если хеш-код объекта равен 76268, а всего имеется 128 групп,
// объект должен быть размещен в группе под номером 108
// (т.к. остаток от целочисленного деления 76268 на 128 равен 108).

// Если в этой группе не окажется других элементов, то элемент просто вводится в группу.
// Рано или поздно встретится непустая группа.
// Такое явление называется хеш-конфликтом.

// В таком случае новый объект сравнивается со всеми объектами в группе,
// чтобы проверить, находится ли он уже в группе.

// Если учесть сравнительно равномерное распределение хеш-кодов
// при достаточно большом количестве групп,
// то в конечном итоге потребуется лишь несколько сравнений.

// Начиная с версии Java 8, вместо связных списков
// в заполненных группах применяются сбалансированные двоичные деревья.

// Это повышает производительность.

// Если в результате неудачно выбранной хеш-функции
// возникает много конфликтов.

// Если в злонамеренном коде
// предпринимается попытка заполнить хеш-таблицу
// многими значениями с одинаковыми хеш-кодами.

// Если требуется более полный контроль над производительностью хеш-таблицы,
// то можно указать первоначальное количество групп.

// Оно определяет количество групп, используемых для накопления объектов с одинаковыми хеш-значениями.

// Если же в хеш-таблицу вводится слишком много элементов, количество конфликтов возрастает,
// что отрицательно сказывается на производительности извлечения элементов из хеш-таблицы.

// Если приблизительно известно,
// сколько элементов в конечном итоге окажется в хеш-таблице,
// можно установить количество групп.

// Обычно это количество устанавливается в пределах от 75 до 150% от ожидаемого числа элементов.

// Некоторые исследователи полагают, что количество групп должно быть выражено простым числом,
// чтобы предотвратить группирование ключей, но на этот счет нет общего мнения.

// В стандартной библиотеке используются количества групп,
// выражаемые числом, являющимся степенью 2, по умолчанию - 16.

// Любое указываемое значение размеров хеш-таблицы автоматически округляется до следующей степени 2.

// Не всегда известно, сколько элементов придется хранить в хеш-таблице,
// а кроме того, первоначально предполагаемое их количество может оказаться заниженным.

// Если хеш-таблица становится чрезмерно заполненной, ее следует хешировать повторно.

// Для повторного хеширования создается новая хеш-таблица с большим количеством групп,
// все элементы старой таблицы вводятся в новую, а старая хеш-таблица отвергается.

// Коэффициент загрузки определяет момент повторного хеширования хеш-таблицы.
// Если коэффициент загрузки равен 0.75 (по умолчанию), а хеш-таблица заполнена более чем на 75%,
// она автоматически хешируется повторно с увеличенным вдвое количеством групп.

// Для большинства приложений целесообразно оставить коэффициент загрузки равным 0.75.

// Хеш-таблицы можно использовать для реализации ряда важных структур данных.

// Простейшая из них относится к типу множества (Set).
// Множество - это совокупность элементов, не содержащая дубликатов.

// Метод add() сначала пытается найти вводимый объект и вводит его только в том случае,
// если он отсутствует в множестве.

// В библиотеке коллекций Java предоставляется класс HashSet,
// реализующий множество на основе хеш-таблицы.

// Элементы вводятся в такое множество методом add().

// Метод contains() переопределяется, чтобы осуществлять быстрый поиск элементов в множестве.
// Он проверяет элементы только одной группы, а не все элемеmы коллекции.

// Итератор хеш-множества (Hash Set) перебирает все группы по очереди.
// В результате хеширования элементы распределяются по таблице, и создается впечатление,
// будто обращение к ним происходит в случайном порядке.

// -> классом HashSet следует пользоваться только в том случае,
// если порядок расположения элементов в коллекции не имеет особого значения.

// В примере программы из листинга 9.2 (ru/sectorsj/_461_set/SetTest.java) отдельные слова текста
// вводятся из стандартного потока System.in в хеш-множество, а затем выводятся из него.

// Например, данной программе можно направить англоязычный текст книги "Алиса в стране чудес"
// (доступный по адресу: http://www.gutenberg.net),
// запустив ее из командной строки следующим образом:
command: java SetTest < alice30.txt
java SetTest < _461/alice30.txt

// Программа введет все слова из стандартного потока ввода в хеш-множество,
// а затем переберет все неповторяющиеся слова в хеш-множестве и выведет их количество.

// Текст книги "Алиса в стране чудес" содержит 5909 неповторяющихся слов,
// включая уведомление об авторском праве в самом начале.

// Слова извлекаются из хеш-множества в случайном порядке.

// Будьте внимательны и аккуратны. изменяя элементы хеш-множества.
// Если хеш-код элемента изменится,
// этот элемент уже не будет находиться на правильной позиции в структуре данных.


// page 463
// 9.3.4 Древовидные множества (Tree Sets)

// Класс TreeSet реализует древовидное множество, подобное хеш-множеству,
// но с одним дополнительным усовершенствованием:
// древовидное множество - представляет собой отсортированную коллекцию,
//                         в которую можно вводить элементы в любом порядке.

// Когда же выполняется перебор ее элементов,
// извлекаемые из нее значения оказываются автоматически отсортированными.

// Допустим, что в такую коллекцию сначала введены три символьные строки,
// а затем перебраны все введенные в нее элементы:
var sorter = new TreeSet<Strung>();
sorter.add("Bob");
sorter.add("Amy");
sorter.add("Carl");
for (String s : sorter) System.println(s);

// Полученные в итоге значения выводятся в отсортированном порядке: Amy, Воb, Carl.
// Как следует из имени класса TreeSet, сортировка обеспечивается древовидной структурой данных.
// В текущей реализации используется структура так называемого красно-черного дерева.

// Подробное описание древовидных структур данных приведено в книге:
// "Алгоритмы: построение и анализ. 3-е издание"
// Томас Х. Кормен, Чарльз И. Лейзерсон, Рональд Л. Ривест, Клиффорд Штайн (ИД "Вильямс", 2016 г.)

// Всякий раз при вводе элемента в древовидное множество
// он размещается на правильно отсортированной позиции.
// -> Итератор всегда перебирает элементы такого множества в отсортированном порядке.

// Ввод элемента в древовидное множество происходит медленнее,
// чем в хеш-таблицу (табл. 9.3), но все же намного быстрее,
// чем в требуемое место массива или связного списка.

// Если древовидное множество состоит из "n" элементов,
// то в среднем требуется log2n сравнений, чтобы найти правильное расположение нового элемента.

// Если древовидное множество уже содержит 1000 элементов,
// для ввода нового элемента потребуется около 10 сравнений.

// Чтобы пользоваться древовидным множеством, необходимо иметь возможность сравнивать его элементы.

// Для этого элементы должны относиться к классу, реализующему интерфейс Comparable,
// а иначе при построении множества придется предоставить объект класса,
// реализующего интерфейс Comparator.

// Интерфейсы Comparable и Comparator (глава 6)

// Таблица 9.3. Сравнение операций ввода элементов в древовидном и хеш-множестве
| ------------------------|--------------|------------------------|------------------|------------------|
|         Документ        |  Всего слов  |  Количество            |  Коллекция типа  |  Коллекция типа  |
|                         |              |  неповторяющмхся слов  |  HashSet         |  TreeSet         |
| ------------------------|--------------|------------------------|------------------|------------------|
| "Алиса в стране чудес"  |  28195       |  5909                  |  5 с             |  7 с             |
| "Граф Монте-Кристо"     |  466300      |  37545                 |  75 с            |  98 с            |
|-------------------------|--------------|------------------------|------------------|------------------|

// Солгасно табл. 9.3, можно прийти к выводу,
// что вместо хеш-множества (Hash Set) всегда следует пользоваться древовидным множеством (Tree Set).

// Т.к. для ввода элементов в такое множество, не требуется много времени,
// а его элементы сортируются автоматически.
// Выбор одной из этих разновидностей множеств зависит от характера накапливаемых данных.

// Если данные не нужно сортировать, то и нет никаких оснований в излишних затратах на их сортировку.
// Важно другое:
// отсортировать некоторые данные в нужном порядке намного сложнее,
// чем с помощью хеш-функции.

// Хеш-функция       - должна достаточно равномерно распределять объекты
// Функция сравнения - должна различать объекты с абсолютной точностью

// Чтобы сделать такое различие конкретным, рассмотрим задачу составления множества прямоугольников.
// Если воспользоваться для этой цели древовидным множеством типа TreeSet,
// то придется предоставить компаратор типа Comparator<Rectangle>.

// Вопрос:
// Как же сравнить два прямоугольника?
// Ответ:
// Сравнить их по площади нельзя,
// поскольку могут оказаться два прямоугольника с разными координатами, но одинаковой площадью.
// Порядок сортировки древовидного множества должен быть общим.

// Два любых элемента должны быть сравнимы,
// и результат сравнения может быть нулевым лишь в том случае,
// если сравниваемые элементы равны.

// Для прямоугольников имеется способ лексикографического упорядочения по координатам,
// но он кажется неестественным и сложным для вычисления.

// С другой стороны, хеш-функция уже определена для класса Rectangle и просто хеширует координаты.

// Начиная с версии Java 6, класс Treeset реализует интерфейс NavigableSet,
// в который введены удобные методы для обнаружения элементов древовидного множества
// и его обхода в обратном порядке.
// Подробности в документации на прикладной интерфейс API.

// В примере программы из листинга 9.3 (ru/sectorsj/_465_treeSet/TreeSetTest.java)
// строятся два древовидных множества объектов типа Item.
// Первое из них сортируется по номеру изделия в каталоге, т.е. в порядке сортировки,
// выбираемом по умолчанию для объектов типа Item.

// А второе сортируется по описанию изделия с помощью специального компаратора.
// Само же изделие и его номер описываются в классе Item из листинга 9.4
// (ru/sectorsj/_465_treeSet/Item.java)

// page 467
// 9.3.5 Одно- и двухсторонние очереди

// 1. Односторонняя (обычная) очередь - позволяет эффективно вводить элементы в свой хвост
//                                      и удалять элементы из своей головы,
// Двухсторонняя очередь - позволяет вводить и удалять элементы на обоих своих концах,
//                         хотя ввод элементов в середине очереди не поддерживается.

// В версии Java 6 появился интерфейс Deque, реализуемый классами ArrayDeque и LinkedList,
// причем оба класса предоставляют двухстороннюю очередь,
// которая может расти по мере надобности.

// Применение ограниченных одно- и двухсторонних очередей (глава 12).


// page 468
// 9.3.6 Очереди по приоритету (Priority Queues)

// В очередях по приоритету элементы извлекаются в отсортированном порядке после того,
// как они были введены в произвольном порядке.
// -> в результате каждого вызова метода remove()
// получается наименьший из элементов, находящихся в очереди.

// В очереди по приоритету сортируются не все ее элементы.
// Если выполняется перебор элементов такой очереди,
// они совсем не обязательно оказываются отсортированными.

// В очереди по приоритету применяется структура данных - "куча"
// самоорганизующееся двоичное дерево,
// в котором операции ввода и удаления вызывают перемещение наименьшего элемента в корень,
// не тратя времени на сортировку всех элементов очереди.

// Подобно древовидному множеству (TreeSet),
// очередь по приоритету может содержать элементы класса,
// реализующего интерфейс Comparable, или же принимать объект типа Comparator,
// предоставляемый конструктору ее класса.

// Очередь по приоритету применяется для планирования заданий на выполнение.
// У каждого задания имеется свой приоритет.
// Задания вводятся в очередь в случайном порядке.
// Когда новое задание запускается на выполнение,
// наиболее высокоприоритетное задание удаляется из очереди.

// Приоритет 1 считается наивысшим,
// поэтому в результате операции удаления из очереди
// извлекается элемент с наименьшим приоритетом.
// В примере программы из листинга 9.5
// (ru/sectorsj/_469_priorityQueue/PriorityQueueTest.java)
// демонстрируется применение очереди по приоритету непосредственно в коде.
// В отличие от перебора элементов древовидного множества (TreeSet),
// в данном примере элементы очереди не перебираются в отсортированном порядке.
// Но удаление из очереди по приоритету всегда касается ее наименьшего элемента.


// page 470
// 9.4 Отборажения (Maps)

// Множество (Map) - это коллекция, которая позволяет быстро находить существующий элемент.
// Для того, чтобы найти такой элемент, нужно иметь его точную копию.
// Это не слишком распространенная операция поиска,
// поскольку, имеется некоторая ключевая информация,
// по которой требуется найти соответствующий элемент.

// Для этой цели предназначена структура данных типа отображения.
// В отображении хранятся пары "ключ-значение" ("key - value").
// -> значение можно найти, если предоставить связанный с ним ключ.

// Можно составить и сохранить таблицу записей о работниках, где:
// - ключами - служат идентификаторы работников,
// - значениями - объекты типа Employee.


// page 470
// 9.4.1 Основные операции на отображениями (Map)

// В библиотеке коллекций Java предоставляются 2 реализации отображений общего назначения.
// Это классы:
// - HashMap (Хеш-отображение)
// - TreeMap (Древовидное отображение)
// реализующие интерфейс Мар.

// Хеш-отображение (типа HashMap) - хеширует ключи
// Древовидное отображение (типа TreeMap) - использует общий порядок ключей
                                            для организации поискового дерева.

// Функции хеширования или сравнения применяются только к ключам.
// Значения, связанные с ключами, не хешируются и не сравниваются.

// Вопрос:
// Когда же следует применять хеш-отображение, а когда - древовидное отображение?
// Ответ:
// Как и во множествах, хеширование выполняется немного быстрее,
// и поэтому хеш-отображение оказывается более предпочтительным,
// если не требуется перебирать ключи в отсортированном порядке.

// Пример организации хеш-отображение для хранения записей о работниках:
var staff = new HashMap<String, Employee>();  // объект класса HashMap, реализующего интерфейс Мар
var harry = new Employee("Гарри Хаккер");
staff.put("987-98-9996", harry);
...

// Всегда когда объект вводится в отображение, следует указать и его ключ.
// В данном случае ключом является символьная строка,
// а соответствующим значением - объект типа Employee.

// Чтобы извлечь объект, нужно использовать (запомнить) ключ:
var id = "987-98-9996";
Employee e = staff.get(id); // Получаем объект harry

// Если в отображении отсутствуют данные по указанному ключу,
// то метод get() возвращает пустое значение null.

// Обрабатывать возвращаемое пустое значение не совсем удобно.
// Иногда для ключей, отсутствующих в отображении, вполне подходит значение по умолчанию,
// и тогда можно воспользоваться методом getOrDefault() следующим образом:

Map<String, Integer> scores = ...;
int score = scores.getOrDefault(id, 0);     // Получаем нулевое значение, если идентификатор отсутствует

// Ключи должны быть уникальными.
// Нельзя сохранить два значения по одинаковым ключам.
// Если дважды вызвать метод put() с одним и тем же ключом,
// то второе значение заменит первое.

// По существу, метод put() возвращает предыдущее значение,
// сохраненное по ключу, указанному в качестве его параметра.

// Метод remove()  - удаляет элемент из отображения по заданному ключу,
// Метод size ()   - возвращает количество элементов в отображении.
// Метод forEach() - для перебора элементов отображения по ключам и значениям
//                   Ему нужно предоставить лямбда-выражение, получающее ключ и значение.
//                   Это выражение вызывается по очереди для каждой записи в отображении:
scores.forEach((k, v) ->
        System.out,println("key = " + k + ", value = " + v));

//Программа из листинга 9.6 (hortsmann_v_one/src/main/java/ru/sectorsj/_471_map)
// демонстрирует применение отображения непосредственно в коде.

// В отображение вводится пара "ключ-значение",
// затем из него удаляется один ключ, а следовательно, и связанное с ним значение.
// Далее изменяется значение, связанное с ключом,
// вызывается метод get() для нахождения значения
// и выполняется перебор множества элементов отображения.


// page 473
// 9.4.2 Обновление записей в отображении

// Вопрос:
// Что самое трудное в обращении с отображениями
// Ответ:
// Обновление записи в отображении.

// С целью обновления записи в отображении:
// 1. получают значение, связанное с заданным ключом,
// 2. обновляют его и вводят обновленное значение в отображение.
// Нужно учитывать особый случай первого вхождения ключа.

// Пример:
// Применение отображения для подсчета частоты появления слова в текстовом файле.
// При обнаружении искомого слова следует инкрементировать счетчик, как показано ниже:
    counts.put(word, counts.get(word) + 1);

// Такой прием вполне пригоден, за исключением того случая,
// когда искомое слово word встречается в текстовом файле в первый раз.

// В таком случае метод get() возвращает пустое значение null
// и возникает исключение типа NullPointerException.

// Поэтому в качестве выхода из этоrо положения
// можно воспользоваться методом getOrDefault() следующим образом:
    counts.put(word, counts.getOrDefault(word, 0) + 1);

// Кроме того, можно вызвать сначала метод putIfAbsent().
// Метод putIfAbsent() - вводит значение в отображение только в том случае,
//                       если соответствующий ключ в нем ранее отсутствовал.
    counts.putIfAbsent(word, 0);
    counts.put(word, counts.get(word) + 1);     // Теперь точно известно, что операция будет выполнена успешно

// Но можно поступить еще лучше, вызвав метод merge(), упрощающий эту типичную операцию.
// Так, в результате следующего вызова:

    counts.merge(word, 1, Integer::sum);

// заданное слово word связывается со значением 1, если ключ ранее отсутствовал,
// а иначе предыдущее значение соединяется со значением 1 по ссылке на метод Integer::sum

// Также существуют и другие методы обновления записей.

// page 474
// 9.4.3 Представления отображений (Maps Views)

// В каркасе коллекций само отображение не рассматривается в качестве коллекции.
// В других каркасах для построения структур данных
// отображение рассматривается в качестве коллекции пар "ключ-значение" или коллекции значений,
// индексированных ключами.
// Можно получить представления отдельного отображения - объекты класса,
// реализующего интерфейс Collection или один из eгo подчиненных интерфейсов.

// Имеются три таких представления:
// - множество ключей (set of keys)
// - коллекция (не множество) значений (the collection of values - not a set)
// - множество пар "ключ-значение" (set of key/value pairs)

// Ключи и пары "ключ-значение" образуют множество,
// потому что в отображении может присутствовать только по одной копии каждого ключа.

// Приведенные ниже методы возвращают эти три представления.
// Элементы последнего множества являются объектами статического внутреннего класса Мар.Entry.
Set<K> keySet()
Collection<K> values()
Set<Map.Entry<K,V>> entrySet()

// keySet - это объект не класса HashSet или TreeSet,
// а некоторого другого класса, реализующего интерфейс Set,
// который расширяет интерфейс Collection.
// -> объектом keySet можно пользоваться как любой другой коллекцией.

// Все ключи в отображении можно перечислить следующим образом:
Set<String> keys = map.keySet();
for (String key : keys) {
    // сделать что-нибудь с ключом key
}

// Если требуется просмотреть ключи и значения,
// то можно избежать поиска значений, перечисляя элементы в отображении.

// Для этой цели служит следующий скелетный код:
for (Map.Entry<String, Employee> entry : staff.entrySet()){
    String k = entry.getKey();
    Employee v = entry.getValue();
    // сделать что-нибудь с "k" с "v"
}

// Чтобы не оперировать неудобными ссылками типа Mар.Entry в исходном коде,
// переменные можно объявлять с помощью ключевого слова var, как показано ниже.
for (var entry : map.entrySet()) {
   // сделать что-нибудь с результатами вызовов методов
   // entry.getKey(), entry.getValue()

}

// А с другой стороны, можно вызвать метод forEach() следующим образом:
map.forEach((k, v) -> {
    // сделать что-нибудь с ключом key и значением v.
}

// Если вызывается метод remove() итератора,
// то из отображения удаляется ключ и связанное с ним значение.

// Ввести элемент в представление множества ключей нельзя.
// Нет никакого смысла вводить ключ, не вводя связанное с ним значение.

// Если попытаться вызвать метод add(),
// он сгенерирует исключение типа UnsupportedOperationException.

// На представление множества элементов отображения накладывается такое же ограничение,
// даже если операция ввода новой пары "ключ-значение" имеет принципиальный смысл.

// page 476
// 9.4.4 Слабые хэш-отображения (Weak Hash Maps)

// В состав библиотеки коллекций Java входит ряд классов отображений для специальных нужд.
// Будут описаны в последующих разделах.

// Класс WeakHashMap был разработан для решения одной интересной задачи.
// Вопрос:
// Что произойдет со значением, ключ которого не используется нигде больше в программе?
// Описание:
// Допустим, что последняя ссылка на ключ исчезла.
// -> не остается никакого способа сослаться на объект-значение.
// Но поскольку ни одна часть программы больше не содержит обращения к данному ключу,
// то и соответствующая пара "ключ-значение" не может быть удалена из отображения.
// Вопрос:
// Почему бы системе сборки "мусора" не удалить эту пару?
// Разве это не ее задача - удалять неиспользуемые объекты?
// Ответ:
// Система сборки "мусора" отслеживает действующие объекты.
// До тех пор, пока действует объект хеш-отображения,
// все группы в нем активны и не мoгyт быть освобождены из памяти.

// -> прикладная программа должна позаботиться об
// удалении неиспользуемых значений из долгосрочных отображений.

// С другой стороны, можно воспользоваться структурой данных типа WeakHashMap,
// которая взаимодействует с системой сборки "мусора" для удаления пар "ключ-значение",
// когда единственной ссылкой на ключ остается ссылка из элемента хеш-таблицы.

// Принцип действия этого механизма:
// В хеш-отображении типа WeakHashMap используются слабые ссылки для хранения ключей.

// Объект типа WeakHashMap содержит ссылку на другой объект,
// в данном случае ключ из хеш-таблицы.

// Объекты этого типа интерпретируются системой сборки "мусора" особым образом.

// Если система сборки "мусора" обнаруживает отсутствие ссылок на конкретный объект,
// то она освобождает занятую им память.

// А если объект доступен только из хеш-отображения типа WeakHashMap,
// то система сборки "мусора" освобождает и его,
// но размещает в очереди слабую ссылку на него.

// В операциях, выполняемых над хеш-отображением типа WeakHashMap,
// эта очередь периодически проверяется на предмет появления новых слабых ссылок.

// Появление такой ссылки в очереди свидетельствует о том,
// что ключ больше не используется нигде, но по-прежнему хранится в коллекции.
// -> связанный с ним элемент удаляется из хеш-отображения типа WeakHashMap.


// page 477
// 9.4.5 Связанные хэш-множества и отображения (Linked Hash Sets and Maps)

// Классы LinkedHashSet и LinkedHashMap запоминают порядок ввода в них элементов.
// -> можно избежать кажущегося случайным порядка расположения элементов в хеш-таблице.

// По мере ввода элементов в таблицу
// они присоединяются к двунапраиленному связному списку
// рис. 9.11 (resources/_477/pic_9_11.JPG)

// Пример введения элементов в отображение типа LinkedHashMap
// в листинге 9.6, (ru/sectorsj/_471_map)
var staff = new LinkedHashMap<String, Employee>();
staff.put("144-25-5464", new Employee("Amy Lee"));
staff.put("567-24-2546", new Employee("Harry Hacker"));
staff.put("157-62-7935", new Employee("Gary Cooper"));
staff.put("456-62-5527", new Employee("Francesca Cruz"));

// вызывается итератор:
    staff.keySet().iterator()
// перечисляет ключи в следующем порядке:
// 144-25-5464
// 567-24-2546
// 157-62-7935
// 456-62-5527

// А вызываемый итератор:
    staff.values().iterator()
// перечисляет значения в таком порядке:
// Amy Lee
// Harry Hacker
// Gary Cooper
// Francesca Cruz

// Связное хеш-отображение позволяет сменить:
// порядок ввода -> порядок доступа
// для перебора eгo элементов.

// При каждом вызове метода get() или put()
// затрагиваемый элемент удаляется из его текущей позиции
// и вводится в конце связного списка элементов.

// Затрагивается только позиция в связном списке элементов, а не в группах хеш-таблицы.
// Элемент всегда остается на том месте, которое соответствует хеш-коду его ключа.

// Чтобы сконструировать такое хеш-отображение, можно сделать следующий вызов:
LinkedHashMap<K, V>(initialCapacity, loadFactor, true){
    // ...
};

// Порядок доступа удобен для реализации дисциплины кеширования
// с так называемым "наиболее давним использованием".

// Задача:
// Требуется сохранять в памяти часто используемые элементы,
// а менее часто используемые вводить из базы данных.
// Если нужный элемент не обнаруживается в таблице, а таблица уже почти заполнена,
// тогда можно получить итератор таблицы
// и удалить несколько первых элементов, которые он перечисляет.

// Эти элементы использовались очень давно.
// Данный процесс можно даже автоматизировать.

// Для этого достаточно образовать подкласс, производный от класса LinkedHashMap,
// и переопределить в нем следующий метод:
protected boolean removeEldestEntry(Map.Entry<K, V> eldest){
    // ...
}

// -> при вводе новою элемента будет удаляться самый старый (eldest) элемент всякий раз,
// когда данный метод возвратит логическое значение true.

// Пример:
// Максимальный размер кеша (кэша) поддерживается на уровне 100 элементов:
var cache = new LinkedHashMap<K,V>(128, 0,75F, true) {
    protected boolean removeEldestEntry(Map.Entry<K, V> eldest){
        return size() > 100;
    }
};

// С другой стороны, можно проанализировать элемент eldest,
// чтобы решить, стоит ли ею удалять.

// Например, можно проверить отметку времени, хранящуюся в данном элементе.


// page 479
// 9.4.6 Перечисляемые множества и отображения (Enumeration Sets and Maps)

// В классе EnumSet эффективнно реализуется множество элементов,
// относящихся к перечислимому типу.

// А поскольку у перечислимого типа ограниченное количество экземпляров,
// то класс EnumSet реализован внутренним образом в виде битовой последовательности.

// Каждый бит устанавливается, если соответствующее значение перечисления присутствует в множестве.

// У класса EnumSet отсутствуют открытые конструкторы.
// Для конструирования перечислимого множества
// используется статический фабричный метод.

// Для видоизменения перечислимого множества типа EnumSet
// можно использовать обычные методы из интерфейса Set.

enum Weekday {MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY};
EnumSet<Weekday> always = EnumSet.allOf(Weekday.class);
EnumSet<Weekday> never = EnumSet.noneOf(Weekday.class);
EnumSet<Weekday> workday = EnumSet.range(Weekday.MONDAY, Weekday.FRIDAY);
EnumSet<Weekday> mwf = EnumSet.of(Weekday.MONDAY, Weekday.WEDNESDAY, Weekday.FRIDAY);

// Класс EnumМap реализует отображение с ключами, относящимися к перечислимому типу.
// Такое отображение реализуется просто и эффективно в виде массива значений.

// Для этого достаточно указать тип ключа в конструкторе следующим образом:
var personInChange = new EnumMap<Weekday, Employee>(Weekday.class);
// тоже что и:
EnumМap<Weekday, Employee> personinCharge = new EnumМap<>(Weekday.class);

// В документации на прикладной интерфейс API класса EnumSet
// можно обнаружить необычные параметры вроде:
// Е extends Enum<E>
// -> это читается как: "Е относится к перечислимому типу".

// Перечислимые типы расширяют обобщенный класс Enum.
// Пример:
// Перечислимый тип Weekday расширяет класс Enum<Weekday>.

// page 479
// 9.4.7 Хэш-отображения идентичности (Identity Hash Maps)

// Класс IdentityHashMap предназначен для построения хеш-отображения идентичности,
// когда хеш-значения ключей должны вычисляться не методом hashCode(),
// а методом System.identityHashCode().

// Для вычисления хеш-кода, исходя из адреса объекта в памяти,
// в методе System.identityHashCode() используется метод Object.hashCode().

// Для сравнения объектов типа IdentityHashMap:
// применяется операция "==",
// а не метод equals().

// Разные объекты-ключи рассматриваются как отличающиеся,
// даже если они имеют одинаковое содержимое.

// Этот класс удобен для реализации алгоритмов обхода объектов (в т.ч. сериализации объектов),
// когда требуется отслеживать уже пройденные объекты.

// page 481
// 9.5 Представления и оболочки (Views and Wrappers)

// Глядя на:
// - рис. 9.4 (hortsmann_v_one/src/main/resources/_447)
// - рис. 9.5 (hortsmann_v_one/src/main/resources/_449)
// можно подумать, что излишне иметь так много интерфейсов и абстрактных классов
// для реализации столь скромного количества конкретных классов коллекций.
// Но эти рисунки не отражают всей картины.

// Используя представления, можно получить объекты других классов,
// реализующих интерфейс Collection или Мар.

// Характерным тому примером служит упоминавшийся ранее метод keySet() из классов отображений.

// На первый взгляд данный метод создает новое множество,
// заполняет его всеми ключами из отображения и возвращает его.

// -Х-> Метод keySet() возвращает объект класса,
// который реализует интерфейс Set
// и методы которого манипулируют исходным отображением.

// Такая коллекция называется представлением (View).

// У методики представлений имеется ряд полезных применений в каркасе коллекций.


// page 481
// 9.5.1 Мелкие коллекции (Small Collections)

// В версии Java 9 внедрены статические методы,
// выдающие множество (Set) или список (List) заданных элементов,
// а также отображение (Map) с заданными парами "ключ-значение".

// Получение списока и множества трех элементов:
List<String> names = List.of(of("Peter", "Paul", "Mary");
Set<Integer> numbers = Set.of(2, 3, 5);

// Для получения отображение, достаточно указать ключи и значения:
Map<String, Integer> scores = Map.of("Peter", 2, "Paul", 3, "Mary", 5);

// Элементы, ключи или значения не должны быть пустыми.

// В интерфейсах List и Set насчитывается 11-ть методов типа of(),
// принимающих от нуля до десяти аргументов,
// а также метод of() с переменным числом аргументов.

// Такое разнообразие методов типа of() предоставляется из соображений эффективности.

// В интерфейсе Мар невозможно предоставить вариант метода of() с переменным числом аргументов,
// поскольку типы аргументов сменяются на типы ключей и значений.

// Но имеется статический метод ofEntries(),
// принимающий произвольное количество объектов типа Мар.Entry<K, V>,
// которые можно создать с помощью статического метода entry(),
// как демонстрируется в следующем примере кода:
import static java.util.Map.*;
...
Map<String, Integer> scores = ofEntries(entry("Peter", 2),
                                        entry("Paul", 3),
                                        entry("Mary", 5));

// Методы of() и ofEntries() производят объекты тех классов,
// в которых каждому элементу коллекции предоставляется
// переменная экземпляра или поддержка со стороны массива.
// Объекты таких коллекций неизменяемы.

// Любая попытка изменить их содержимое приводит к исключению типа UnsupportedOperationException.

// Для того чтобы создать изменяемую коллекцию,
// монжо передать неизменяемую коллекцию
// конструктору соответствующего класса:
var names = new ArrayList<>(List.of("Peter", "Paul", "Mary"));

// В результате вызова метода:
Collections.nCopies(n, anObject)

// возвращается неизменяемый объект, реализующий интерфейс List и создающий впечатление,
// будто коллекция состоит из "n" элементов, каждый из которых оказывается объектом anObject.

// В результате приведенного ниже вызова создается список из 100 символьных строк "DEFAULT".
// Делается это с минимальными затратами оперативной памяти,
// поскольку соответствующий объект сохраняется лишь один раз.
   List<String> settings = Collections.nCopies(100, "DEFAULT");

// Методы тиnа of() были внедрены в версии Java 9.
// Прежде имелся статический метод Arrays.asList,
// возвращавший изменяемый сnисок постоянной длины.

// Это означает, что для такого списка можно вызвать метод set(),
// но не метод add() или remove().

// В классе Collections имеются также унаследованные методы:
// - Collections.emptySet()
// - Collections.singleton()

// В состав класса Collections входит ряд служебных методов,
// принимающих параметры или возвращающих значения, которые являются коллекциями.

// Класс Collections не следует путать с интерфейсом Collection.

// В стандартной библиотеке классов Java отсутствует класс Pair,
// -> некоторые программисты пользуются внутренним классом мар.Entry в качестве дешевой замены пары.

// До версии Java 9 пару приходилось строить с помощью операции:
    new Abstractмap.SimpleImmutableEntry<>(first, second)
// Начиная с версии Java 9 для этого достаточно сделать вызов:
    мар.entry(first, second).

// page 482
// 9.5.2 Поддиапазоны (Subranges)

// Для ряда коллекций можно сформировать представления поддиапазонов.

// Задача:
// Имеется список staff, из которого требуется извлечь с 10-гo по 19-й элемент.

// Решение:
// Чтобы получить представление этого поддиапазона элементов списка,
// достаточно вызвать метод subList():
List<EWmployee> group2 = staff.subList(10, 20);

// Первый индекс поддиапазона указывается включительно,
// а второй индекс - исключительно аналогично параметрам метода substring() из класса String.

// Над поддиапазонами можно выполнять любые операции,
// которые автоматически отражают целый список.

// Например, весь поддиапазон можно стереть приведенным ниже способом.
// В итоге элементы автоматически удаляются из списка staff,
// и поддиапазон group2 опорожняется.
group2.clear();     // Сокращение штатов

// Что касается отсортированных множеств и отображений,
// то для формирования из них поддиапазонов можно воспользоваться порядком сортировки,
// а не расположением элементов.

// Так, в интерфейсе SortedSet объявляются три метода:
SortedSet<E> subSet(E from, E to)
SortedSet<E> headSet(E to)
SortedSet<E> tailSet(E from)

// Эти методы возвращают подмножества всех элементов,
// которые оказываются больше или равными параметру from, но строго меньше параметра to.

// Для отсортированных отображений имеются аналогичные методы,
// возвращающие представления, состоящие из всех элементов,
// где ключи находятся в указанных пределах.
SortedMap<K, V> subMap(K from, K to)
SortedMap<K, V> headMap(K to)
SortedMap<K, V> tailMap(K from)

// В версии Java 6 был внедрен интерфейс NavigableSet,
// обеспечивающий более полный контроль операций над поддиапазонами.

// Указать включаемые границы поддиапазонов можно следующим образом:
NavigableSet<E> subSet(E from, boolean fromiIclusive, Е to, boolean toInclusive)
NavigableSet<E> headSet(E to, boolean toInclusive)
NavigableSet<E> tailSet(E from, boolean fromInclusive)


// page 483
// 9.5.3 Немодифиуируемые представления (Unmodifiable Views)

// В состав класса Collections входят методы,
// производящие немодифицируемые представления коллекций.
// Такие представления вводят динамическую проверку в существующие коллекции.

// Если в ходе такой проверки обнаруживается попьпка видоизменить коллекцию,
// генерируется исключение и коллекция остается невредимой.

// Получить немодифицируемые представления можно следующими 8ю методами:
Collections.unmodifiableCollection
Collections.unmodifiableList
Collections.unmodifiableSet
Collections.unmodifiableSortedSet
Collections.unmodifiableNavigableSet
Collections.unmodifiableMap
Collections.unmodifiableSortedMap
Collections.unmodifiableNavigableMap

// Каждый их этих методов определен для работы с интерфейсом.
// Метод Collections.unmodifiableList() - работает с классом ArrayList,
//                                        LinkedList или любым другим,
//                                        реализующим интерфейс List.

// Задача:
// Некоторой части прикладной программы
// требуется предоставить возможность просматривать, но не изменять содержимое коллекции:
var staff = new LinkedList<String>();
...
lookAt(Collections.unmodifiableList(staff));

// Метод Collections.unmodifiaЬleList() - возвращает объект класса, реализующею интерфейс List.
// Его методы доступа извлекают значения из коллекции staff.
// Метод lookAt() может вызывать все методы из интерфейса List, а не только методы доступа.

// Все методы, изменяющие коллекцию, например add(),
// переопределены таким образом,
// чтобы немедленно генерировать исключение типа UnsupportedOperationException
// вместо передачи вызова базовой коллекции.

// Немодифицируемое представление не делает саму коллекцию немодифицируемой.
// Коллекцию можно по-прежнему видоизменить по ее исходной ссылке (в данном случае - staff).
// А модифицирующие методы можно вызывать для отдельных элементов коллекции.

// Представления заключают в оболочку интерфейс, а не конкретный объект коллекции,
// -> доступ требуется лишь к тем методам, которые определены в интерфейсе.

// В состав класса LinkedList входят служебные методы addFirst() и addLast(),
// не являющиеся частью интерфейса List,
// но они недоступны через немодифицируемое представление.

// Методы:
    unmodifiableCollection()
    synchronizedCollection()
    checkedCollection()
// возвращает коллекцию, в которой метод equals()
// не вызывает одноименный метод из базовой коллекции.

// Вместо этого он наследует метод equals() из класса Object,
// который проверяет объекты на равенство.

// Если просто преобразовать множество или список в коллекцию,
// то проверить ее содержимое на равенство не удастся.
// Представление действует подобным образом,
// -> проверка на равенство четко определена на данном уровне иерархии.

// Аналогичным образом в представлениях интерпретируется и метод hashCode().

// Но в классах объектов, возвращаемых методами:
    unmodifiableSet()
    inmodifiableList()
// используются методы equals() и hashCode() из базовой коллекции.


// page 484
// 9.5.4 Синхронизированние представления (Synchronized Views)

// Если обращение к коллекции происходит из нескольких потоков исполнения,
// то нужно каким-то образом исключить ее непреднамеренное повреждение.

// Произойдет фатальная ошибка:
// Если в одном потоке исполнения предпринята попытка
// ввести элемент в хеш-таблицу в тот момент,
// когда в другом повторно хешируются ее элементы.

// Вместо реализации потокобезопасных классов разработчики библиотеки коллекций
// воспользовались механизмом представлений, чтобы сделать потокобезопасными обычные коллекции.

// Например, статический метод synchronizedMap() из класса Collections,
// может превратить любое отображение в объект типа Мар
// с синхронизированными методами доступа:
    var map = Collections.syncronizedMap(new HashMap<String, Employee>();

// После этого к объекту "map" можно обращаться из нескольких потоков исполнения.
// Такие методы, как:
// - get()
// - put()
// сериализованы, это означает что каждый вызов метода,
// должен полностью завершаться до того, как другой поток сможет его вызвать.

// Синхронизированный доступ к структурам данных (глава 12).


// page 485
// 9.5.5 Проверяемые представления (Checked Views)

// Проверяемые представления предназначены для поддержки отладки ошибок,
// сопутствующих применению обобщенных типов в прикладном коде.

// Существует возможность незаконно внедрить
// в обобщенную коллекцию элементы неверного типа (глава 8).

// Здесь ошибочный вызов метода add() не обнаруживается:
    var strings = new ArrayList<String>();
    ArrayList rawList = strings;    // ради совместимости с унаследованным кодом
                                    // при компиляции этой строки кода выдается только предупреждение,
                                    // но не ошибка

    rawList.add(new Date());        // теперь символьные строки содержат объект типа Date!

// Вместо этого возникнет исключение, когда при последующем вызове метода get()
// будет сделана попытка привести результат к типу String.

// Проверяемое представление позволяет обнаружить этот недостаток в коде.
// Для этого сначала определяется безопасный список:
    List<String> safeStrings = Collections.checkedList(strings, String.class);

// Затем в методе представления add() проверяется принадлежность объекта,
// вводимого в коллекцию, заданному классу.

// Если обнаружится несоответствие,
// то немедленно сгенерируется исключение типа ClassCastException:

    ArrayList rawList = safeStrings;
    rawList.add(new Date());    // проверяемый список генерирует исключение типа ClassCastException

// Преимущество такого подхода:
// ошибка произойдет в том месте кода,
// где ее можно обнаружить и обработать.

// Проверяемые представления ограничиваются динамическими проверками,
// которые способна выполнить виртуальная машина.

// Eсли имеется списочный массив типа ArrayList<Pair<String>>,
// его нельзя защитить от ввода элемента типа Pair<Date>,
// поскольку виртуальной машине ничего неизвестно о единственном базовом классе Pair.


// page 485
// 9.5.6 О необязательных операциях (Optional Operations)

// Обычно на представление накладывается определенное ограничение:
// - может быть доступно только для чтения,
// - может не допускать изменений размера
// - может поддерживать удаление
// но запрещать ввод элементов, как это имеет место для представления ключей в отображении.

// Ограниченное таким образом представление
// генерирует исключение типа UnsupportedOperationException,
// если попытаться выполнить неразрешенную операцию.

// В документации на прикладной интерфейс API
// для интерфейсов коллекций и итераторов
// многие методы описаны как "необязательные операции"(optional operations).

// На первый взгляд, это противоречит самому понятию интерфейса.
// Вопрос:
// Разве не в том назначение интерфейсов, чтобы объявлять методы, которые класс обязан реализовать?
// Ответ:
// Такая организация неудовлетворительна с теоретической точки зрения.

// Возможно, лучше  разработать отдельные интерфейсы
// для представлений "только для чтения"
// и представлений, которые не могут изменять размер коллекции.

// Но это привело бы к значительному увеличению количества интерфейсов,
// что разработчики библиотеки сочли неприемлемым.

// Вопрос:
// Следует ли распространять методику "необязательных" методов на собственные проекты?
// Ответ:
// Вряд ли.

// Даже если коллекции используются часто,
// стиль программирования для их реализации нетипичен для других предметных областей.

// Разработчикам библиотеки классов коллекций
// пришлось удовлетворить ряд жестких и противоречивых требований.

// Пользователи хотели бы, чтобы библиотеку было легко усвоить и удобно использовать,
// чтобы она была полностью обобщенной,
// защищенной от неумелого обращения
// такой же эффективной, как и алгоритмы, разработанные вручную.

// Удовлетворить всем этим требованиям одновременно
// или даже приблизиться к этой цели практически невозможно.

// На практике при программировании на Java
// можно редко столкнуться с таким суровым рядом ограничений.

// Тем не менее нужно быть готовым находить решения,
// которые не опираются на такую крайнюю меру,
// как применение "необязательных" (Optional) интерфейсных операций.


// page 489
// 9.6 Алгоритмы

// Помимо реализации классов коллекций,
// в каркасе коллекций Java предоставляется целый ряд полезных алгоритмов.

// В последующих разделах поясняется, как пользоваться этими алгоритмами
// и составлять собственные алгоритмы, вполне пригодные для каркаса коллекций.


// page 490
// 9.6.1 Почему именно обобшенные алгоритмы (Why Generic Algorithms?)

// Обобщенные интерфейсы коллекций дают огромное преимущество:
//      конкретный алгоритм достаточно реализовать лишь один раз.

// В качестве примера простой алгоритм вычисления наибольшего элемента в коллекции.
// Традиционно он реализуется в цикле.

// Как обнаружить самый большой элемент в массиве (Array) традиционным способом:
if (a.length == 0) throw new NoSuchElementException();
T largest = a[0];
for (int i = 1; i < i.length; i++){
    if (largest.compareTo(a[i]) < 0) {
        largest = a[i];
    }
}

// Чтобы найти наибольший элемент в списочном массиве(ArrayList), придется написать код немного иначе:
if (v.size() == 0) throw new NoSuchElementException();
T largest = v.get(0);
for (int i = 1; i < v.size(); i++) {
    if (largest.compareTo(v.get(i)) < 0) {
        largest = v.get(i);
    }
}

// А как насчет связного списка?
// Для связного списка не существует эффективного произвольного доступа (RandomAccess),
// но можно воспользоваться итератором:
if (l.isEmpty()) throw new NoSuchElementException();
Iterator<T> iter = l.iterator();
T largest = iter.next();
while(iter.hasNext()) {
    T next = iter.next();
    if (largest.compateTo(next) < 0) {
        largest = next;
    }
}

// Все эти циклы писать довольно утомительно, а кроме того, они чреваты ошибками.

// Нужно постоянно проверять:
// - не допущена ли ошибка выхода за допустимые пределы
// - правильно ли будут выполняться эти циклы с пустыми коллекциями
// - что насчет контейнеров с одним элементом

// Вряд ли захочется тестировать и отлаживать такой код каждый раз,
// но и желания реализовывать уйму таких методов не возникнет:
    static <T extends Comparable> T max(T[] a)
    static <T extends Comparable> T max(ArrayList<T> v)
    static <T extends Comparable> T max(LinkedList<T> l)

// Здесь на помощь приходят интерфейсы коллекций.
// Подумайте о "минимальном" интерфейсе коллекции,
// который понадобится для эффективной реализации алгоритма.

// Произвольный доступ с помощью методов get() и set() стоит рангом выше, чем простая итерация.

// Как следует из приведенного выше примера:
// - вычисления наибольшего элемента в связном списке(LinkedList),
// произвольный доступ совсем не обязателен для решения подобной задачи.

// Вычисление максимума может быть выполнено путем простой итерации по элементам коллекции.
// -> метод max() можно воплотить в коде таким образом,
// чтобы он принимал объект любого класса, реализующего интерфейс Collection:
    public static <T extends Comparable> T max(Collection<T> c) {
        if (c.isEmpty()) throw new NoSuchElementException();
        Iterator<T> iter = c.iterator();
        T largest = iter.next();

        while (iter.hasNext()) {
            T next = iter.next();
            if (largest.compareTo(next) < 0) {
                largest = next;
            }
        }
        return largest;
    }

// Теперь единственным обобщенным методом можно вычислить максимум в связном списке,
// в списочном или простом массиве.

// Эnо весьма эффективный алгоритм.
// На самом деле в стандартной библиотеке С++ имеются десятки полезных алгоритмов,
// каждый из которых оперирует обобщенной коллекцией.

// Библиотека Java не настолько богата, но в ней все же имеются самые основные алгоритмы:
//  - сортировки
//  - двоичного поиска
//  - и др. служебные алгоритмы