// For notes
https://horstmann.com/corejava/index.html

// Предисловие                                                      - 13
// Глава 1. Потоки данных                                           - 19
// Глава 2. Ввод и вывод                                            - 71
// Глава 3. XML                                                     - 163
// Глава 4. Работа в сети                                           - 235
// Глава 5. Работа с базами данных                                  - 287
// Глава 6. Прикладной интерфейс API даты и времени                 - 353
// Глава 7. Интернационализация                                     - 377
// Глава 8. Написание сценариев, компиляция и обработка аннотаций   - 435
// Глава 9. Модульная система на платформе Java                     - 493
// Глава 10. Безопасность                                           - 521
// Глава 11. Расширенные средства Swing и графика                   - 601
// Глава 12. Платформенно-ориентированные методы                    - 787
// Предметный указатель                                             - 849

// Глава 1 Библиотека потоков данных в Java,
//           придающая современные черты обработке данных благодаря тому,
//           что программисту достаточно указать, что именно ему требуется,
//           не вдаваясь в подробности, как получить желаемый результат.
//           Такой подход позволяет уделить в библиотеке потоков данных
//           основное внимание оптимальной эволюционной стратегии,
//           которая дает особые преимущества при оптимизации параллельных вычислений.

// Глава 2 Организация ввода-вывода. В языке Java весь ввод-вывод
//         осуществляется через так называемые потоки ввода-вывода
//         (не путать с потоками данных, рассматриваемыми в главе 1).
//         Позволяют единообразно обмениваться данными между различными источниками,
//         включая файлы, сетевые соединения и блоки памяти.
//         Приводится подробное описание классов чтения и записи в потоки ввода-вывода,
//         упрощающие обработку данных в Юникоде.
//         Рассматривается внутренний механизм сериализации объектов,
//         который делает простым и удобным сохранение и загрузку объектов.
//         Обсуждаются регулярные выражения, а также особенности манипулирования файлами и путями к ним.
//         Будут представлены усовершенствования системы ввода-вывода в последних версиях Java.

// Глава 3 XML. Каким образом осуществляется синтаксический анализ ХМL-файлов,
//         формируется ХМL-разметка и выполняются ХSL-преобразования.
//         Демонстрируется разметка компоновки Swing-фopмы в формате XML.
//         Рассматривается прикладной интерфейс API XPath,
//         значительно упрощающий поиск мелких подробностей в больших объемах данных формата XML.

// Глава 4 Прикладной интерфейс API для работы в сети.
//         В языке Java чрезвычайно просто решаются сложные задачи сетевого программирования.
//         Как устанавливаются сетевые соединения с серверами,
//         реализуются собственные серверы и организуется связь по сетевому протоколу HTTP.
//         Новый HTTP-клиент.

// Глава 5 Программирование баз данных.
//         Основное внимание уделяется JDBC - прикладному интерфейсу
//         для организации доступа к базам данных из приложений на Java,
//         который позволяет прикладным программам на Java
//         устанавливать связь с реляционными базами данных.
//         Полезные программы для выполнения рутинных операций с настоящими базами данных,
//         с применением только самых основных средств интерфейса JDBC.
//         Краткие сведения об интерфейсе JNDI (Java Naming and Directory Interface)
//         - интерфейс именования и каталогов Java
//         и протоколе LDAP (Lightweight Directory Access Protocol)
//         упрощенный протокол доступа к каталогам).

// Глава 6 Как преодолевать трудности организации календарей и оперирования часовыми поясами,
//         используя новую библиотеку даты и времени.
//         Ранее в библиотеках Java были предприняты
//         две безуспешные попытки организовать обработку даты и времени.
//         Третья попытка была успешно предпринята в версии Java 8.

// Глава 7 Вопросы интернационализации, важность которой, будет со временем только возрастать.
//         Java относится к тем немногочисленным языкам программирования,
//         где с самого начала предусматривалась возможность обработки данных в Юникоде,
//         но поддержка интернационализации в Java этим не ограничивается.
//         Интернационализация прикладных программ на Java
//         позволяет сделать их независимыми не только от платформы, но и от страны применения.
//         Как написать прикладную программу
//         для расчета времени выхода на пенсию с выбором английского, немецкого или китайского языка.

// Глава 8 Три разные методики обработки исходного кода.
//         Прикладные интерфейсы API для сценариев и компилятора дают возможность
//         вызывать в программе на Java код, написанный на каком-нибудь языке сценариев,
//         например JavaScript или Groovy, и компилировать, его в код Java.
//         Аннотации позволяют вводить в программу на Java произвольную информацию
//         (иногда еще называемую метаданными).
//         Каким образом обработчики аннотаций собирают аннотации на уровне источника
//         и на уровне файлов классов и как с помощью аннотаций оказывается воздействие
//         на поведение классов во время выполнения.
//         Аннотации выгодно использовать вместе с подходящими инструментальными средствами,
//         и материал этой главы поможет читателю научиться выбирать
//         именно те средства обработки аннотаций,
//         которые в наибольшей степени отвечают его потребностям.

// Глава 9 Модульная система на платформе java, внедренная в версии Java 9
//         для того, чтобы способствовать нормальной эволюции самой платформы и базовых библиотек Java.
//         Эта модульная система обеспечивает инкапсуляцию пакетов
//         и предоставляет механизм для описания требований к модулям.
//         Свойства модулей, на основании которых можно решить,
//         стоит ли применять модули в ваших приложениях.
//         Даже если решите не применять их, все равно должны знать новые правила модуляризации,
//         чтобы взаимодействовать с платформой Java и другими библиотеками, имеющими модульную организацию.

// Глава 10 Модель безопасности Java.
//          Платформа Java с самого начала разрабатывалась с учетом безопасности.
//          Объясняется, что именно позволяет ей обеспечивать безопасность.
//          Демонстрируется, как создавать свои собственные загрузчики классов
//          и диспетчеры защиты для специальных приложений.
//          Прикладной интерфейс API для безопасности,
//          который позволяет оснащать приложения важными средствами
//          вроде механизма цифровых подписей сообщений и кода,
//          а также авторизации, аутентификации и шифрования.
//          Примеров, в которых применяются такие алгоритмы шифрования, как AES и RSA.

// Глава 11 Весь материал по библиотеке Swing, не вошедший в первый том данной книги.
//          Описание важных и сложных компонентов деревьев и таблиц.
//          Прикладной интерфейс Java 2D API
//          для воспроизведения реалистичных графических изображений и спецэффектов.
//          Функциональные средства для формирования изображений на сервере.

// Глава 12 Платформенно-ориентированные методы, которые позволяют вызывать функции,
//          специально написанные для конкретной платформы, например Microsoft Windows.
//          Очевидно, что данное языковое средство является спорным,
//          ведь применение платформенно-ориентированных методов
//          сводит на нет все межплатформенные преимущества java.
//          Серьезно занимающийся разработкой на Java приложений для конкретных платформ,
//          должен знать и уметь пользоваться платформенно-ориентированными средствами.
//          Ведь иногда возникают ситуации, когда требуется обращаться к
//          прикладному интерфейсу API операционной системы целевой платформы
//          для взаимодействия с устройствами или службами,
//          которые не поддерживаются на платформе Java.
//          Организация доступа из программы на Java к прикладному интерфейсу API
//          системного реестра Windows.

----------------------------------------------------------------------------------------------------




// page 287
// 5 Глава: Работа с базами данных (Database Programming)

// 5.1  Структура JDBC (The Design of JDBC)
// 5.2  Язык SQL (The Structured Query Language)
// 5.3  Конфигурирование JDBC (JDBC Configuration)
// 5.4  Работа с операторами JDBC (Working with JDBC Statements)
// 5.5  Выполнение запросов (Query Execution)
// 5.6  Прокручиваемые и обновляемые результирующие наборы (Scrollable and Updatable Result Sets)
// 5.7  Наборы строк (Row Sets)
// 5.8  Метаданные (Metadata)
// 5.9  Транзакции (Transactions)
//      Расширенные типы данных SQL
// 5.10 Управление подключением к базам данных в веб- и корпоративных приложениях
//      (Connection Management in Web and Enterprise Applications)


// page 288
// 5.1 Структура JDBC (The Design of JDBC)

// Создатели Java с самого начала осознавали потенциальные преимущества данного языка
// для работы с базами данных.
// С 1995 года они начали работать над расширением стандартной библиотеки Java
// для организации доступа к базам данных средствами SQL.

// Сначала они попробовали создать такие расширения Java,
// которые позволили бы осуществлять доступ
// к произвольной базе данных только средствами Java,
// но очень скоро убедились в бесперспективности такого подхода,
// т.к. для доступа к базам данных применялись самые разные протоколы.

// Поставщики программного обеспечения баз данных
// были весьма заинтересованы в разработке на Java стандартного сетевого протокола
// для доступа к базам данных, при условии,
// что за основу будет принят их собственный сетевой протокол.

// В конечном счете:
// - поставщики баз данных
// - инструментальных средств для доступа к ним
// сошлись на том, что лучше предоставить прикладной интерфейс API только на Java
// для доступа к базам данных средствами SQL, а также диспетчер драйверов,
// который позволил бы подключать к базам драйверы независимых производителей.

// Такой подход позволял поставщикам баз данных создавать собственные драйверы,
// которые подключались бы с помощью данного диспетчера.

// Предполагалось, что это будет простой механизм регистрации сторонних драйверов.

// Подобная организация прикладного интерфейса JDBC
// основана на весьма удачной модели интерфейса ODBC,
// разработанного в корпорации Microsoft.

// В основу интерфейсов JDBC и ODBC положен общий принцип:
// программы, написанные в соответствии с требованиями прикладного интерфейса API,
// способны взаимодействовать с диспетчером драйверов JDBC,
// который, использует подключаемые драйверы для обращения к базе данных.

// Это означает, что для работы с базами данных в прикладных программах
// достаточно пользоваться средствами JDBC API.


// page 288
// 5.1.1 Типы драйверов JDBC (JDBC Driver Types)

// Каждый драйвер JDBC относится к одному из перечисленных типов:

// Драйвер:
// Тип 1: Преобразует интерфейс JDBC в ODBC.
//        Для взаимодействия с базой данных использует драйвер ODBC.
//        Один такой драйвер был включен в первые версии Java под названием мост JDBC/ODBC.
//        Но для его применения требуется установить и настроить соответствующим образом драйвер ODBC.
//        В первом выпуске JDBC этот мост предполагалось использовать только для тестирования,
//        а не для применения в рабочих программах.
//        В настоящее время уже имеется достаточное количество более удачных драйверов,
//        поэтому пользоваться мостом JDBC/ODBC не рекомендуется.

// Тип 2: Написан частично на Java и отчасти использует платформенно-ориентированный код
//        для взаимодействия с клиентским прикладным интерфейсом API базы данных.
//        Для применения такого драйвера, помимо библиотеки Java,
//        на стороне клиента необходимо установить код, специфический для конкретной платформы.

// Тип 3: Разрабатывается только на основе клиентской библиотеки Java,
//        в которой используется независимый от базы данных протокол передачи запросов базы данных на сервер.
//        Этот протокол приводит запросы базы данных в соответствие с характерным для нее протоколом.
//        Развертывание прикладных программ значительно упрощается благодаря тому,
//        что код, зависящий от конкретной платформы, находится только на сервере.

// Тип 4: Представляет собой библиотеку, написанную только на Java,
//        для приведения запросов JDBC в соответствие с протоколом конкретной базы данных.

// Спецификация прикладного интерфейса JDBC доступна для загрузки по адресу:
// https://jcp.org/en/jsr/detail?id=221

// Большинство поставщиков баз данных предоставляют драйверы 3 или 4 типа.
// Целый ряд сторонних производителей специализируется на создании драйверов,
// которые позволяют добиться более полного соответствия принятым стандартам,
// поддерживают большее количество платформ,
// обладают более высокой производительностью или надежностью, чем драйверы,
// предлагаемые поставщиками баз данных.

// Основные цели прикладного интерфейса JDBC:
// 1. Разработчики пишут программы на Java, пользуясь для доступа к базам данных
//    стандартными средствами языка SQL или его специализированными расширениями,
//    следуя только соглашениям, принятым в Java.

// 2. Поставщики баз данных и инструментальных средств к ним
//    предоставляют драйверы только низкого уровня.
//    Это дает им возможность оптимизировать драйверы под свою конкретную продукцию.


// page 290
// 5.1.2 Типичные примеры применения JDBC (Typical Uses of JDBC)

// Согласно традиционной модели "клиент-сервер" графический пользовательский интерфейс (ГПИ)
// реализуется на стороне клиента, а базы данных располагается на стороне сервера (рис. 5.1)
// (resources/_290/pic_5_1.JPG)

// В этом случае драйвер JDBC развертывается на стороне клиента.

// В настоящее время существует тенденция по переходу:
// от архитектуры "клиент-сервер"
// к трехуровневой модели (three-tier)
//  или
// n-уровневой модели

// В трехуровневой модели:
// клиент не формирует обращения к базе данных.
// Он обращается к средствам промежуточного уровня на сервере,
// который, выполняет запросы к базе данных.

// Трехуровневая модель, обладает преимуществами.
// Она отделяет:
// 1. визуальное представление (на клиентском компьютере)
// 2. бизнес-логику (на промежуточном уровне)
// 3. исходных данных (хранящихся в базе данных).

// -> Становится возможным доступ к тем же самым данным
// по одинаковым бизнес-правилам со стороны разнотипных клиентов,
// в том числе:
//  - прикладных программ на java
//  - веб-браузеров
//  - приложений для мобильных устройств

// Взаимодействие между клиентом и промежуточным уровнем
// может быть реализовано по сетевому протоколу НТТР.

// JDBC - прикладной интерфейс, который служит для управления взаимодействием между:
// - промежуточным уровнем
// - серверной базой данных

// На рис. 5.2 (resources/_290/pic_5_2.JPG)
// схематически показана основная архитектура трехуровневой модели.


// page 291
// 5.2 Язык SQL (Structured Query Language)

// Прикладной интерфейс JDBC позволяет взаимодействовать с базами данных посредством языка SQL,
// который, образует интерфейс для большинства современных реляционных баз данных.

// Настольные базы данных предоставляют графический интерфейс,
// который дает пользователям возможность непосредственно манипулировать данными,
// но доступ к серверным базам данных возможен только средствами языка SQL.

// Пакет JDBC можно рассматривать лишь как прикладной интерфейс API
// для взаимодействия с операторами языка SQL с целью получить доступ к базам данных.

// Краткое описание языка SQL.
// Если не приходилось раньше иметь дело с SQL, то сведений,
// представленных в этом разделе, может оказаться недостаточно.

// Для более досконального изучения основ SQL
// можно порекомендовать книгу:
// Learning SQL Алана Болью (Alan Beaulieu; издательство O'Reilly, 2009 г.)
//      или
// Learn SQL The Hard Way Зеда А. Шоу (Zed А. Shaw),
//оперативно доступную в электронном виде для заказа по адресу:
// http://sql.learncodethehardway.org/

// База данных представляет собой набор именованных таблиц со строками и столбцами.
// Каждый столбец имеет свое имя, а данные хранятся в строках.
// В качестве примера базы данных здесь и далее рассматривается ряд таблиц
// с описаниями библиотеки классических книг по вычислительной технике (табл. 5.1-5.4).

// Таблица 5.1. Таблица "Authors"
// |------------|-----------|--------------|
// | Author_ID  |    Name   |     Fname    |
// |------------|-----------|--------------|
// | ALEX       | Alexander | Christopher  |
// | ВRОО       | Brooks    | Frederick Р. |
// |------------|-----------|--------------|

// Таблица 5.2. Таблица "Books"
// |----------------------------------------------------|---------------|--------------|-------|
// |                        Title                       |      ISBN     | Publisher_ID | Price |
// |----------------------------------------------------|---------------|--------------|-------|
// | А Guide to the SQL Standard                        | 0-201-96426-0 |     0201     | 47.95 |
// | А Pattern Language: Towns, Buildings, Construction | 0-19-501919-9 |     019      | 65.00 |
// | ...                                                | ...           |     ...      | ...   |
// |----------------------------------------------------|---------------|--------------|-------|

// Таблица 5.3. Таблица "BooksAuthors"
// |---------------|-----------|--------|
// |      ISBN     | Author_ID | Seq_No |
// |---------------|-----------|--------|
// | 0-201-96426-0 | DATE      |   1    |
// | 0-201-96426-0 | DARW      |   2    |
// | 0-19-501919-9 | ALEX      |   1    |
// | ...           | ...       |  ...   |
// |---------------|-----------|--------|

// Таблица 5.4. Таблица "Publishers"
// |--------------|-------------------|---------------|
// | Publisher_ID |        Name       |      URL      |
// |--------------|-------------------|---------------|
// | 0201         | Addison-Wesley    | www.aw-bc.com |
// | 0407         | John Wiley & Sons | www.wiley.com |
// | ...          | ...               | ...           |
// |--------------|-------------------|---------------|

// на рис. 5.3 (resources/_293/pic_5_3.JPG) - представлена таблица Books
// на рис. 5.4 (resources/_293/pic_5_4.JPG) - представлен результат соединения таблиц Books и Publishers

// Обе таблицы содержат идентификатор издателя.
// При соединении таблиц по этому идентификатору получается результат запроса в виде таблицы,
// содержащей данные из обеих исходных таблиц.

// В каждой строке этой таблицы содержатся сведения о:
// - книге
// - название
// - адрес веб-сайта издательства

// Данные с названием книги и адресом веб-сайта неоднократно дублируются,
// поскольку в результирующей таблице оказывается несколько строк,
// относящихся к одному и тому же издательству.

// Объяснение:
// В данном примере мы имеем четыре таблицы:
// - "Authors"
// - "Books"
// - "BooksAuthors"
// - "Publishers"

// Эти таблицы представляют собой реляционную базу данных,
// где информация о книгах, авторах и издателях хранится в отдельных таблицах.

// Таблица "Authors":
// содержит информацию об авторах,
// включая их идентификатор (Author_ID), имя (Name) и полное имя (Fname).

// Таблица "Books":
// содержит информацию о книгах,
// включая название (Title), ISBN (уникальный идентификатор книги),
// идентификатор издателя (Publisher_ID) и цену (Price).

// Таблица "BooksAuthors":
// является связующей таблицей,
// которая устанавливает связь между книгами и авторами.
// Каждая строка в этой таблице представляет собой связь между:
// - книгой (идентифицируемой по ISBN)
// - автором (идентифицируемым по Author_ID).
// Поле Seq_No указывает порядок авторов для каждой книги.

// Таблица "Publishers":
// содержит информацию об издателях, включая их идентификатор (Publisher_ID),
// название (Name) и URL-адрес веб-страницы (URL).

// Рисунок 5.3 показывает представление таблицы "Books",
// которое содержит информацию о книгах.
// Однако, в этом представлении только идентификатор издателя (Publisher_ID),
// но нет его названия и URL-адреса.

// Можно объединить таблицы "Books" и "Publishers" по полю Publisher_ID,
// чтобы получить более полную информацию.
// Это называется операцией соединения (join) в реляционных базах данных.

// Результат объединения таблиц "Books" и "Publishers" показан на рисунке 5.4.
// В этом результате каждая строка содержит информацию о книге:
// - название
// - ISBN
// - цену
// вместе с соответствующим названием издателя и его URL-адресом.

// При объединении таблиц возможно дублирование информации
// об издателях в результирующем наборе данных.
// Это происходит потому, что у одного издателя может быть несколько книг.
// В таких случаях информация об издателе (название и URL-адрес)
// будет повторяться для каждой книги этого издателя.

// Объединение таблиц является мощным инструментом в реляционных базах данных,
// который позволяет связывать данные из разных таблиц
// и получать более полную и осмысленную информацию.

// Это позволяет эффективно хранить данные в нормализованной форме (разделенными по таблицам)
// и при необходимости объединять их для получения желаемого результата.

// Преимущество соединения таблиц заключается в том,
// что при этом удается избежать нежелательного дублирования данных.

// Например, в простейшей структуре баз данных таблица "Books"
// может содержать столбцы с названием и адресом веб-сайта издательства.
// Но в таком случае данные будут дублироваться уже не только в результате запроса,
// но и в самой базе данных.

// При изменении адреса веб-сайта придется также изменить эти данные во всех записях в базе данных.
// При выполнении столь трудоемкой задачи могут легко возникнуть, ошибки.

// В реляционной модели данные распределяются среди нескольких таблиц таким образом,
// чтобы они не дублировались без особой надобности.

// Например, адрес веб-сайта каждого издательства хранится в единственном экземпляре
// в таблице с данными об издательствах.
// При необходимости данные из разных таблиц нетрудно соединить, в результате запроса.

// На рис. 5.3 и 5.4 показано графическое инструментальное средство,
// предназначенное для просмотра и связывания таблиц.
// Многие поставщики программного обеспечения предлагают разнообразные диалоговые инструментальные средства
// для создания запросов путем манипулирования столбцами и ввода данных в готовые формы.

// Они называются инструментальными средствами составления "запросов по образцу" (QBE) (query by example).
// А при использовании SQL запрос создается в текстовом виде в строгом соответствии
// с синтаксисом этого языка, как показано ниже:
    SELECT Books.Title Books.Publisher_Id, Books.Price, Publishers.Name, Publishers.URL
    FROM Books, Publishers
    WHERE Books.Publisher_Id = Publisher.Publisher_Id

// Здесь описываются основные способы создания подобных запросов базы данных.
// Читатели, знакомые с SQL, могут пропустить этот материал.

// Ключевые слова SQL принято вводить прописными буквами,
// хотя это правило не является обязательным.

// SELECT - оператор, может применяться в самых разных целях,
// в т.ч. для выбора всех элементов из таблицы Books по следующему запросу:
    SELECT * FROM Books;

// Предложение FROM обязательно указывается в каждом операторе SELECT.
// В этом предложении базе данных сообщается о тех таблицах,
// в которых требуется выполнить поиск данных.

// В операторе SELECT можно указать любые требующиеся столбцы следующим образом:
    SELECT ISBN, Price, Title
    FROM Books;

// Выбор строк можно ограничить с помощью условия, указываемого в предложении WHERE:
    SELECT ISBN, Price, Title
    FROM Books
    WHERE Price <= 29.95

// Для сравнения в SQL используются операции:
//  = и <>      // нужно использовать в SQL
//  == или !=   // не нужно использовать в SQL
как при программировании на Java.

// Некоторые поставщики баз данных используют операцию "!=" для обозначения сравнения,
// но такое обозначение не соответствует стандарту SQL, поэтому пользоваться ей не рекомендуется.

// В предложении WHERE может присутствовать операция LIKE
// для сопоставления с заданным шаблоном.
// Но вместо символов подстановки:
// "*"
// "?"
// В SQL также употребляются знаки:
// "%" - обозначает любое количество символов
// "_" - обозначает один символ

// Задача:
// Запрос на выборку книг, в названиях которых отсутствует такое слово, как UNIX или Linux:
    SELECT ISBN, Price, Title
    FROM Books
    WHERE Title NOT LIKE '%n_x';

// В запросах базы данных символьные строки заключаются в одиночные, а не в двойные кавычки.
// Одиночная кавычка в символьной строке обозначается парой одиночных кавычек,
// как в приведенном ниже примере запроса на поиск всех книг,
// в названиях которых содержится одиночная кавычка.
    SELECT Title
    FROM Books
    WHERE Title LIKE '%''%'

// Чтобы выбрать данные из нескольких таблиц, их нужно перечислить в следующем порядке:
    SELECT * FROM Books, Publishers

// Без предложения WHERE такой запрос не представляет большого интереса,
// поскольку по нему получаются все сочетания строк из обеих таблиц.
// В данном случае:
// таблица Books      - содержит 20 строк
// таблица Publishers - содержит 8 строк

// -> результат выполнения такого запроса будет содержать 20 х 8 строк
// с большим количеством дублирующихся данных.

// Задача:
// Требуется найти только те книги, которые выпущены издательствами,
// перечисленными в таблице Publishers.
// Для обнаружения такого соответствия книг издательствам
// можно составить приведенный ниже запрос:
    SELECT * FROM Books, Publishers
    WHERE Books.Publishers_Id = Publishers.Publishers_Id

// Результат выполнения этого запроса содержит 20 строк,
// т.е. по одной строке на каждую книгу,
// поскольку на каждую книгу в таблице Publishers приходится лишь одно издательство.

// Если в запросе указано несколько таблиц,
// то в двух разных местах может упоминаться одно и то же имя столбца,
// как в показанном выше примере
// столбец Publisher_Id из таблицы Books и аналогичный столбец
// Publisher Id из таблицы Publishers.

// Во избежание неоднозначной интерпретации имен столбцов
// их следует предварять префиксом с именем таблицы:
// Books.Publisher_Id.

// Языковыми средствами SQL можно пользоваться и для изменения информации в базе данных.
// Задача:
// Требуется снизить на 5 долларов текущую цену всех книг,
// в названиях которых содержится подстрока "С++".
// С этой целью можно составить следующий запрос:
    UPDATE Books
    SET Price = Price - 5.00
    WHERE Title LIKE '%C++%'

// Для удаления всех книг по С++ понадобится оператор DELETE,
// как показано в приведенном ниже примере запроса.
    DELETE FROM Books
    WHERE Title LIKE '%C++%'

// В языке SQL предусмотрены также встроенные функции для:
// - вычисления средних значений,
// - поиска максимальных и минимальных значений в столбце
// - и многое другое.

// INSERT - оператор для ввода новых данных в таблицу:
    INSERT INTO Books
    VALUES ('А Guide to the SQL Standard', '0-201-96426-0', '0201', 47.95)

// Для ввода каждой строки в таблицу приходится выполнять отдельный оператор INSERT.
// Но прежде чем составлять запросы, изменять и вводить данные,
// необходимо предоставить место для их хранения, т.е. создать таблицу.

// CREATE TABLE - оператор для создания новой таблицы.

// В CREATE TABLE указывается имя и тип данных каждого столбца:
    CREATE TABLE Books
    (
        Title CHAR(60),
        ISBN CHAR(13),
        Publisher_Id CHAR(6),
        Price DECIMAL(10,2)
    )

// В табл. 5.5 перечислены наиболее распространенные типы данных в SQL.

// Дополнительные предложения и операции, задающие ключи и ограничения,
// употребляемые в операторе CREATE TABLE, здесь не рассматриваются.

// Таблица 5.5. Типы данных SQL
// |------------------------------|------------------------------------------------------------------|
// | Типы данных                  |                           Описание                               |
// |------------------------------|------------------------------------------------------------------|
// | INTEGER или INT              | Обычно 32-разрядное целое значение                               |
// | SМALLINT                     | Обычно 16-разрядное целое значение                               |
// | NUМERIC(m, n), DECIМAL(m, n) | Десятичное числовое значение с фиксированной точкой,             |
// | или DEC (m, n)               | содержащее "m" цифр, в том числе "n" знаков после точки          |
// | FLOAT (n)                    | Числовое значение с плавающей точкой и точностью до "n" знаков   |
// | REAL                         | Обычно 32-разрядное числовое значение с плавающей точкой         |
// | DOUВLE                       | Обычно 64-разрядное числовое значение с плавающей точкой         |
// | CНARACTER (n) или СНАR (n)   | Строка фиксированной длины "n" символов                          |
// | VARCНAR(n)                   | Строка неременной длины максимум "n" символов                    |
// | BOOLEAN                      | Логическое значение                                              |
// | DATE                         | Календарная дата (зависит от реализации)                         |
// | ТIМЕ                         | Время (зависит от реализации)                                    |
// | ТIМЕSТАМР                    | Дата и время (зависят от реал1вации)                             |
// | BLOB                         | Большой двоичный объект                                          |
// | CLOB                         | Большой символьный объект                                        |
// |------------------------------|------------------------------------------------------------------|


// page 296
// 5.3 Конфигурирование JDBC (JDBC Configuration)

// Для работы с базой данных потребуется система управления базой данных (СУБД),
// для которой в прикладном интерфейсе JDBC имеется подходящий драйвер.

// Среди имеющихся СУБД можно выбрать следующие:
// - IВМ DB2
// - Microsoft SQL Server
// - MySQL
// - Oracle
// - PostgreSQL

// Далее необходимо создать экспериментальную базу данных, например, под названием COREJAVA.

// Задача:
// 1. Создайть новую базу данных самостоятельно
// или
// 2. Попросите сделать это администратора баз данных и наделить вас правами на:
// - создание таблиц
// - обновление таблиц
// - удаление таблиц

// Если не приходилось раньше устанавливать базу данных с архитектурой "клиент-сервер",
// то процесс ее установки, конечно, покажется вам очень сложным,
// а обнаружить причину возможной неудачи будет совсем не просто.

// -> рекомендуется обратиться к услугам опытных специалистов.

// Если отсутствует опыт работы с базами данных,
// рекомендуется установить сначала базу данных Apache Derby,
// доступную для загрузки по адресу:
//  http://db.apache.org/derby

// Чтобы запустить базу данных Apache Derby, выполним следующие шаги:

// 1. Убедитеся, что установлена Java Development Kit (JDK), так как Apache Derby написана на Java.

// 2. Загружаем дистрибутив Apache Derby с официального сайта:
//    https://db.apache.org/derby/downloads/index.html
//    т.к. мы используем Java 17...
//    файл: db-derby-10.16.1.1-bin.zip
// 3. Распаковываем загруженный архив в удобное для вас место.

// 4. Открыть командную строку или терминал и перейдите в каталог:
//    - lib
//    где находится файл derbyrun.jar, внутри распакованного дистрибутива Derby.

// 5. Чтобы запустить сервер Derby в сетевом режиме, выполните команду:
        command: java -jar derbyrun.jar server start

//    Эта команда запустит сервер Derby и позволит подключаться к нему по сети.

// 6. Чтобы создать и подключиться к базе данных Derby, выполните команду:
        command: java -jar derbyrun.jar ij
//    Эта команда запустит интерактивную оболочку Derby (ij),
//    где можно выполнять SQL-запросы и управлять базой данных.

//    В оболочке ij можно создать новую базу данных, используя команду
        command: CONNECT 'jdbc:derby:mydb;create=true';
//    Эта команда создаст базу данных:
//    - mydb
//    и подключится к ней.

//    Если база данных уже существует, она просто подключится к ней.

// 7. Теперь можно выполнять SQL-запросы и работать с базой данных через оболочку ij.

// 8. Чтобы выйти из оболочки ij, введите:
        command: exit

// Это основные шаги для запуска и начала работы с базой данных Apache Derby.
// Derby также предоставляет возможность встраивать базу данных.

// Дополнительно:
// Чтобы подключиться к уже созданной базе данных Apache Derby, выполните следующие шаги:

// 1. Убедитесь, что сервер Apache Derby запущен.
// 2. Если сервер не запущен, выполните следующую команду в терминале:
        command: java -jar derbyrun.jar server start
// 3. В своем Java-приложении добавьте зависимость Apache Derby (например, derby.jar) в classpath.

// 4. Установите соединение с базой данных с помощью URL-адреса подключения в формате:
        command: jdbc:derby://localhost:1527/имя_базы_данных
//    имя_базы_данных - фактическое имя вашей базы данных Derby.

// 5. Пример кода для подключения:
        String url = "jdbc:derby://localhost:1527/MyDatabase";
        Connection conn = DriverManager.getConnection(url);

// 6. Если вы используете аутентификацию, укажите:
//    - имя пользователя
//    - пароль
//    при установлении соединения:
        String url = "jdbc:derby://localhost:1527/MyDatabase";
        String username = "your_username";
        String password = "your_password";
        Connection conn = DriverManager.getConnection(url, username, password);

// 7. После успешного подключения можно выполнять SQL-запросы
//    и взаимодействовать с базой данных, используя объект:
//    - Connection conn

// 8. Когда закончите работу с базой данных, не забудьте закрыть соединение:
        conn.close();
//    Обратите внимание, что URL-адрес подключения предполагает,
//    что сервер Derby работает на локальном компьютере (localhost) и использует порт по умолчанию (1527).

// 9. Если сервер работает на другом хосте или порту,
//    нужно соответствующим образом изменить URL-адрес подключения.

//10. Убедиться, что указанная база данных существует и доступна.
//    Если база данных не найдена, будет получено исключение типа:
//    - SQLException


// page 297
// 5.3.1 URL баз данных (Database URLs)

//  Для подключения к базе данных необходимо указать ряд характерных для нее параметров.
// К их числу могут относиться:
// - имена хостов
// - номера портов
// - имена баз данных

// В прикладном интерфейсе JDBC используется синтаксис описания источника данных,
// подобный обычным URL.

// Примеры такого синтаксиса:
    jdbc:derby://localhost:1527/COREJAVA;create=true
    jdbc:postgresql:COREJAVA

// Эти URL определяют в JDBC базы данных Derby и PostgreSQL по имени COREJAVA.
// Общая синтаксическая форма записи URL в JDBC:
    jdbc:подчиненный_протокол:другие_сведения
// 1. подчиненный_ протокол - специальный драйвер для соединения с базой данных,
// 2. другие_сведения - формат, который зависит от применяемого подчиненного протокола.

// По поводу выбора конкретного формата
// следует обращаться к документации на применяемую базу данных.


// page 297
// 5.3.2 Архивные JAR-файлы драйверов (Driver JAR Files)

// Нужно получить архивный JАR-файл, в котором находится драйвер для выбранной базы данных.

// Если пользуется база данных Derby, то понадобится файл derbyclient.jar.
// Если же это другая база данных, придется найти для нее подходящий драйвер.

// Драйверы для базы данных PostgreSQL доступны для загрузки по адресу:
// https://jdbc.postgresql.org

// При запуске программы, обращающейся к базе данных,
// в командной строке следует указать архивный JАR-файл драйвера после параметра -classpath.

// Для компиляции самой программы архивный JАR-файл драйвера не требуется.

// Для запуска подобных программ из командной строки
// можно воспользоваться приведенной ниже командой.

// "." - знак обозначающий текущий каталог в Windows.
// Он отделяется от местонахождения архивного JАR-файла драйвера точкой с запятой.

    command: java -classpath nуть_к_файлу_драйвера:. имя_программы

// В IntelliJ IDEA можно настроить конфигурацию запуска (Run Configuration) для вашей программы,
// чтобы указать путь к драйверу базы данных.

// Шаги, которые нужно выполнить:

// 1. Откройте ваш проект в IntelliJ IDEA

// 2. В правом верхнем углу найдите выпадающий список конфигураций запуска (рядом с зеленой кнопкой "Run")
//    и нажмите "Edit Configurations".

// 3. В открывшемся окне нажмите на "+" (плюс) в левом верхнем углу
//    и выберите "Application" из выпадающего списка.

// 4. Дайте конфигурации запуска имя. Например:
//    "MyDatabaseApp"

// 5. В поле "Main class" укажите полное имя класса вашей программы,
//    содержащего метод main. Например:
//    com.example.MyDatabaseApp

// 6. В поле "VM options" введите параметр -classpath со значением,
//    указывающим путь к JAR-файлу драйвера. Например:
      command: -classpath /path/to/driver/postgresql.jar

// 7. Замените "/path/to/driver/postgresql.jar" на фактический путь к вашему JAR-файлу драйвера.

// 8. В поле "Working directory" укажите путь к папке с вашим проектом.
//    Обычно это корневая папка проекта.

// 9. Нажмите "Apply" и затем "OK", чтобы сохранить конфигурацию запуска.

// Теперь можно запустить вашу программу, используя созданную конфигурацию запуска.
// Для этого выберите "MyDatabaseApp" (или другое указанное вами имя)
// из выпадающего списка конфигураций и нажмите зеленую кнопку "Run".

// Если путь к вашему JAR-файлу драйвера, (к примеру PostgreSQL) следующий:
//      C:\Program Files\Java\jdbc\drivers\postgresql-42.4.0.jar

// В поле "VM options" конфигурации запуска в IntelliJ IDEA нужно указать:
    command:-classpath "C:\Program Files\Java\jdbc\drivers\postgresql-42.4.0.jar"

// Важные моменты:
// 1. Путь указывается в двойных кавычках, так как он содержит пробелы.
// 2. Слеши "/" заменены на обратные слеши "\", так как это путь в Windows.
// 3. Не нужно добавлять точку "." в конце, так как IntelliJ IDEA автоматически включает путь
// к классам вашего проекта в classpath.

// Конфигурация запуска в IntelliJ IDEA должна выглядеть примерно так:

// Name:                MyDatabaseApp
// Main class:          com.example.MyDatabaseApp (замените на фактическое имя вашего класса)
// VM options:          -classpath "C:\Program Files\Java\jdbc\drivers\postgresql-42.4.0.jar"
// Working directory:   /path/to/your/project (путь к корневой папке вашего проекта)

// После сохранения этой конфигурации можно запустить программу,
// используя драйвер PostgreSQL, выбрав "MyDatabaseApp"
// из выпадающего списка конфигураций и нажав зеленую кнопку "Run".


// page 297
// 5.3.3 Запуск базы данных (Starting the Database)

// Прежде чем подключиться к серверу базы данных, его нужно запустить.
// Подробности этого процесса зависят от конкретной базы данных.

// Для запуска базы данных "Derby" выполните следующие действия:

// 1. Открыть командную оболочку (терминал) и перейти в каталог, в котором находятся файлы базы данных.

// 2. Найдите архивный файл:
//    - "derbyrun.jar"
//    В одних версиях JDK он может находиться в каталоге jdk/db/lib,
//    в других - в отдельном установочном каталоге JavaDB.

//    Каталог, содержащий папку с архивным файлом:
//    - "lib/derbyrun.jar"
//    будет обозначается здесь и далее как "derby".

// 3. Выполните следующую команду:
        command: java -jar derby/lib/derbyrun.jar server start
// 4. Еще раз проверьте, работает ли база данных должным образом.
//    Создайте файл ij.properties, введя в него следующие строки:
//        ij.driver=org.apache.derby.jdbc.ClientDriver
//        ij.protocol=jdbc:derby://localhost:1527/
//        ij.database=COREJAVA;create=true

// 5. Запустите в другой копии командной оболочки диалоговое инструментальное средство
//    для написания сценариев базы данных Derby (оно называется ij), выполнив следующую команду:
        command: java -jar derby/lib/derbyrun.jar ij -р ij.properties

// 6. Теперь можно выдать команды SQL, например, следующие:
//    CREATE TABLE Greetings(Message CHAR(20));
//    INSERT INTO Greetings VALUES ('Hello, World!');
//    SELECT * fROM Greetings;
//    DROP TABLE Greetings;

// 7. Каждая команда должна завершаться точкой с запятой.
//    Чтобы выйти из режима ввода команд SQL, введите команду:
//    EXIT;

// 8. Завершив работу с базой данных, остановите ее сервер,
//    выполнив следующую команду:
        command: java -jar derby/lib/derbyrun.jar server shutdown

// Если вы польуетесь, другой базой данных, нужно найти в документации на нее
// сведения о запуске и остановке сервера базы данных,
// а также о том, как подключаться к нему и выполнять команды SQL.


// page 298
// 5.3.4 Регистрация класса драйвера (Registering the Driver Class)

// Многие архивные JАR-файлы прикладного интерфейса JDBC
// например, драйвер базы данных Apache Derby автоматически регистрируют класс драйвера.

// В этом случае вы можете пропустить этап ручной регистрации,
// рассматриваемый в этом разделе.

// Архивный JАR-файл может автоматически зарегистрировать класс драйвера,
// если он содержит файл:
// META-INF/services/java.sql.Driver

// Чтобы убедиться в этом, можно распаковать архивный JАR-файл драйвера.

// Если архивный JАR-файл драйвера не поддерживает автоматическую регистрацию,
// придется выяснить имена классов драйверов JDBC,
// используемых поставщиком базы данных.

// Типичными именами классов драйверов являются следующие:
// - org.apache.derby.jdbc.ClientDriver
// - org.postgresql.Driver

// Зарегистрировать драйвер с помощью класса DriverManager можно двумя способами:
// 1. Загрузить класс драйвера в программу на Java,
//    как показано в приведенной ниже строке кода, где выполняется статический инициализатор,
//    который и осуществляет регистрацию загружаемого драйвера.
        Class.forName("org.postgresql.Driver"); // принудительная загрузка класс драйвера

// 2. Задать свойство jdbc.drivers, которое можно указать
//    в качестве аргумента непосредственно в командной строке:
        java -Djdbc.drivers=org.postgresql.Driver имя_програнны

// Можно установить системное свойство в своей прикладной программе, сделав следующий вызов:
    System.setProperty("jdbc.drivers", "org.postgresql.Driver");

// При необходимости можно указать несколько разных драйверов, разделив их двоеточием:
    org.postgresql.Driver:org.apache.derby.jdbc.ClientDriver


// page 299
// 5.3.5 Подключение к базе данных (Connecting to the Database)

// Установить соединение с базой данных в прикладной программе на Java можно следующим образом:
    String url = "jdbc:postgresql:COREJAVA";
    String username = "dbuser";
    String password = "secret";
    Connection conn = DriverManager.getConnection(url, username, password);

// Диспетчер перебирает все зарегистрированные драйверы, пытаясь найти тот,
// который соответствует подчиненному протоколу, указанному в URL базы данных.

// Метод getConnection() - возвращает объект типа Connection,
//                         который используется для выполнения операторов SQL.

// Чтобы соединиться с базой данных, необходимо знать:
// - имя пользователя базы данных
// - пароль пользователя

// По умолчанию база данных Derby допускает соединение
// под любым именем пользователя, не проверяя пароль.

// Для каждого пользователя в этой базе данных формируется отдельный ряд таблиц.

// По умолчанию используется имя пользователя:
// - "арр".

// Все сказанное выше о работе с базами данных демонстрируется на примере тестовой программы,
// исходный код которой приведен в листинге 5.1
// (ru/sectorsj/_300_testdb/TestDB.java)
// Эта программа загружает из файла свойств database.properties
// параметры подключения к базе данных и затем осуществляет его.

// Файл свойств database.properties (resources/_301/database.properties)
// предоставляемый вместе с примером кода, содержит сведения о подключении к базе данных Derby.

// Если вы пользуетесь другой базой данных,
// введите в этот файл соответствующие сведения о подключении к конкретной базе данных.

// Пример параметров подключения к базе данных PostgreSQL:
    jdbc.drivers=org.postgresql.Driver
    jdbc.url=jdbc:postgresql:COREJAVA
    jdbc.username=dbuser
    jdbc.password=secret

// После подключения к базе данных рассматриваемая программа выполняет следующие операторы SQL:
    CREATE TABLE Greetings (Message CHAR(20))
    INSERT INTO Greetings VALUES ('Hello, World' ')
    SELECT * FROM Greetings
    DROP TABLE Greetings

// В результате выполнения оператора SELECT выводится:
// Hello, World!

// В результате выполнения оператора DROP TABLE:
// созданная в базе данных таблица удаляется из нее.

// Чтобы выполнить данную тестовую программу, запустите сначала базу данных,
// как описано выше, а затем саму программу, введя приведенную ниже команду.
    command: java -classpath .:driverJAR _300_testdb.TestDB

// Пользователям Windows следует:
// - ввести точку с запятой ";"
// - вместо двоеточия ":"
// для разделения составляющих пути к файлам.

// Для устранения неполадок в прикладном интерфейсе JDBC
// можно активизировать трассировку JDBC.

// С этой целью следует вызвать метод DriverМanager.setLogWriter(),
// чтобы направить сообщения трассировки в записывающий поток типа PrintWriter.

// Вывод трассировки содержит подробный перечень действий JDBC.

// В большинстве реализаций драйвера JDBC предоставляются дополнительные механизмы трассировки.

// Для базы данных Dеrbу можно добавить параметр traceFile
// в URL прикладного интерфейса JDBC (в файл database.properties) следующим образом:
    jdbc:derby://localhost:1527/COREJAVA;create=true;traceFile=trace.out


// page 302
// 5.4 Работа с операторами JDBC (Working with JDBC Statements)

// Как пользоваться классом Statement из прикладного интерфейса JDBC для:
// - выполнения операторов SQL,
// - получения результатов и обработки ошибок.

// Пример простой программы для заполнения базы данных.


// page 302
// 5.4.1 Выполнение операторов SQL (Executing SQL Statements)

// Для выполнения оператора SQL:
// 1. Создается объект типа Statement.
//    Для этой цели используется объект типа Connection,
//    который можно получить, вызвав метод DriverManager.getConnection() следующим образом:
        Staternent stat = conn.createStaternent();

// 2. Формируется символьная строка с требующимся оператором SQL:
        String command = "UPDATE Books"
        + " SET Price = Price - 5.00"
        + " WHERE Title NOT LIKE '%Introduction%'";

// 3. Вызывается метод executeUpdate() из класса Statement:
        stat.executeUpdate(command);

// Метод executeUpdate() - возвращает количество строк, полученных из таблицы базы данных
//                         в результате выполнения оператора SQL, или же нуль строк для тех операторов,
//                         которые не возвращают количество строк из таблицы.

// -> вызов метода executeUpdate() возвращает количество книг, цена которых снижена на 5 долларов.

// Вызывая метод executeUpdate(), можно выполнять операторы:
//  - INSERT
//  - UPDATE
//  - DELETE
// а также операторы определения данных, в том числе:
//  - CREATE TABLE
//  - DROP TABLE

// Для выполнения оператора SELECT необходимо вызвать, другой метод executeQuery().

// execute() - универсалышй метод может выполнять произвольные операторы SQL.
//             Применяется для составления запросов в диалоговом режиме.

// Если составляется запрос для базы данных, будет интересен результат его обработки.

// Метод executeQuery() - возвращает объект типа ResultSet, который можно использовать
// для построчного просмотра результатов выполнения запроса:
    ResultSet rs = stat.executeQuery("SELECT * FROM Books")

// Для анализа результирующего набора организуется простой цикл:
    while (rs.next()) {
        // проанализировать строку из результирующего набора
    }

// Порядок последовательной обработки строк в интерфейсе ResultSet
// организован несколько иначе, чем в интерфейсе java.util.Iterator.

// В интерфейсе ResultSet итератор устанавливается на позиции
// перед первой строкой из результирующего набора.
// Поэтому для его перемещения к первой строке нужно вызвать метод next().

// В интерфейсе ResultSet отсутствует метод hasNext(),
// -> метод next() придется вызывать до тех пор,
// пока не будет возвращено логическое значение false.

// В результирующем наборе строки располагаются в произвольном порядке.
// Если порядок их следования важен, его необходимо установить с помощыо предложения ORDER ВУ.

// При обработке каждой строки таблицы
// требуется получить содержимое отдельных полей (или столбцов).

// Для этой цели имеется целый ряд методов доступа к полям (или столбцам).

// Примеры вызова подобных методов доступа:
    String isbn = rs.getString(1);
    String price = rs.getDouble("Price");

// Для каждого типа данных Java предусмотрен отдельный метод доступа,
// - getString()
// - getDouble()
// - и др
// Каждый из них реализован в двух формах:
// одной - с числовым параметром,
// другой - со строковым.

// Если метод доступа вызывается с числовым параметром,
// данные извлекаются из столбца с указанным номером.

// -> вызова метода rs.getString(1):
// возвращается значение из первого столбца текущей строки таблицы.

// В отличие от массивов, нумерация столбцов таблиц в базе данных начинается с 1.

// Если же метод доступа вызывается со строковым параметром,
// данные извлекаются из столбца с указанным именем.

// -> вызова метода rs.getDouble("Price"):
возвращается значение из столбца с именем Price.

// Первая форма методов доступа с числовым параметром более эффективна,
// но строковые параметры улучшают восприятие и упрощают сопровождение кода.

// Если указанный тип не соответствует фактическому типу,
// метод доступа автоматически выполняет необходимое преобразование данных.

// -> вызова метода rs.getString("Price"):
// числовое значение с плавающей точкой, извлекаемое из столбца Price,
// преобразуется в символьную строку.


// page 305
// 5.4.2 Управленеи подключениями, операторами и результирующими наборами
//       (Managing Connections, Statements, and Result Sets)

// Каждый объект типа Connection может создать один или несколько объектов типа Statement.

// Один и тот же объект типа Statement можно использовать
// для выполнения нескольких не связанных между собой операторов SQL и запросов.
// Но для такого объекта допускается наличие не более oдногo открытого результирующего набора.

// Если же требуется выполнить несколько запросов и одновременно проанализировать их результаты,
// то для этого понадобится несколько объектов типа Statement.

// Нужно помнить про ограничения, накладываемые на количество операторов SQL,
// приходящихся на одно подключение к базе данных.

// Количество открытых объектов типа Statement, одновременно поддерживаемых драйвером JDBC,
// можно выяснить, вызвав метод getMaxStatements() из интерфейса DatabaseMetaData.

// Не стоит одновременно обрабатывать несколько результирующих наборов.

// Если же результирующие наборы (ResultSet) взаимосвязаны,
// следует выдать составной запрос и проанализировать единый результат.

// Намного эффективнее объединять запросы в самой базе данных,
// чем выполнять обход нескольких результирующих наборов в программе на Java.

// Примеры:
// 1. объединения запросов в базе данных
// 2. обхода нескольких результирующих наборов в Java

// 1. Объединение запросов в базе данных (на примере SQL):
// У нас есть две таблицы: "orders" (заказы) и "customers" (покупатели).
// Нужно получить информацию о заказах вместе с именами покупателей.

// sql запрос:
// SELECT orders.order_id, orders.order_date, customers.customer_name
// FROM orders
// JOIN customers ON orders.customer_id = customers.customer_id;

// В этом примере используется оператор JOIN
// для объединения таблиц "orders" и "customers" на основе поля "customer_id".
// Это позволяет получить информацию из обеих таблиц в одном запросе.

// 2. Обход нескольких результирующих наборов в Java:
// Было выполнено два отдельных запроса к базе данных
// и получено два результирующих набора:
// - "orders"
// - "customers".
// Теперь нужно объединить эти наборы в Java.

// java code:
// List<Order> orders = // получаем список заказов из базы данных
// List<Customer> customers = // получаем список покупателей из базы данных

// for (Order order : orders) {
//     for (Customer customer : customers) {
//         if (order.getCustomerId() == customer.getId()) {
//             order.setCustomerName(customer.getName());
//             break;
//         }
//     }
// }

// В этом примере используется вложенные циклы для обхода списков "orders" и "customers".
// Для каждого заказа, где ищется соответствующий покупатель по полю "customer_id"
// и устанавливаем имя покупателя в объекте заказа.

// Как можно заметить, объединение запросов в базе данных является более эффективным подходом,
// так как база данных оптимизирована для выполнения таких операций.
// Это позволяет уменьшить количество передаваемых данных и уменьшить нагрузку на приложение.

// В некоторых случаях может потребоваться выполнить обход результирующих наборов в Java,
// например, когда необходимо выполнить сложную бизнес-логику или преобразования данных,
// которые невозможно реализовать на уровне базы данных.

//  Выбор подхода зависит от конкретных требований и особенностей приложения.
// Но в общем случае, рекомендуется максимально использовать возможности базы данных
// для объединения и фильтрации данных, чтобы минимизировать передачу данных
// и улучшить производительность приложения.

// Обработку любого результирующего набора следует завершить,
// прежде чем выдавать новый запрос или обновлять объект типа Statement.

// Т.к. результирующие наборы из предыдущих запросов автоматически закрываются.

// Закончив работать с объектом типа ResultSet, Statement или Connection,
// следует как можно скорее вызвать метод close().

// Т.к. эти объекты используют:
// - крупные структуры данных
// - истощаемые ресурсы
// на сервере базы данных.

// Метод close() из класса Statement автоматически закрывает результирующий набор,
// связанный с объектом данного класса, если этот набор открыт
// при выполнении соответствующей команды.

// Аналогично
// метод close() из класса Connection закрывает все объекты данного класса,
открытые для соединения с базой данных.

// С другой стороны, можно вызвать метод closeOnCompletion() из класса Statement,
// чтобы автоматически закрыть объект данного класса,
// как только будут закрыты все связанные с ним результирующие наборы.

// Если подключение к базе данных кратковременно,
// то можно не беспокоиться о закрытии объектов типа Statement
// и связанных с ними результирующих наборов.

// Для абсолютной гарантии, что объект подключения к базе данных не останется открытым,
// можно воспользоваться оператором try с ресурсами следующим образом:
    try (Connection conn = ...) {
        Statement stat = conn.createStatement();
        ResultSet result = stat.executeQuery(queryString);
        // Обработка результата запроса ...
    }


// page 306
// 5.4.3 Анализ исключений SQL (Analyzing SQL Exceptions)

// У каждого исключения SQL имеется цепочка объектов типа SQLException,
// которые извлекаются методом getNextException().

// Эта цепочка исключений является дополнением "причинной" цепочки объектов типа Throwable,
// имеющихся в каждом исключении (том 1, глава 7, стр 339 - 393).

// -> чтобы полностью перечислить все исключения,
// нужно организовать два вложенных цикла.

// Класс SQLException был усовершенствован для реализации интерфейса Iterable<Throwable>.

// В частности, метод iterator() производит объект типа Iterator<Throwable>,
// который осуществляет перебор в обеих цепочках исключений,
// сначала проходя по "причинной" цепочке первого объекта типа SQLException,
// а затем переходя к следующему объекту типа SQLException и т.д.

// Для этой цели можно организовать усовершенствованный цикл for следующим образом:
    for (Throwable t : sqlException) {
        // сделать что-нибудь с объектом "t"
    }

// Чтобы продолжить анализ объекта типа SQLException,
// для него можно вызвать методы:
// - getSQLState() - выдает символьную строку по стандарту X/Open или SQL:2003.
                     Чтобы выяснить, какому именно стандарту соответствует применяемый драйвер,
                     достаточно вызвать метод getSQLStateType() из интерфейса DatabaseMetadata.

// - getErrorCode() - Что же касается метода кода ошибки, то у различных поставщиков баз данных он разный.

// Исключения SQL организованы в виде древовидной структуры наследования,
// приведенной на рис. 5.5 ()

//  SQLException                                       - SQL-исключение
//      BatchUpdateException                           - Исключение пакетного обновления
//      SerialException                                - Серийное исключение
//      SQLTransientException                          - Временное исключение SQL
//          SQLTimeoutException                        - Исключение тайм-аута SQL
//          SQLTransientConnectionException            - Исключение временного соединения SQL
//          SQLTransactionRollbackException            - Исключение отката транзакции SQL
//      SQLClientInfoException                         - Исключение информации SQL-клиента
//      SQLRecoverableException                        - Исправимое исключение SQL
//      SQLWarning                                     - Предупреждение SQL
//      SQLNonTransientException                       - Непереходное исключение SQL
//          SQLDataException                           - Исключение данных SQL
//          SQLFeatureNotSupportedException            - Исключение функция SQL не поддерживается
//          SQLIntegrityConstraintViolationException   - Исключение нарушения ограничения целостности SQL
//          SQLSyntaxErrorException                    - Исключение синтаксической ошибки SQL
//          SQLInvalidAuthorizationSpecException       - Исключение недопустимой спецификации авторизации SQL
//          SQLNonTransientConnectionException         - Исключение непереходного соединения SQL
//      RowSetWarning                                  - Предупреждение о заданном наборе строк
//      SyncFactoryException                           - Исключение синхронизации с заводом
//      SyncProviderException                          - Исключение поставщика синхронизации

// Благодаря этому имеется возможность перехватывать,
// отдельные типы ошибок независимо от предпочтений поставщиков баз данных.

// Драйвер базы данных может сообщать о некритичных ситуациях в виде предупреждений.
// Подобные предупреждения можно получать от:
// - подключений к базе данных,
// - операторов SQL
// - результирующих наборов (Result Sets).

// Класс SQLWarning является подклассом, производным от класса SQLException,
// несмотря на то, что объект типа SQLWarning не генерируется в виде исключения.

// Вызвав методы:
// - getSQLState()
// - getErrorCode()
// можно получить дополнительные сведения о предупреждениях.

// Подобно исключениям SQL, предупреждения организуются в цепочку.
// Чтобы получить все предупреждения, нужно организовать следующий цикл:
    SQLWarning w = stat.getWarning();
    while(w != null) {
        // сделать что-нибудь с объектом "w"
        w = w.nextWarning();
    }

// Подкласс DataTruncation, производный от класса SQLWarning, используется в тех случаях,
// когда данные считываются из базы данных и в этот момент происходит их неожиданное усечение.

// Если усечение данных произошло при выполнении команды обновления,
// то объект типа DataTruncation генерируется в виде исключения.


// page 309
// 5.4.4 Заполнение базы данных (Populating a Database)

// Попробуем теперь написать первую реальную программу,
// используя прикладной интерфейс JDBC.
// Будет хорошо, если в этой программе
// можно выполнить некоторые из рассмотренных ныше запросов.
// Это невозможно, т.к. база данных пуста.

// Сначала ее нужно заполнить данными.
// Сделать это нетрудно с помощью ряда инструкций SQL
// для создания таблиц и ввода в них данных.

// Большинство СУБД способны обрабатывать инструкции SQL из текстового файла,
// но в этом случае проявляются досадные отличия в завершающих символах операторов
// и другие синтаксические особенности реализации SQL на разных платформах.

// -> воспользуемся прикладным интерфейсом JDBC,
// чтобы написать простую программу для построчного чтения инструкций SQL
// из файла и последующего их выполнения.

// Данная программа должна читать данные из текстового файла в следующем формате:
    CREATE TABLE Publishers (Publisher_id CHAR(6), Name CHAR (30), URL CHAR(80));
    INSERT INTO Publishers VALUES ('0201', 'Addison-Wesley', 'www.aw-bc.com);
    INSERT INTO Publishers VALUES ('0471', 'John Wiley & Sons', 'www.wiley.com);
    ...

// В листинге 5.2 ()
// приведен исходный код программы ExecSQL,
// сначала читающей операторы SQL из текстового файла,
// а затем выполняющей их.

// Для применения этой программы совсем не обязательно разбираться в ее исходном коде.

// Самое главное, что она позволяет заполнить базу данных и выполнить примеры программ,
// приведенные в остальной части этой главы.

// 1. Приведите сервер базы данных в рабочее состояние
// 2. Запустите программу ExecSQL на выполнение
// 3. Введите следующие команды:
        command: java -classpath путь_к_драйввру:. exec.ExecSQL Books.sql
        command: java -classpath путь_к_драйверу:. exec.ExecSQL Authors.sql
        command: java -classpath путь_к_драйввру:. exec.ExecSQL Publishers.sql
        command: java -classpath путь_к_драйввру:. exec.ExecSQL BooksAuthors.sql

// Перед запуском данной программы проверьте содержимое файла свойств:
// - database.properties
// на соответствие исполняющей среде (раздел 5.3.5) ()

// В состав вашей базы данных может входить утилита для непосредственного чтения файлов SQL.

// В базе данных Dеrbу можно выполнить следующую команду:
        command: java -jar derby/lib/derbyrun.jar ij -р ij.properties Books.sql

// для чтения файла свойств ij.properties, описанного ранее в разделе 5.3.3 (стр 297)

// В формате данных для программы ExecSQL
// допускается вставка точки с запятой в конце каждой строки,
// поскольку такой формат предполагается в большинстве утилит баз данных.

// Основные этапы выполнения программы ExecSQL.
// 1. Устанавливается соединение с базой данных.
//    Метод getConnection():
      - считывает содержимое файла свойств database.properties
//    - вводит свойство jdbc.drivers в список системных свойств.
//    Диспетчер драйверов использует свойство jdbc.drivers для загрузки соответствующего драйвера базы данных.
//    Для подключения к базе данных в методе getConnection() применяются свойства:
//    - jdbc.url
//    - jdbc.username
//    - jdbc.password

// 2. Открывается текстовый файл с операторами SQL.
//    Если такой файл отсутствует, пользователю предлагается ввести операторы вручную с консоли.

// 3. Все заданные операторы SQL выполняются с помощью универсального метода execute().
//    При получении результирующего набора этот метод возвращает логическое значение true.
//    В конце всех четырех текстовых файлов с операторами SQL содержится оператор SELECT *.
//    Это дает возможность убедиться, что информация успешно введена в базу данных.

// 4. При наличии результирующего набора полученные результаты выводятся на экран.
//    Поскольку это обобщенный результирующий набор,
//    то для определения количества столбцов в нем потребуются метаданные.
//    Подробно метаданные рассматриваются далее (раздел 5.8).

// 5. Если при выполнении операторов SQL возникает какое-нибудь исключение,
//    то выводятся сведения о нем, а также обо всех остальных исключениях,
//    которые могут следовать по цепочке.

// 6. По завершении всех заданных операторов SQL
//    соединение с базой данных разрывается.

hortsmann_v_two/src/main/resources/_310/Books.sql
// D:\filesEvgeniy\projects\mycoding\java\learnbooks\hortsmann_v_two\src\main\resources\_310\Authors.sql
// D:\filesEvgeniy\projects\mycoding\java\learnbooks\hortsmann_v_two\src\main\resources\_310\Books.sql
// D:\filesEvgeniy\projects\mycoding\java\learnbooks\hortsmann_v_two\src\main\resources\_310\BooksAuthors.sql
// D:\filesEvgeniy\projects\mycoding\java\learnbooks\hortsmann_v_two\src\main\resources\_310\Publishers.sql


// Дополнительно разбираю с тему ИИ:

// Код класса: ExecSQL.java
    class ExecSQL {
       public static void main(String args[]) throws IOException {
          try (Scanner in = args.length == 0 ? new Scanner(System.in)
                : new Scanner(Path.of(args[0]), StandardCharsets.UTF_8)) {
             try (Connection conn = getConnection();
                   Statement stat = conn.createStatement()) {
                while (true) {
                   if (args.length == 0)
                      System.out.println("Enter command or EXIT to exit:");

                   if (!in.hasNextLine())
                      return;

                   String line = in.nextLine().strip();
                   if (line.equalsIgnoreCase("EXIT"))
                      return;
                   if (line.endsWith(";")) // remove trailing semicolon
                      line = line.substring(0, line.length() - 1);
                   try {
                      boolean isResult = stat.execute(line);
                      if (isResult) {
                         try (ResultSet rs = stat.getResultSet()) {
                            showResultSet(rs);
                         }
                      } else {
                         int updateCount = stat.getUpdateCount();
                         System.out.println(updateCount + " rows updated");
                      }
                   } catch (SQLException e) {
                      for (Throwable t : e)
                         t.printStackTrace();
                   }
                }
             }
          } catch (SQLException e) {
             for (Throwable t : e)
                t.printStackTrace();
          }
       }

       public static Connection getConnection() throws SQLException, IOException {
          var props = new Properties();
          try (Reader in = Files.newBufferedReader(
                Path.of("database.properties"), StandardCharsets.UTF_8)) {
             props.load(in);
          }
          String drivers = props.getProperty("jdbc.drivers");
          if (drivers != null)
             System.setProperty("jdbc.drivers", drivers);

          String url = props.getProperty("jdbc.url");
          String username = props.getProperty("jdbc.username");
          String password = props.getProperty("jdbc.password");

          return DriverManager.getConnection(url, username, password);
       }

       public static void showResultSet(ResultSet result) throws SQLException {
          ResultSetMetaData metaData = result.getMetaData();
          int columnCount = metaData.getColumnCount();

          for (int i = 1; i <= columnCount; i++) {
             if (i > 1)
                System.out.print(", ");
             System.out.print(metaData.getColumnLabel(i));
          }
          System.out.println();

          while (result.next()) {
             for (int i = 1; i <= columnCount; i++) {
                if (i > 1)
                   System.out.print(", ");
                System.out.print(result.getString(i));
             }
             System.out.println();
          }
       }
    }

// В приведенном фрагменте кода есть несколько моментов, которые можно улучшить или изменить:

// 1. Обработка аргументов командной строки:
//  - В данном коде предполагается, что если аргументы командной строки отсутствуют (`args.length == 0`),
//    то ввод будет осуществляться с консоли (`System.in`).
//  - Если аргументы командной строки присутствуют, то предполагается,
//    что первый аргумент (`args[0]`) содержит путь к файлу, из которого будет осуществляться ввод.
//  - Однако в этом случае не предусмотрена обработка ситуации,
//    когда указанный файл не существует или не может быть открыт, что может привести к исключению `IOException`.

// 2. Обработка пустых строк:
//    - В коде выполняется проверка наличия следующей строки с помощью `if (!in.hasNextLine())`,
//      но не проверяется, является ли введенная строка пустой.
//    - Если пользователь введет пустую строку, она будет обрабатываться как обычная команда SQL,
//      что может привести к ошибке или неожиданному поведению.

// 3. Обработка точки с запятой в конце команды:
//    - Выполняется проверка, заканчивается ли введенная строка на точку с запятой (`;`),
//      если да, то точка с запятой удаляется.
//    - Если пользователь случайно введет несколько точек с запятой
//      или другие символы после точки с запятой, они не будут удалены,
//      что может привести к ошибке при выполнении команды SQL.

// 4. Обработка исключений:
//    - Перехватываются исключения `SQLException` и выводится информация о них с помощью `printStackTrace()`.
//    - В некоторых случаях может быть полезно
//      предоставить более дружественные сообщения об ошибках для пользователя,
//      чтобы он мог понять, что пошло не так и как исправить проблему.
//
// Несмотря на эти замечания, код в целом функционален
// и выполняет свою основную задачу - обработку команд SQL, введенных пользователем,
// и выполнение их с помощью объекта `Statement`.

// Ошибки, которые могут возникнуть, связаны с некорректными входными данными
// или проблемами с подключением к базе данных, и они обрабатываются с помощью перехвата исключений.


// Задача:
// Программа ExecSQL столкнулась с множеством синтаксических ошибок
// при выполнении SQL-операторов из указанных файлов скриптов.
// Основная проблема заключается в том, что операторы SQL в файлах скриптов
// разделены на отдельные строки,
// но программа ExecSQL пытается выполнить каждую строку как отдельный оператор SQL.

// Чтобы решить эту проблему, вам нужно изменить способ чтения
// и выполнения SQL-операторов в программе ExecSQL.

// Вместо чтения каждой строки отдельно, вам нужно читать весь файл скрипта целиком,
// а затем разделять его содержимое на отдельные операторы SQL,
// используя точку с запятой (;) в качестве разделителя.

// Вот как вы можете изменить код в методе main класса ExecSQL:
class ExecSQLv1 {
    public static void main(String[] args) throws IOException {
        try (Connection conn = getConnection();
             Statement stat = conn.createStatement()) {
            for (String filePath : args) {
                String content = Files.readString(Path.of(filePath));
                String[] statements = content.split(";");
                for (String sql : statements) {
                    sql = sql.trim();
                    if (!sql.isEmpty()) {
                        try {
                            boolean isResult = stat.execute(sql);
                            if (isResult) {
                                try (ResultSet rs = stat.getResultSet()) {
                                    showResultSet(rs);
                                }
                            } else {
                                int updateCount = stat.getUpdateCount();
                                System.out.println(updateCount + " rows updated");
                            }
                        } catch (SQLException e) {
                            for (Throwable t : e) {
                                t.printStackTrace();
                            }
                        }
                    }
                }
            }
        } catch (SQLException e) {
            for (Throwable t : e) {
                t.printStackTrace();
            }
        }
    }

    public static Connection getConnection() throws SQLException, IOException {
       var props = new Properties();
       try (Reader in = Files.newBufferedReader(
             Path.of("database.properties"), StandardCharsets.UTF_8)) {
          props.load(in);
       }
       String drivers = props.getProperty("jdbc.drivers");
       if (drivers != null)
          System.setProperty("jdbc.drivers", drivers);
       String url = props.getProperty("jdbc.url");
       String username = props.getProperty("jdbc.username");
       String password = props.getProperty("jdbc.password");
       return DriverManager.getConnection(url, username, password);
    }

    public static void showResultSet(ResultSet result) throws SQLException {
       ResultSetMetaData metaData = result.getMetaData();
       int columnCount = metaData.getColumnCount();
       for (int i = 1; i <= columnCount; i++) {
          if (i > 1)
             System.out.print(", ");
          System.out.print(metaData.getColumnLabel(i));
       }
       System.out.println();
       while (result.next()) {
          for (int i = 1; i <= columnCount; i++) {
             if (i > 1)
                System.out.print(", ");
             System.out.print(result.getString(i));
          }
          System.out.println();
       }
    }
}

// Основные изменения:
// Вместо использования Scanner для чтения файла построчно, используем Files.readString()
// для чтения всего содержимого файла скрипта в виде строки.

// Разделяем содержимое файла на отдельные операторы SQL, используя split(";").
// Это создает массив строк, каждая из которых представляет отдельный оператор SQL.

// Затем проходимся по каждому оператору SQL в цикле for,
// удаляем лишние пробелы с помощью trim() и проверяем, что оператор не пустой.

// Выполняем каждый оператор SQL с помощью stat.execute(sql), как и раньше,
// и обрабатываем результаты и исключения так же, как в исходном коде.

// -> программа ExecSQLv1 должна правильно читать файлы скриптов,
// разделять их содержимое на отдельные операторы SQL и выполнять их по очереди.


// Фрагмент исходного кода ExecSQLv1.java
    public static void main(String[] args) throws IOException {
        try (Connection conn = getConnection();
             Statement stat = conn.createStatement()) {

            for (String filePath : args) {
                String content = Files.readString(Path.of(filePath));
                String[] statements = content.split(";");

                for (String sql : statements) {
                    sql = sql.trim();
                    if (!sql.isEmpty()) {
                        try {
                            boolean isResult = stat.execute(sql);
                            if (isResult) {
                                try (ResultSet rs = stat.getResultSet()) {
                                    showResultSet(rs);
                                }
                            } else {
                                int updateCount = stat.getUpdateCount();
                                System.out.println(updateCount + " rows updated");
                            }
                        } catch (SQLException e) {
                            for (Throwable t : e) {
                                t.printStackTrace();
                            }
                        }
                    }
                }
            }
        } catch (SQLException e) {
            for (Throwable t : e) {
                t.printStackTrace();
            }
        }
    }

// Задача:
// Сделать из этих фрагментов кода один, так чтобы можно было вводить данные в таблицы через строку
// и если написать команду "LOAD FILES" можно загрузить данные в таблицу из файлов
    public static void main(String[] args) throws IOException {
        try (Connection conn = getConnection();
             Statement stat = conn.createStatement();
             Scanner in = new Scanner(System.in)) {

            while (true) {
                System.out.println("Enter command, LOAD FILES to load data from files, or EXIT to exit:");
                if (!in.hasNextLine()) {
                    return;
                }
                String line = in.nextLine().trim();
                if (line.equalsIgnoreCase("EXIT")) {
                    return;
                }
                if (line.equalsIgnoreCase("LOAD FILES")) {
                    if (args.length == 0) {
                        System.out.println("No file paths provided as command-line arguments.");
                        continue;
                    }
                    for (String filePath : args) {
                        String content = Files.readString(Path.of(filePath));
                        String[] statements = content.split(";");
                        for (String sql : statements) {
                            sql = sql.trim();
                            if (!sql.isEmpty()) {
                                executeStatement(stat, sql);
                            }
                        }
                    }
                } else {
                    if (line.endsWith(";")) {
                        line = line.substring(0, line.length() - 1);
                    }
                    executeStatement(stat, line);
                }
            }
        } catch (SQLException e) {
            for (Throwable t : e) {
                t.printStackTrace();
            }
        }
    }

    private static void executeStatement(Statement stat, String sql) throws SQLException {
        try {
            boolean isResult = stat.execute(sql);
            if (isResult) {
                try (ResultSet rs = stat.getResultSet()) {
                    showResultSet(rs);
                }
            } else {
                int updateCount = stat.getUpdateCount();
                System.out.println(updateCount + " rows updated");
            }
        } catch (SQLException e) {
            for (Throwable t : e) {
                t.printStackTrace();
            }
        }
    }

// Основные изменения:
// Снова используем Scanner для чтения ввода пользователя из консоли.

// В бесконечном цикле while (true) запрашиваем у пользователя ввод команды,
// файлов для загрузки данных или выход из программы.

// Если пользователь вводит "EXIT", программа завершается.

// Если пользователь вводит "LOAD FILES", программа проверяет,
// были ли указаны пути к файлам в аргументах командной строки.

    // Если файлы не указаны, выводится сообщение об ошибке и цикл продолжается.
    // В противном случае, программа читает содержимое каждого файла,
    // разделяет его на отдельные операторы SQL и выполняет каждый оператор,
    // используя метод executeStatement().

// Если пользователь вводит обычную команду SQL,
// программа удаляет точку с запятой в конце строки (если она есть)
// и выполняет команду, используя метод executeStatement().

// Метод executeStatement() выполняет оператор SQL,
// обрабатывает результаты и исключения, как и раньше.

// Можно запустить программу без указания файлов в аргументах командной строки.
// Вводить команды SQL непосредственно в консоль.
// Если нужно загрузить данные из файлов,
// можно ввести команду "LOAD FILES", и программа выполнит операторы SQL из указанных файлов.

// Задача:
// Когда программа не находит пути в аргументах,
// должно выводиться сообщение о ручном вводе путей к файлам скриптов,
// вместо выведения сообщения об ошибке.
// Если пути указаны не верно, тогда программа должна выводить предупреждение.

    public static void main(String[] args) throws IOException {
        try (Connection conn = getConnection();
             Statement stat = conn.createStatement();
             Scanner in = new Scanner(System.in)) {

            while (true) {
                System.out.println("Enter command, LOAD FILES to load data from files, or EXIT to exit:");
                if (!in.hasNextLine()) {
                    return;
                }
                String line = in.nextLine().trim();
                if (line.equalsIgnoreCase("EXIT")) {
                    return;
                }
                if (line.equalsIgnoreCase("LOAD FILES")) {
                    if (args.length == 0) {
                        System.out.println("No file paths provided as command-line arguments.");
                        System.out.println("Please enter the paths to the script files (separated by commas):");
                        String filePaths = in.nextLine().trim();
                        args = filePaths.split(",");
                    }
                    for (String filePath : args) {
                        try {
                            String content = Files.readString(Path.of(filePath.trim()));
                            String[] statements = content.split(";");
                            for (String sql : statements) {
                                sql = sql.trim();
                                if (!sql.isEmpty()) {
                                    executeStatement(stat, sql);
                                }
                            }
                        } catch (IOException e) {
                            System.out.println("Warning: File not found or invalid path - " + filePath.trim());
                        }
                    }
                } else {
                    if (line.endsWith(";")) {
                        line = line.substring(0, line.length() - 1);
                    }
                    executeStatement(stat, line);
                }
            }
        } catch (SQLException e) {
            for (Throwable t : e) {
                t.printStackTrace();
            }
        }
    }

    private static void executeStatement(Statement stat, String sql) throws SQLException {
        try {
            boolean isResult = stat.execute(sql);
            if (isResult) {
                try (ResultSet rs = stat.getResultSet()) {
                    showResultSet(rs);
                }
            } else {
                int updateCount = stat.getUpdateCount();
                System.out.println(updateCount + " rows updated");
            }
        } catch (SQLException e) {
            for (Throwable t : e) {
                t.printStackTrace();
            }
        }
    }
// Изменения:
// Если пользователь вводит "LOAD FILES", но пути к файлам не были указаны в аргументах командной строки,
// программа выводит сообщение о том, что пути не были указаны,
// и запрашивает у пользователя ручной ввод путей к файлам скриптов.
// Пользователь может ввести несколько путей, разделенных запятыми.

// Программа разделяет введенные пользователем пути по запятым и сохраняет их в массиве args.

// При чтении каждого файла программа обрабатывает исключение IOException, которое может возникнуть,
// если файл не найден или указан неверный путь.
// В таком случае программа выводит предупреждение с указанием проблемного файла
// и продолжает обработку остальных файлов.

// Далее код остается без изменений.

// Теперь если пользователь вводит "LOAD FILES",
// но пути к файлам не были указаны в аргументах командной строки,
// программа запросит у пользователя ручной ввод путей.
// Если какой-либо из указанных путей неверен или файл не найден,
// программа выведет предупреждение и продолжит обработку остальных файлов.

// Вопрос:
// Каким образом можно вводить название путей к файлам скриптов?

// Когда программа запрашивает у пользователя ручной ввод путей к файлам скриптов,
// пользователь должен ввести полные или относительные пути
// к каждому файлу, разделенные запятыми.

// Примеры:
// 1. Если файлы скриптов находятся в той же директории, что и программа:
    Authors.sql, Books.sql, BooksAuthors.sql, Publishers.sql

// 2. Если файлы скриптов находятся в другой директории,
// 2.1 Можно указать относительные пути:
    scripts/Authors.sql, scripts/Books.sql, scripts/BooksAuthors.sql, scripts/Publishers.sql

// 2.2 Можно также указать полные пути к файлам:
    C:\path\to\scripts\Authors.sql, C:\path\to\scripts\Books.sql,
    C:\path\to\scripts\BooksAuthors.sql, C:\path\to\scripts\Publishers.sql

// 3. Для Unix-подобных систем (Linux, macOS):
/path/to/scripts/Authors.sql, /path/to/scripts/Books.sql,
/path/to/scripts/BooksAuthors.sql, /path/to/scripts/Publishers.sql

// Внимание:
// Пути к файлам должны быть разделены запятыми без дополнительных пробелов.

// Если путь содержит пробелы, его нужно заключить в двойные кавычки,
// Пример:
"C:\path with spaces\script.sql"

// Нужно убедитесь, что указанные пути и имена файлов
// являются правильными и соответствуют фактическому расположению файлов скриптов на вашем компьютере.

// Пример ввода путей при запросе программы:
// Введите пути к файлам скриптов (через запятую и пробел):
    path/to/scripts/Authors.sql, path/to/scripts/Books.sql,
    path/to/scripts/BooksAuthors.sql, path/to/scripts/Publishers.sql

// Программа разделяет введенную строку по запятым и будет обрабатывать каждый путь отдельно,
// выполняя операторы SQL из соответствующих файлов скриптов.

    public static void main(String[] args) throws IOException {
        // Открытие соединения с базой данных, создание объекта Statement и Scanner для чтения ввода пользователя
        try (Connection conn = getConnection();
             Statement stat = conn.createStatement();
             Scanner in = new Scanner(System.in)) {

            // Бесконечный цикл для обработки команд пользователя
            while (true) {
                // Вывод приглашения для ввода команды
                System.out.println("Enter command, LOAD FILES to load data from files, or EXIT to exit:");

                // Проверка наличия следующей строки ввода
                if (!in.hasNextLine()) {
                    // Если нет следующей строки, выход из программы
                    return;
                }

                // Чтение следующей строки ввода и удаление лишних пробелов
                String line = in.nextLine().trim();

                // Проверка, если введена команда "EXIT"
                if (line.equalsIgnoreCase("EXIT")) {
                    // Выход из программы
                    return;
                }

                // Проверка, если введена команда "LOAD FILES"
                if (line.equalsIgnoreCase("LOAD FILES")) {
                    // Проверка, если пути к файлам не были указаны в аргументах командной строки
                    if (args.length == 0) {
                        // Вывод сообщения о том, что пути к файлам не были указаны
                        System.out.println("No file paths provided as command-line arguments.");
                        // Запрос у пользователя ручного ввода путей к файлам скриптов
                        System.out.println("Please enter the paths to the script files (separated by commas):");
                        // Чтение введенных путей и удаление лишних пробелов
                        String filePaths = in.nextLine().trim();
                        // Разделение введенных путей по запятым и сохранение их в массиве args
                        args = filePaths.split(",");
                    }

                    // Цикл по каждому пути к файлу скрипта
                    for (String filePath : args) {
                        try {
                            // Чтение содержимого файла скрипта
                            String content = Files.readString(Path.of(filePath.trim()));
                            // Разделение содержимого файла на отдельные операторы SQL
                            String[] statements = content.split(";");

                            // Цикл по каждому оператору SQL
                            for (String sql : statements) {
                                // Удаление лишних пробелов из оператора SQL
                                sql = sql.trim();
                                // Проверка, если оператор SQL не пустой
                                if (!sql.isEmpty()) {
                                    // Выполнение оператора SQL с помощью метода executeStatement
                                    executeStatement(stat, sql);
                                }
                            }
                        } catch (IOException e) {
                            // Обработка исключения, если файл не найден или указан неверный путь
                            System.out.println("Warning: File not found or invalid path - " + filePath.trim());
                        }
                    }
                } else {
                    // Если введена обычная команда SQL
                    // Проверка, если команда заканчивается на ";"
                    if (line.endsWith(";")) {
                        // Удаление ";" из конца команды
                        line = line.substring(0, line.length() - 1);
                    }
                    // Выполнение команды SQL с помощью метода executeStatement
                    executeStatement(stat, line);
                }
            }
        } catch (SQLException e) {
            // Обработка исключения SQLException
            for (Throwable t : e) {
                // Вывод информации об исключении и трассировки стека
                t.printStackTrace();
            }
        }
    }

    private static void executeStatement(Statement stat, String sql) throws SQLException {
        try {
            // Выполнение оператора SQL и получение флага, указывающего, есть ли результат
            boolean isResult = stat.execute(sql);

            if (isResult) {
                // Если есть результат, получение ResultSet
                try (ResultSet rs = stat.getResultSet()) {
                    // Отображение содержимого ResultSet с помощью метода showResultSet
                    showResultSet(rs);
                }
            } else {
                // Если нет результата, получение количества обновленных строк
                int updateCount = stat.getUpdateCount();
                // Вывод количества обновленных строк
                System.out.println(updateCount + " rows updated");
            }
        } catch (SQLException e) {
            // Обработка исключения SQLException
            for (Throwable t : e) {
                // Вывод информации об исключении и трассировки стека
                t.printStackTrace();
            }
        }
    }



// Возникает проблема из-за некорректных путей к файлам SQL-скриптов.
// Когда вводишь пути, содержащие обратный слеш "\\",
// база данных воспринимает это как спецсимвол и выдает ошибку синтаксиса.

// Чтобы исправить эту проблему, попробуйте следующее:

// 1. Используйте прямой слеш "/" вместо обратного слеша "\\" в путях к файлам. Например:
        hortsmann_v_two/src/main/resources/_310/Books.sql
//    вместо
        hortsmann_v_two\src\main\resources\_310\Books.sql

// 2. Если нужно сохранить обратные слеши в путях, то нужно удвоить каждый обратный слеш,
//    чтобы база данных воспринимала его как обычный символ. Например:
        hortsmann_v_two\\src\\main\\resources\\_310\\Books.sql

// 3. Убедиться, что файлы SQL-скриптов действительно существуют по указанным путям
      и имеют правильные имена файлов.

// 4. Попробовать ввести полные абсолютные пути к файлам, начиная с корневого каталога, например:
        D:/filesEvgeniy/projects/mycoding/java/learnbooks/hortsmann_v_two/src/main/resources/_310/Books.sql

// Применив одно из этих решений, повторно выполнить команду "LOAD FILES"
// и ввести исправленные пути к файлам SQL-скриптов.

// Если ошибки сохраняются, то возможно проблема в самих файлах SQL-скриптов.
// Нужно убедитесь, что файлы содержат корректные SQL-запросы и не имеют синтаксических ошибок.


// Если прямой слеш не помогает и программа все равно пытается выполнить SQL-код вместо загрузки файлов,
то попробуем следующее:

// 1. Проверить содержимое файлов SQL-скриптов:
//    (`Books.sql`, `BooksAuthors.sql`, `Publishers.sql`).
//    Убедитеся, что они содержат только валидные SQL-запросы и не имеют синтаксических ошибок.
//    Если в файлах есть некорректный SQL-код, то это может приводить к ошибкам при попытке их выполнения.

// 2. Изменить логику программы, чтобы она явно различала команду "LOAD FILES" и обычные SQL-запросы.
//    Можно добавить проверку на точное совпадение с "LOAD FILES" (с учетом регистра)
//    и обрабатывать эту команду отдельно от остальных запросов.

// 3. При обработке команды "LOAD FILES" попробуйте считывать пути к файлам
//    из отдельной переменной, а не из общей строки ввода.
//    Это позволит избежать интерпретации путей как SQL-кода.

Пример изменений в коде:
if (line.equals("LOAD FILES")) {
    System.out.println("Enter the paths to the script files (separated by commas):");
    String filePaths = in.nextLine().trim();
    String[] paths = filePaths.split(",");
    for (String path : paths) {
        path = path.trim();
        try {
            String content = Files.readString(Path.of(path));
            String[] statements = content.split(";");
            for (String sql : statements) {
                sql = sql.trim();
                if (!sql.isEmpty()) {
                    executeStatement(stat, sql);
                }
            }
        } catch (IOException e) {
            System.out.println("Warning: File not found or invalid path - " + path);
        }
    }
} else {
    // Обработка обычных SQL-запросов
    if (line.endsWith(";")) {
        line = line.substring(0, line.length() - 1);
    }
    executeStatement(stat, line);
}

// В примере мы явно проверяем, что введенная команда равна "LOAD FILES",
// если это так, то запрашиваем у пользователя пути к файлам в отдельной строке.
// Затем мы разделяем введенные пути по запятым и обрабатываем каждый файл отдельно.

// Если ни одно из предложенных решений не помогает,
// возможно проблема кроется в самой логике программы или в настройках базы данных.
// В таком случае, потребуется более детальное изучение кода и конфигурации окружения.

// Можно попробовать отладить работу программы, и посмотреть,
// как именно обрабатываются введенные команды и пути к файлам.
// Это поможет выявить конкретное место, где возникает проблема.


// В скрипте Books.sql скрипты написаны в одну строку без переноса:
    CREATE TABLE Books (Title CHAR(60), ISBN CHAR(13), Publisher_Id CHAR(6), Price DECIMAL(10,2));
    INSERT INTO Books VALUES ('A Guide to the SQL Standard', '0-201-96426-0', '0201', 47.95);


//  Authors.sql во первых есть переносы:
    CREATE TABLE Authors
    (
    	Author_Id CHAR(4),
    	Name CHAR(25),
    	Fname CHAR(25)
    );

// Оператор INSERT INTO указан всего один раз и дальше значения перечисляются через запятую.
    INSERT INTO Authors VALUES
    ('ALEX', 'Alexander', 'Christopher'),
    ('BROO', 'Brooks', 'Frederick P.'),
    ...
    ('WEIS', 'Weise', 'Daniel');

// В скрипте `Books.sql` каждый оператор `INSERT INTO` указан отдельно для каждой строки данных,
// и все операторы написаны в одну строку без переносов.

// В скрипте `Authors.sql` используются переносы строк для форматирования кода,
// и оператор `INSERT INTO` указан только один раз, а значения перечисляются через запятую.

// Оба формата являются допустимыми в SQL, но могут по-разному обрабатываться
// в зависимости от настроек и особенностей используемой базы данных и инструментов.

// Чтобы исключить влияние форматирования на обработку скриптов,
// можно привести скрипт `Authors.sql` к формату, аналогичному скрипту `Books.sql`:

// Изменить скрипт `Authors.sql`, чтобы каждый оператор `INSERT INTO`
// был указан отдельно для каждой строки данных, и убрать переносы строк.

// sql код:
    CREATE TABLE Authors (Author_Id CHAR(4), Name CHAR(25), Fname CHAR(25));
    INSERT INTO Authors VALUES ('ALEX', 'Alexander', 'Christopher');
    INSERT INTO Authors VALUES ('BROO', 'Brooks', 'Frederick P.');
    -- ...
    INSERT INTO Authors VALUES ('WEIS', 'Weise', 'Daniel');
    SELECT * FROM Authors;

Если lанные не сохраняются в таблице `Authors`,
// то проблема может быть не связана с форматированием скрипта.
// В этом случае стоит проверить другие возможные причины, такие как:

// 1. Наличие ошибок в скрипте `Authors.sql` (опечатки, некорректные данные и т.д.).
// 2. Проблемы с правами доступа к базе данных или таблице `Authors`.
// 3. Некорректная обработка скриптов в самой программе.




// Вопрос:
// Можно ли модифицировать программу, чтобы она корректно обрабатывала скрипты
 с переносами строк и множественными значениями в одном операторе `INSERT INTO`?

// Попытка корректной обрабатки скриптов с переносами строк
// и множественными значениями в одном операторе `INSERT INTO`:
    private static void executeScript(Statement stat, String script) throws SQLException {
        String[] statements = script.split(";");
        for (String sql : statements) {
            sql = sql.trim();
            if (!sql.isEmpty()) {
                if (sql.toUpperCase().startsWith("INSERT INTO")) {
                    executeInsertStatement(stat, sql);
                } else {
                    executeStatement(stat, sql);
                }
            }
        }
    }

    private static void executeInsertStatement(Statement stat, String sql) throws SQLException {
        String[] lines = sql.split("\\r?\\n");
        StringBuilder sb = new StringBuilder();
        for (String line : lines) {
            line = line.trim();
            if (!line.isEmpty()) {
                if (line.endsWith(",")) {
                    sb.append(line).append(" ");
                } else {
                    sb.append(line);
                    executeStatement(stat, sb.toString());
                    sb.setLength(0);
                }
            }
        }
    }

// Добавлен новый метод `executeScript`, который разделяет скрипт
// на отдельные операторы SQL по точке с запятой (`;`)
// и обрабатывает каждый оператор отдельно.

// Если оператор начинается с `INSERT INTO` (без учета регистра),
// то он передается в метод `executeInsertStatement` для специальной обработки.
//      Метод `executeInsertStatement` разделяет оператор `INSERT INTO`
//      на отдельные строки по переносу строки (`\r?\n`).
//      Затем он объединяет строки, заканчивающиеся запятой (`,`), в один оператор `INSERT INTO`
//      и выполняет его с помощью метода `executeStatement`.



// Пример использования:
    String filePath = "path/to/Authors.sql";
    try {
        String content = Files.readString(Path.of(filePath));
        executeScript(stat, content);
    } catch (IOException e) {
        System.out.println("Warning: File not found or invalid path - " + filePath);
    }

// Выполняется чтение содержимого файла скрипта `Authors.sql`
// и выполняется передача его в метод `executeScript` для выполнения.

// После внесения этих изменений в код, программа должна быть способна обрабатывать скрипты
// с переносами строк и множественными значениями в одном операторе `INSERT INTO`.



// Полный код класса `ExecSQL` с учетом изменений для обработки скриптов
// с переносами строк и множественными значениями в одном операторе `INSERT INTO`:

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.sql.*;
import java.util.Scanner;

public class ExecSQLv2 {
    public static void main(String[] args) throws IOException {
        try (Scanner in = args.length == 0
                ? new Scanner(System.in)
                : new Scanner(Path.of(args[0]))) {
            try (Connection conn = getConnection();
                 Statement stat = conn.createStatement()) {
                while (true) {
                    if (args.length == 0) {
                        System.out.println("Enter command, LOAD FILES to load data from files, or EXIT to exit:");
                    }
                    if (!in.hasNextLine()) {
                        return;
                    }
                    String line = in.nextLine().trim();
                    if (line.equalsIgnoreCase("EXIT")) {
                        return;
                    }
                    if (line.equalsIgnoreCase("LOAD FILES")) {
                        System.out.println("Enter the paths to the script files (separated by commas):");
                        String filePaths = in.nextLine().trim();
                        String[] paths = filePaths.split(",");
                        for (String path : paths) {
                            path = path.trim();
                            try {
                                String content = Files.readString(Path.of(path));
                                executeScript(stat, content);
                            } catch (IOException e) {
                                System.out.println("Warning: File not found or invalid path - " + path);
                            }
                        }
                    } else {
                        if (line.endsWith(";")) {
                            line = line.substring(0, line.length() - 1);
                        }
                        executeStatement(stat, line);
                    }
                }
            }
        } catch (SQLException e) {
            for (Throwable t : e) {
                t.printStackTrace();
            }
        }
    }

    private static Connection getConnection() throws SQLException {
        String url = "jdbc:derby:booksdb";
        return DriverManager.getConnection(url);
    }

    private static void executeScript(Statement stat, String script) throws SQLException {
        String[] statements = script.split(";");
        for (String sql : statements) {
            sql = sql.trim();
            if (!sql.isEmpty()) {
                if (sql.toUpperCase().startsWith("INSERT INTO")) {
                    executeInsertStatement(stat, sql);
                } else {
                    executeStatement(stat, sql);
                }
            }
        }
    }

    private static void executeInsertStatement(Statement stat, String sql) throws SQLException {
        String[] lines = sql.split("\\r?\\n");
        StringBuilder sb = new StringBuilder();
        for (String line : lines) {
            line = line.trim();
            if (!line.isEmpty()) {
                if (line.endsWith(",")) {
                    sb.append(line).append(" ");
                } else {
                    sb.append(line);
                    executeStatement(stat, sb.toString());
                    sb.setLength(0);
                }
            }
        }
    }

    private static void executeStatement(Statement stat, String sql) throws SQLException {
        try {
            boolean isResult = stat.execute(sql);
            if (isResult) {
                try (ResultSet rs = stat.getResultSet()) {
                    showResultSet(rs);
                }
            } else {
                int updateCount = stat.getUpdateCount();
                System.out.println(updateCount + " rows updated");
            }
        } catch (SQLException e) {
            for (Throwable t : e) {
                t.printStackTrace();
            }
        }
    }

    private static void showResultSet(ResultSet result) throws SQLException {
        ResultSetMetaData metaData = result.getMetaData();
        int columnCount = metaData.getColumnCount();

        for (int i = 1; i <= columnCount; i++) {
            if (i > 1) {
                System.out.print(", ");
            }
            System.out.print(metaData.getColumnLabel(i));
        }
        System.out.println();

        while (result.next()) {
            for (int i = 1; i <= columnCount; i++) {
                if (i > 1) {
                    System.out.print(", ");
                }
                System.out.print(result.getString(i));
            }
            System.out.println();
        }
    }
}

// Основные изменения:

// 1. Добавлен метод `executeScript`, который разделяет скрипт
//    на отдельные операторы SQL по точке с запятой (`;`)
//    и обрабатывает каждый оператор отдельно.

// 2. Добавлен метод `executeInsertStatement`, который обрабатывает операторы `INSERT INTO`
//    с переносами строк и множественными значениями.
//    Он разделяет оператор на отдельные строки, объединяет строки, заканчивающиеся запятой (`,`),
//    в один оператор `INSERT INTO` и выполняет его.

// 3. В методе `main` добавлена обработка команды `LOAD FILES`.
//    При вводе этой команды программа запрашивает у пользователя
//    пути к файлам скриптов, разделенные запятыми.
//    Затем программа читает содержимое каждого файла
//    и передает его в метод `executeScript` для выполнения.

4. Остальной код класса остался без изменений.


// Вопрос:
// Откуда возникает Синтаксическая ошибка:
//      Encountered "<EOF>" at line 1, column 23 :
//      java.sql.SQLSyntaxErrorException: Синтаксическая ошибка: Encountered "<EOF>" at line 1, column 23.
//      ...


// Ошибка "Синтаксическая ошибка: Encountered "<EOF>" at line 1, column 23" возникает,
// когда парсер SQL достигает конца файла (EOF - End of File) раньше, чем ожидалось,
// то есть когда SQL-запрос не завершен корректно.

// В данном случае, эта проблема возникает из-за наличия комментария в конце файла:

// sql:
    -- DELETE FROM Authors;

// Когда парсер SQL читает файл и достигает этой строки, он ожидает,
// что после комментария будет корректный SQL-запрос.
// Поскольку комментарий является последней строкой в файле,
// парсер встречает конец файла (EOF) вместо ожидаемого запроса, что и вызывает ошибку.

// Чтобы исправить эту проблему, можно:
// - либо удалить комментарий в конце файла
// - либо добавить после комментария пустую строку
// - либо добавить другой корректный SQL-запрос

// Итог
// Что необходимо сделать чтобы выполнить подключение к данной БД:
// 1. В терминале - перейти в директорию с файлом  "derbyrun.jar"
//
// Можно воспользоваться вариатом подключения к бд и внесения в нее данных
// где не нужно запускать приложение ExecSQL.java
// 2. Открываем новый терминал и ввести команду, которая запускает утилиту "ij":
        command: java -jar .\derbyrun.jar ij -p .\ij.properties
//    далее вводим по одному команды на ввод в бд:
        command: run 'D:/filesEvgeniy/pr.../hortsmann_v_two/src/main/resources/_310/Books.sql';
        command: run 'D:/filesEvgeniy/pr.../hortsmann_v_two/src/main/resources/_310/Authors.sql';
        command: run 'D:/filesEvgeniy/pr.../hortsmann_v_two/src/main/resources/_310/BooksAuthors.sql';
        command: run 'D:/filesEvgeniy/pr.../hortsmann_v_two/src/main/resources/_310/Publishers.sql';

// Либо Запустить приложение "ExecSQL.java"
// 3. Следовать инструкциям приложения
// 4. Либо вводим команды SQL

// 5. Либо пишем "LOAD FILES"
// 6. Выполняем настройку запуска конфигурации ExecSQL.java
//    Нажимаем "Edit configuration":
//    В поле "Program arguments" указываем пути к файлам скриптов, разделенные пробелами:
    D:\filesEvgeniy\pr...\hortsmann_v_two\src\main\resources\_310\Authors.sql
    D:\filesEvgeniy\pr...\hortsmann_v_two\src\main\resources\_310\Books.sql
    D:\filesEvgeniy\pr...\hortsmann_v_two\src\main\resources\_310\BooksAuthors.sql
    D:\filesEvgeniy\pr...\hortsmann_v_two\src\main\resources\_310\Publishers.sql

// 7. Либо после команды: "LOAD FILES"
//    После появления строки: Введите пути к файлам скриптов (через запятую и пробел):
//    Указываем относительные пути к файлам скриптов:
        hortsmann_v_two/src/main/resources/_310/Authors.sql,
        hortsmann_v_two/src/main/resources/_310/Books.sql,
        hortsmann_v_two/src/main/resources/_310/BooksAuthors.sql,
        hortsmann_v_two/src/main/resources/_310/Publishers.sql
//    Пути пишуться в одну строку после запятой, без переносов на следующую строку и дополнительных пробелов

// Выбираем для работы более удобный вариант


// page 312
// 5.5 Выполнение запросов (Query Execution)

// Пример программы, способной выполнять запросы к базе данных COREJAVA.
// Для нормальной работы этой программы необходимо создать и заполнить таблицы в базе данных COREJAVA,
// как пояснялось в предыдущем разделе.

// При составлении запроса базы данных можно выбрать:
// автора книги и издательство
// или же оставить критерий отбора книги,
// независимо от автора или издательства.

// Данная программа позволяет также вносить изменения в содержимое базы данных.
// Для этого достаточно выбрать издательство и ввести сумму.

// Все цены на книги данного издательства автоматически откорректируются по введенной сумме,
// а программа отобразит количество измененных строк в таблице.

// После подобной коррекции цен на книги можно выполнить запрос,
// чтобы проверить новые цены.


// page 313
// 5.5.1 Подготовленные операторы для зпросов (Prepared Statements)

// В программе используется новое средство:
//  - подготовленные операторы (Prepared Statements).

// Запрос SQL на выборку всех книг отдельного издательства независимо от их авторов:
    SELECT Books.Price, Books.Title
    FROM Books, Publishers
    WHERE Books.Publisher_Id = Publishers.Publishers_Id
    AND Publishers.Name = название издательства выбранного из списка (the name from the list box)

// Вместо того чтобы создавать отдельный оператор SQL для каждого пользовательского запроса,
// можно заранее подготовить запрос с главной переменной и многократно использовать его,
// меняя только значение этой переменной.

// Такая возможность существенно повышает эффективность работы программы.

// Перед обработкой каждого запроса база данных вырабатывает план его эффективного исполнения.
// Подготавливая запрос для последующего многократного применения,
// можно исключить повторное планирование его выполнения.

// Каждая главная переменная в запросе обозначается знаком вопроса(?).
// Если в запросе используется несколько главных переменных,
// необходимо внимательно следить за их расстановкой с помощью знаков вопроса,
// чтобы правильно устанавливать их конкретные значения.

// Показано, как выглядит в исходном коде предварительно подготовленный запрос
// к базе данных COREJAVA:
    String publisherQuery = "SELECT Books.Price, Books.Title "
        + "FROM Books, Publishers "
        + "WHERE Books.Publishers_Id = Publishers.Publishers_Id "
        + "AND Publishers.Name = ?";
    PreparedStatment = stat = conn.prepareStatement(publisherQuery);

// Перед выполнением подготовленного оператора
// необходимо связать главные переменные с их конкретными значениями,
// вызвав метод set().

// Подобно разным формам метода get() из интерфейса ResultSet,
// для разных типов данных предусмотрены отдельные формы метода set().

// В качестве примера задается строковое значение с названием издательства:
    stat.setString(1, publisher);

// 1й аргумент: этого метода задает номер позиции главной переменной,
//              обозначаемой знаком вопроса в подготовленном операторе,
// 2й аргумент: ее конкретное значение. Так, аргумент 1 задает первый знак "?".

// При повторном использовании подготовленного запроса с несколькими главными переменными
// все их привязки к конкретным значениям остаются в силе,
// если только они не изменены с помощью методов:
// - set()
// - clearParameters()

// Это означает, что метод setXxx(),
// где Ххх - тип данных, следует вьвывать только для тех главных переменных,
// которые изменяются в последующих запросах.

// После привязки всех переменных к их конкретным значениям
// можно приступить к выполнению подготовленного оператора следующим образом:
    ResultSet rs = stat.executeQuery();

// Составление запроса вручную путем сцепления символьных строк
// - довольно трудоемкое, чреватое ошибками и небезопасное занятие.

// В этом случае нужно позаботиться об обозначении специальных символов [например, кавычек].

// Если при составлении запроса предполагается ввод пользователем данных,
// необходимо принять меры защиты от умышленного внесения запросов SQL
// при совершении атак на сервер базы данных.

// В этом отношении подготовленные операторы оказываются намного более удобными,
// и поэтому их рекомендуется применять всякий раз, когда в запрос включаются переменные.

// Обновление цены осуществляется в операторе UPDATE.
// Для этого вьвывается метод executeUpdate(), а не executeQuery().

// Дело в том, что оператор UPDATE не возвращает результирующий набор,
// который в данном случае не требуется.

// Метод executeUpdate() - возвращает лишь подсчет количества изменных строк в таблице:
    int r = stat.executeUpdate();
    System.out.println(r + " rows updated");

// Объект типа PreparedStatement становится недействительным после того,
// как связанный с ним объект типа Connection закрывается.

// Но многие драйверы баз данных автоматически кешируют подготовленные операторы.
// Если один и тот же запрос подготавливается дважды,
// то в базе данных еще раз используется план его выполнения.

// -> вызывая метод prepareStatement(),
// можно не особенно беспокоиться об издержках на выполнение подготовленных операторов.

// Здесь вкратце описывается порядок действий,
// выполняемых в рассматриваемой программы:
// • Списочные массивы заполняются именами авторов и названиями издательств по двум запросам,
     из которых возвращаются все имена авторов и названия издательств, сохраняемые в базе данных.

// • Запросы по имени автора имеют более сложную структуру.
//   Т.к. у одной книги может быть, несколько авторов,
//   поэтому в таблице BooksAuthors сохраняется соответствие авторов и книг.
//   Допустим, у книги с ISBN 0-20196426-0 два автора с идентификаторами DATE и DARW.
//   Для отражения этого факта таблица BooksAuthors должна содержать следующие строки:
        0-201-96426-0, DATE, 1
        0-201-96426-0, DARW, 2

// • В третьем столбце указаны порядковые номера авторов.
//   Для этой цели нельзя использовать сведения о расположении строк в таблице,
//   поскольку в реляционной базе данных порядок следования записей не фиксирован.
//   -> в составляемом запросе следует сначала соединить таблицы
//      - Books
//      - BooksAuthors
//      - Authors
//  а затем сравнить в них имя автора с тем, что указано пользователем:
    SELECT Books.Price, Books.Title
    FROM Books, BooksAuthors, Authors, Publishers
    WHERE Authors.Author_Id = BooksAuthors.Author_Id
    AND BooksAuthors.ISBN = Books.ISBN
    AND Books.Publisher_Id = Publishers.Publisher_Id
    AND Authors.Name = ?
    AND Publishers.Name = ?

// Некоторые программирующие на Java стараются избегать составления столь сложных запросов SQL.
// Как ни странно, они выбирают обходной, но неэффективный путь,
// предполагающий написание немалого объема кода на Java
// для последовательной обработки нескольких результирующих наборов.

// Следует иметь в виду, что база данных выполняет запросы намного эффективнее,
// чем программа на Java, поскольку база данных именно для этого и предназначена.

// -> нужно взять на вооружение следующее эмпирическое правило:
// то, что можно сделать средствами SQL,
// нецелесообразно делать средствами Java.

// Метод changePrices() выполняет оператор UPDATE.
// В предложении WHERE этой команды требуется указать код издательства,
// но нам известно лишь его название.
// Это затруднение разрешается с помощью вложенного запроса:
    UPDATE Books
    SET Price = Price + ?
    WHERE Books.Publisher_Id = (SELECT Publisher_Id FROM Publishers WHERE Name = ?)

// *где (SELECT Publisher_Id FROM Publishers WHERE Name = ?) - подзапрос или вложенный запрос/подзапрос.

// Другой пример использования вложенного подзапроса:
    UPDATE Books
    SET Price = Price + 5
    WHERE Publisher_Id = (SELECT Publisher_Id FROM Publishers WHERE Name = 'Acme')

// Вложенный подзапрос выбирает идентификатор издателя (Publisher_Id) из таблицы Publishers,
// где название издателя (Name) равно 'Acme'.
// Затем этот идентификатор используется во внешнем операторе UPDATE
// для обновления цен книг, соответствующих данному издателю.

// Такой подход позволяет выполнить обновление цен книг на основе названия издателя,
// даже если мы не знаем непосредственно код издателя.

// Исходный код данной программы приведен в листинге 5.3
// (ru/sectorsj/_315_query/QueryTest.java)


// page 321
// 5.5.2 Чтение и запись больших объектов (Reading and Writing LOBs)

// *(LOBs) - большие объекты (large objects)

// Помимо чисел, символьных строк и дат,
// во многих базах данных можно сохранять большие объекты (LOB),
// к числу которых относятся изображения и другие данные.

// В языке SQL понятие больших объектов разделяется на категории:
// - большие двоичные (binary) объекты (BLOB)
// - большие символьные (character) объекты (CLOB)

// Чтобы прочитать большой объект, необходимо сначала выполнить команду SELECT,
// затем вызвать метод:
// - getBlob()
//      или
// - getClob()
// из интерфейса ResultSet.

// В результате будет получен объект типа:
// - Blob
// или
// - Clob

// Для того чтобы получить двоичные данные из объекта типа Blob,
// следует вызвать метод:
// - getBytes()
// или
// - getinputStream()

// Если имеется таблица с изображениями на книжных обложках,
// то такое изображение можно получить следующим образом:
    PreparedStatement stat = conn.prepareStatement("SELECT Cover FROM BookCovers WHERE ISBN = ?");
    ...
    stat.set(1, isbn);
    try (ResultSet result = stat.executeQuery()) {
        if (result.next()) {
            Blob coverBlob = result.getBlob(1);
            Image coverImage = ImageIO.read(coverBlob.getBinaryStream());
        }
    }

// Аналогично, если извлечь объект типа Clob,
// то из него можно получить символьные данные,
// вызвав метод:
// - String()
// или
// - getCharacterStream()

// Чтобы разместить большой объект в базе данных,
// 1. следует вызвать метод:
//    - createLOB()
//         или
//    - createClob()
//    для объекта типа Connection

// 2. получить
//    - поток вывода
//          или
//    - поток записи
//    для большого объекта,

// 3. записать данные

// 4. сохранить этот объект в базе данных.

// Пример как сохранить изображение в базе данных:
    Blob coverBlob = conn.createBlob();
    int offset = 0;
    OutputStream out = coverBlob.setBinaryStream(offset);
    ImageIO.write(coverImage, "PNG", out);
    PreparedStatement stat = conn.prepareStatement("INSERT INTO Cover VALUES (?, ?)");
    stat.set(1, isbn);
    stat.set(2, coverBlob);
    stat.executeUpdate();


// page 321
// 5.5.3 Синтаксис переходов в SQL (SQL Escapes)

// Синтаксис переходов (escape) предоставляет средства,
// которые обычно поддерживаются базами данных,
// но в разных вариантах в зависимости от конкретного синтаксиса базы данных.

// В задачу драйвера JDBC входит
// преобразование синтаксиса переходов
// в синтаксис конкретной базы данных.

// Переходы предусмотрены для следующих средств:
//  - Литералы времени и даты           (Date and time literals)
//  - Вызовы скалярных функций          (Calling scalar functions)
//  - Вызовы хранимых процедур          (Calling stored procedures)
//  - Внешние соединения                (Outer joins)
//  - Символы перехода в операциях LIKE (The escape character in LIKE clauses)

// Литералы даты и времени сильно отличаются в разных базах данных.

// Чтобы вставить литерал даты или времени, следует определить его значение в формате ISO 8601
// https://www.cl.cam.ac.uk/~mgk25/iso-time.html
// После этого драйвер преобразует литерал в собственный формат базы данных.

// 1. Для значений типа:
//    - DATE
//    - TIME
//    - TIMESTAMP

//    используются литералы:
//    - d
//    - t
//    - ts

//    следующим образом:
//    {d '2008-01-24'}
//    {t '23:59:59'}
//    {ts '2008-01-24 23:59:59.999'}

// 2. Скалярна функция - функция, которая возращает одно значение.
//    В базах данных применяется немало скалярных функций, но под разными именами.

//    В спецификации JDBC указаны стандартные имена,
//    преобразуемые в специфические имена, для конкретных баз данных.

//    Чтобы вызвать скалярную функцию, нужно вставить ее стандартное имя и аргументы:
       {fn left (?, 20)}
       {fn user()}

//    Полный список поддерживаемых имен скалярных функций можно найти в спецификации JDBC.

// 3. Хранимая процедура - процедура, которая выполняется в базе данных
//                         и написана на специальном языке для конкретной базы данных.

//    Для вызова хранимой процедуры служит переход call.

//    Если у процедуры отсутствуют параметры, то указывать скобки не нужно.
//    Для фиксации возвращаемого значения служит знак равенства.

//    Каким образом вызываются хранимые процедуры:
        {call PROC1(?, ?)}
        {call PROC2}
        {call ? = PROC3(?)}

// 4. Внешнее соединение (Outer join) двух таблиц не требует,
//    чтобы строки из каждой таблицы совпадали по условию соединения.

//    В приведенном запросе указаны книги, для которых столбец Publisher_Id
//    не имеет совпадений в таблице Publishers,
//    причем пустые значения NULL обозначают отсутствие совпадений.
        SELECT * FROM {oj Books LEFT OUTER JOIN Publishers
        ON Books.Publisher Id = Publisher.Publisher_Id}

// Чтобы включить в запрос издательства без совпадающих книг,
// может потребоваться предложение RIGHT OUTER JOIN,
// а чтобы возвратить по запросу и то и другое - предложение FULL OUTER JOIN.

// Синтаксис переходов требуется именно потому,
// что не во всех базах данных используется стандартное обозначение внешних соединений.

// 5. Знаки "_" и "%" имеют специальное назначение в операции LIKE,
//    обозначая совпадение с одним символом или последовательностью символов.

//    Стандартного способа их буквального употребления не существует.
//    Для сопоставления всех символьных строк, содержащих знак "_",
//    можно воспользоваться конструкцией:
        ... WHERE ? LIKE %!_% {escape '!'}
//    где, "!"  - знак определен как символ перехода,
//         "!_" - последовательность знаков, обозначает знак подчеркивания.


// page 323
// 5.5.4 Множественные результаты (Multiple Results)

// По запросу могут быть возвращены множественные результаты (Multiple Results).
// Это может произойти при выполнении хранимой процедуры или в базах данных,
// которые допускают также выполнение многих операторов SELECT в одном запросе.

// Получить все результирующие наборы можно следующим образом:
// 1. Вызвать метод execute() для выполнения оператора SQL.
// 2. Получить первый результат или подсчет обновлений.
// 3. Повторить вызов метода getMoreResults(), чтобы перейти к следующему результирующему набору.
// 4. Завершить процедуру, если больше не остается результирующих наборов или подсчетов обновлений.

// Методы:
// - execute()
// - getMoreResults()
// возвращают логическое значение true,
// если следующим звеном в цепочке оказывается результирующий набор.

// Метод get.UpdateCount() возвращает значение -1,
// если следующим звеном в цепочке не оказывается подсчет обновлений.

// В следующем цикле осуществляется последовательный обход всех полученных результатов:
         boolean isResult = stat.execute(command);
         boolean done = false;
         while(!done) {
             if (isResult) {
                 ResultSet result = stat.getResultSet();
                 // Сделать что-нибудь с полученным результатом в переменной result
             } else {
                 int updateCount = stat.getUpdateCount();
                 if (updateCount >= 0) {
                     // Сделать что-нибудь с подсчетом обновлений в переменной updateCount
                 } else{
                     done = true
                 }
             }
             if (!done) {
                 isResult = stat.getMoreResults();
             }
         }


// page 324
// 5.5.5 Извлечение автоматически генерируемых ключей (Retrieving Autogenerated Keys)

// В большинстве баз данных поддерживается механизм автоматической нумерации строк в таблице.
// У разных поставщиков баз данных эти механизмы заметно отличаются.

// Автоматически присваиваемые номера часто используются н качестве первичных ключей.
// Несмотря на то что в JDBC не предлагается независимое
// от особенностей разных баз данных решение для генерирования подобных ключей,
// в этом прикладном интерфейсе предоставляется эффективный способ их извлечения.

// Если при вводе новой строки в таблицу автоматически генерируется ключ,
// его можно получить с помощью следующего кода:
    stmt.executeUpdate(insertStatement, Statement.RETURN_GENERATED_KEYS);
    ResultSet rs = stmt.getGeneratedKeys();
    if (rs.next()) {
        int key = rs.getInt(1);
        // ...
    }