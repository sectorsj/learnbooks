// For notes
https://horstmann.com/corejava/index.html

// Предисловие                                                      - 13
// Глава 1. Потоки данных                                           - 19
// Глава 2. Ввод и вывод                                            - 71
// Глава 3. XML                                                     - 163
// Глава 4. Работа в сети                                           - 235
// Глава 5. Работа с базами данных                                  - 287
// Глава 6. Прикладной интерфейс API даты и времени                 - 353
// Глава 7. Интернационализация                                     - 377
// Глава 8. Написание сценариев, компиляция и обработка аннотаций   - 435
// Глава 9. Модульная система на платформе Java                     - 493
// Глава 10. Безопасность                                           - 521
// Глава 11. Расширенные средства Swing и графика                   - 601
// Глава 12. Платформенно-ориентированные методы                    - 787
// Предметный указатель                                             - 849

// Глава 1 Библиотека потоков данных в Java,
//           придающая современные черты обработке данных благодаря тому,
//           что программисту достаточно указать, что именно ему требуется,
//           не вдаваясь в подробности, как получить желаемый результат.
//           Такой подход позволяет уделить в библиотеке потоков данных
//           основное внимание оптимальной эволюционной стратегии,
//           которая дает особые преимущества при оптимизации параллельных вычислений.

// Глава 2 Организация ввода-вывода. В языке Java весь ввод-вывод
//         осуществляется через так называемые потоки ввода-вывода
//         (не путать с потоками данных, рассматриваемыми в главе 1).
//         Позволяют единообразно обмениваться данными между различными источниками,
//         включая файлы, сетевые соединения и блоки памяти.
//         Приводится подробное описание классов чтения и записи в потоки ввода-вывода,
//         упрощающие обработку данных в Юникоде.
//         Рассматривается внутренний механизм сериализации объектов,
//         который делает простым и удобным сохранение и загрузку объектов.
//         Обсуждаются регулярные выражения, а также особенности манипулирования файлами и путями к ним.
//         Будут представлены усовершенствования системы ввода-вывода в последних версиях Java.

// Глава 3 XML. Каким образом осуществляется синтаксический анализ ХМL-файлов,
//         формируется ХМL-разметка и выполняются ХSL-преобразования.
//         Демонстрируется разметка компоновки Swing-фopмы в формате XML.
//         Рассматривается прикладной интерфейс API XPath,
//         значительно упрощающий поиск мелких подробностей в больших объемах данных формата XML.

// Глава 4 Прикладной интерфейс API для работы в сети.
//         В языке Java чрезвычайно просто решаются сложные задачи сетевого программирования.
//         Как устанавливаются сетевые соединения с серверами,
//         реализуются собственные серверы и организуется связь по сетевому протоколу HTTP.
//         Новый HTTP-клиент.

// Глава 5 Программирование баз данных.
//         Основное внимание уделяется JDBC - прикладному интерфейсу
//         для организации доступа к базам данных из приложений на Java,
//         который позволяет прикладным программам на Java
//         устанавливать связь с реляционными базами данных.
//         Полезные программы для выполнения рутинных операций с настоящими базами данных,
//         с применением только самых основных средств интерфейса JDBC.
//         Краткие сведения об интерфейсе JNDI (Java Naming and Directory Interface)
//         - интерфейс именования и каталогов Java
//         и протоколе LDAP (Lightweight Directory Access Protocol)
//         упрощенный протокол доступа к каталогам).

// Глава 6 Как преодолевать трудности организации календарей и оперирования часовыми поясами,
//         используя новую библиотеку даты и времени.
//         Ранее в библиотеках Java были предприняты
//         две безуспешные попытки организовать обработку даты и времени.
//         Третья попытка была успешно предпринята в версии Java 8.

// Глава 7 Вопросы интернационализации, важность которой, будет со временем только возрастать.
//         Java относится к тем немногочисленным языкам программирования,
//         где с самого начала предусматривалась возможность обработки данных в Юникоде,
//         но поддержка интернационализации в Java этим не ограничивается.
//         Интернационализация прикладных программ на Java
//         позволяет сделать их независимыми не только от платформы, но и от страны применения.
//         Как написать прикладную программу
//         для расчета времени выхода на пенсию с выбором английского, немецкого или китайского языка.

// Глава 8 Три разные методики обработки исходного кода.
//         Прикладные интерфейсы API для сценариев и компилятора дают возможность
//         вызывать в программе на Java код, написанный на каком-нибудь языке сценариев,
//         например JavaScript или Groovy, и компилировать, его в код Java.
//         Аннотации позволяют вводить в программу на Java произвольную информацию
//         (иногда еще называемую метаданными).
//         Каким образом обработчики аннотаций собирают аннотации на уровне источника
//         и на уровне файлов классов и как с помощью аннотаций оказывается воздействие
//         на поведение классов во время выполнения.
//         Аннотации выгодно использовать вместе с подходящими инструментальными средствами,
//         и материал этой главы поможет читателю научиться выбирать
//         именно те средства обработки аннотаций,
//         которые в наибольшей степени отвечают его потребностям.

// Глава 9 Модульная система на платформе java, внедренная в версии Java 9
//         для того, чтобы способствовать нормальной эволюции самой платформы и базовых библиотек Java.
//         Эта модульная система обеспечивает инкапсуляцию пакетов
//         и предоставляет механизм для описания требований к модулям.
//         Свойства модулей, на основании которых можно решить,
//         стоит ли применять модули в ваших приложениях.
//         Даже если решите не применять их, все равно должны знать новые правила модуляризации,
//         чтобы взаимодействовать с платформой Java и другими библиотеками, имеющими модульную организацию.

// Глава 10 Модель безопасности Java.
//          Платформа Java с самого начала разрабатывалась с учетом безопасности.
//          Объясняется, что именно позволяет ей обеспечивать безопасность.
//          Демонстрируется, как создавать свои собственные загрузчики классов
//          и диспетчеры защиты для специальных приложений.
//          Прикладной интерфейс API для безопасности,
//          который позволяет оснащать приложения важными средствами
//          вроде механизма цифровых подписей сообщений и кода,
//          а также авторизации, аутентификации и шифрования.
//          Примеров, в которых применяются такие алгоритмы шифрования, как AES и RSA.

// Глава 11 Весь материал по библиотеке Swing, не вошедший в первый том данной книги.
//          Описание важных и сложных компонентов деревьев и таблиц.
//          Прикладной интерфейс Java 2D API
//          для воспроизведения реалистичных графических изображений и спецэффектов.
//          Функциональные средства для формирования изображений на сервере.

// Глава 12 Платформенно-ориентированные методы, которые позволяют вызывать функции,
//          специально написанные для конкретной платформы, например Microsoft Windows.
//          Очевидно, что данное языковое средство является спорным,
//          ведь применение платформенно-ориентированных методов
//          сводит на нет все межплатформенные преимущества java.
//          Серьезно занимающийся разработкой на Java приложений для конкретных платформ,
//          должен знать и уметь пользоваться платформенно-ориентированными средствами.
//          Ведь иногда возникают ситуации, когда требуется обращаться к
//          прикладному интерфейсу API операционной системы целевой платформы
//          для взаимодействия с устройствами или службами,
//          которые не поддерживаются на платформе Java.
//          Организация доступа из программы на Java к прикладному интерфейсу API
//          системного реестра Windows.

----------------------------------------------------------------------------------------------------




// page 287
// 5 Глава: Работа с базами данных (Database Programming)

// 5.1  Структура JDBC (The Design of JDBC)
// 5.2  Язык SQL (The Structured Query Language)
// 5.3  Конфигурирование JDBC (JDBC Configuration)
// 5.4  Работа с операторами JDBC (Working with JDBC Statements)
// 5.5  Выполнение запросов (Query Execution)
// 5.6  Прокручиваемые и обновляемые результирующие наборы (Scrollable and Updatable Result Sets)
// 5.7  Наборы строк (Row Sets)
// 5.8  Метаданные (Metadata)
// 5.9  Транзакции (Transactions)
//      Расширенные типы данных SQL
// 5.10 Управление подключением к базам данных в веб- и корпоративных приложениях
//      (Connection Management in Web and Enterprise Applications)


// page 288
// 5.1 Структура JDBC (The Design of JDBC)

// Создатели Java с самого начала осознавали потенциальные преимущества данного языка
// для работы с базами данных.
// С 1995 года они начали работать над расширением стандартной библиотеки Java
// для организации доступа к базам данных средствами SQL.

// Сначала они попробовали создать такие расширения Java,
// которые позволили бы осуществлять доступ
// к произвольной базе данных только средствами Java,
// но очень скоро убедились в бесперспективности такого подхода,
// т.к. для доступа к базам данных применялись самые разные протоколы.

// Поставщики программного обеспечения баз данных
// были весьма заинтересованы в разработке на Java стандартного сетевого протокола
// для доступа к базам данных, при условии,
// что за основу будет принят их собственный сетевой протокол.

// В конечном счете:
// - поставщики баз данных
// - инструментальных средств для доступа к ним
// сошлись на том, что лучше предоставить прикладной интерфейс API только на Java
// для доступа к базам данных средствами SQL, а также диспетчер драйверов,
// который позволил бы подключать к базам драйверы независимых производителей.

// Такой подход позволял поставщикам баз данных создавать собственные драйверы,
// которые подключались бы с помощью данного диспетчера.

// Предполагалось, что это будет простой механизм регистрации сторонних драйверов.

// Подобная организация прикладного интерфейса JDBC
// основана на весьма удачной модели интерфейса ODBC,
// разработанного в корпорации Microsoft.

// В основу интерфейсов JDBC и ODBC положен общий принцип:
// программы, написанные в соответствии с требованиями прикладного интерфейса API,
// способны взаимодействовать с диспетчером драйверов JDBC,
// который, использует подключаемые драйверы для обращения к базе данных.

// Это означает, что для работы с базами данных в прикладных программах
// достаточно пользоваться средствами JDBC API.


// page 288
// 5.1.1 Типы драйверов JDBC (JDBC Driver Types)

// Каждый драйвер JDBC относится к одному из перечисленных типов:

// Драйвер:
// Тип 1: Преобразует интерфейс JDBC в ODBC.
//        Для взаимодействия с базой данных использует драйвер ODBC.
//        Один такой драйвер был включен в первые версии Java под названием мост JDBC/ODBC.
//        Но для его применения требуется установить и настроить соответствующим образом драйвер ODBC.
//        В первом выпуске JDBC этот мост предполагалось использовать только для тестирования,
//        а не для применения в рабочих программах.
//        В настоящее время уже имеется достаточное количество более удачных драйверов,
//        поэтому пользоваться мостом JDBC/ODBC не рекомендуется.

// Тип 2: Написан частично на Java и отчасти использует платформенно-ориентированный код
//        для взаимодействия с клиентским прикладным интерфейсом API базы данных.
//        Для применения такого драйвера, помимо библиотеки Java,
//        на стороне клиента необходимо установить код, специфический для конкретной платформы.

// Тип 3: Разрабатывается только на основе клиентской библиотеки Java,
//        в которой используется независимый от базы данных протокол передачи запросов базы данных на сервер.
//        Этот протокол приводит запросы базы данных в соответствие с характерным для нее протоколом.
//        Развертывание прикладных программ значительно упрощается благодаря тому,
//        что код, зависящий от конкретной платформы, находится только на сервере.

// Тип 4: Представляет собой библиотеку, написанную только на Java,
//        для приведения запросов JDBC в соответствие с протоколом конкретной базы данных.

// Спецификация прикладного интерфейса JDBC доступна для загрузки по адресу:
// https://jcp.org/en/jsr/detail?id=221

// Большинство поставщиков баз данных предоставляют драйверы 3 или 4 типа.
// Целый ряд сторонних производителей специализируется на создании драйверов,
// которые позволяют добиться более полного соответствия принятым стандартам,
// поддерживают большее количество платформ,
// обладают более высокой производительностью или надежностью, чем драйверы,
// предлагаемые поставщиками баз данных.

// Основные цели прикладного интерфейса JDBC:
// 1. Разработчики пишут программы на Java, пользуясь для доступа к базам данных
//    стандартными средствами языка SQL или его специализированными расширениями,
//    следуя только соглашениям, принятым в Java.

// 2. Поставщики баз данных и инструментальных средств к ним
//    предоставляют драйверы только низкого уровня.
//    Это дает им возможность оптимизировать драйверы под свою конкретную продукцию.


// page 290
// 5.1.2 Типичные примеры применения JDBC (Typical Uses of JDBC)

// Согласно традиционной модели "клиент-сервер" графический пользовательский интерфейс (ГПИ)
// реализуется на стороне клиента, а базы данных располагается на стороне сервера (рис. 5.1)
// (resources/_290/pic_5_1.JPG)

// В этом случае драйвер JDBC развертывается на стороне клиента.

// В настоящее время существует тенденция по переходу:
// от архитектуры "клиент-сервер"
// к трехуровневой модели (three-tier)
//  или
// n-уровневой модели

// В трехуровневой модели:
// клиент не формирует обращения к базе данных.
// Он обращается к средствам промежуточного уровня на сервере,
// который, выполняет запросы к базе данных.

// Трехуровневая модель, обладает преимуществами.
// Она отделяет:
// 1. визуальное представление (на клиентском компьютере)
// 2. бизнес-логику (на промежуточном уровне)
// 3. исходных данных (хранящихся в базе данных).

// -> Становится возможным доступ к тем же самым данным
// по одинаковым бизнес-правилам со стороны разнотипных клиентов,
// в том числе:
//  - прикладных программ на java
//  - веб-браузеров
//  - приложений для мобильных устройств

// Взаимодействие между клиентом и промежуточным уровнем
// может быть реализовано по сетевому протоколу НТТР.

// JDBC - прикладной интерфейс, который служит для управления взаимодействием между:
// - промежуточным уровнем
// - серверной базой данных

// На рис. 5.2 (resources/_290/pic_5_2.JPG)
// схематически показана основная архитектура трехуровневой модели.


// page 291
// 5.2 Язык SQL (Structured Query Language)

// Прикладной интерфейс JDBC позволяет взаимодействовать с базами данных посредством языка SQL,
// который, образует интерфейс для большинства современных реляционных баз данных.

// Настольные базы данных предоставляют графический интерфейс,
// который дает пользователям возможность непосредственно манипулировать данными,
// но доступ к серверным базам данных возможен только средствами языка SQL.

// Пакет JDBC можно рассматривать лишь как прикладной интерфейс API
// для взаимодействия с операторами языка SQL с целью получить доступ к базам данных.

// Краткое описание языка SQL.
// Если не приходилось раньше иметь дело с SQL, то сведений,
// представленных в этом разделе, может оказаться недостаточно.

// Для более досконального изучения основ SQL
// можно порекомендовать книгу:
// Learning SQL Алана Болью (Alan Beaulieu; издательство O'Reilly, 2009 г.)
//      или
// Learn SQL The Hard Way Зеда А. Шоу (Zed А. Shaw),
//оперативно доступную в электронном виде для заказа по адресу:
// http://sql.learncodethehardway.org/

// База данных представляет собой набор именованных таблиц со строками и столбцами.
// Каждый столбец имеет свое имя, а данные хранятся в строках.
// В качестве примера базы данных здесь и далее рассматривается ряд таблиц
// с описаниями библиотеки классических книг по вычислительной технике (табл. 5.1-5.4).

// Таблица 5.1. Таблица "Authors"
// |------------|-----------|--------------|
// | Author_ID  |    Name   |     Fname    |
// |------------|-----------|--------------|
// | ALEX       | Alexander | Christopher  |
// | ВRОО       | Brooks    | Frederick Р. |
// |------------|-----------|--------------|

// Таблица 5.2. Таблица "Books"
// |----------------------------------------------------|---------------|--------------|-------|
// |                        Title                       |      ISBN     | Publisher_ID | Price |
// |----------------------------------------------------|---------------|--------------|-------|
// | А Guide to the SQL Standard                        | 0-201-96426-0 |     0201     | 47.95 |
// | А Pattern Language: Towns, Buildings, Construction | 0-19-501919-9 |     019      | 65.00 |
// | ...                                                | ...           |     ...      | ...   |
// |----------------------------------------------------|---------------|--------------|-------|

// Таблица 5.3. Таблица "BooksAuthors"
// |---------------|-----------|--------|
// |      ISBN     | Author_ID | Seq_No |
// |---------------|-----------|--------|
// | 0-201-96426-0 | DATE      |   1    |
// | 0-201-96426-0 | DARW      |   2    |
// | 0-19-501919-9 | ALEX      |   1    |
// | ...           | ...       |  ...   |
// |---------------|-----------|--------|

// Таблица 5.4. Таблица "Publishers"
// |--------------|-------------------|---------------|
// | Publisher_ID |        Name       |      URL      |
// |--------------|-------------------|---------------|
// | 0201         | Addison-Wesley    | www.aw-bc.com |
// | 0407         | John Wiley & Sons | www.wiley.com |
// | ...          | ...               | ...           |
// |--------------|-------------------|---------------|

// на рис. 5.3 (resources/_293/pic_5_3.JPG) - представлена таблица Books
// на рис. 5.4 (resources/_293/pic_5_4.JPG) - представлен результат соединения таблиц Books и Publishers

// Обе таблицы содержат идентификатор издателя.
// При соединении таблиц по этому идентификатору получается результат запроса в виде таблицы,
// содержащей данные из обеих исходных таблиц.

// В каждой строке этой таблицы содержатся сведения о:
// - книге
// - название
// - адрес веб-сайта издательства

// Данные с названием книги и адресом веб-сайта неоднократно дублируются,
// поскольку в результирующей таблице оказывается несколько строк,
// относящихся к одному и тому же издательству.

// Объяснение:
// В данном примере мы имеем четыре таблицы:
// - "Authors"
// - "Books"
// - "BooksAuthors"
// - "Publishers"

// Эти таблицы представляют собой реляционную базу данных,
// где информация о книгах, авторах и издателях хранится в отдельных таблицах.

// Таблица "Authors":
// содержит информацию об авторах,
// включая их идентификатор (Author_ID), имя (Name) и полное имя (Fname).

// Таблица "Books":
// содержит информацию о книгах,
// включая название (Title), ISBN (уникальный идентификатор книги),
// идентификатор издателя (Publisher_ID) и цену (Price).

// Таблица "BooksAuthors":
// является связующей таблицей,
// которая устанавливает связь между книгами и авторами.
// Каждая строка в этой таблице представляет собой связь между:
// - книгой (идентифицируемой по ISBN)
// - автором (идентифицируемым по Author_ID).
// Поле Seq_No указывает порядок авторов для каждой книги.

// Таблица "Publishers":
// содержит информацию об издателях, включая их идентификатор (Publisher_ID),
// название (Name) и URL-адрес веб-страницы (URL).

// Рисунок 5.3 показывает представление таблицы "Books",
// которое содержит информацию о книгах.
// Однако, в этом представлении только идентификатор издателя (Publisher_ID),
// но нет его названия и URL-адреса.

// Можно объединить таблицы "Books" и "Publishers" по полю Publisher_ID,
// чтобы получить более полную информацию.
// Это называется операцией соединения (join) в реляционных базах данных.

// Результат объединения таблиц "Books" и "Publishers" показан на рисунке 5.4.
// В этом результате каждая строка содержит информацию о книге:
// - название
// - ISBN
// - цену
// вместе с соответствующим названием издателя и его URL-адресом.

// При объединении таблиц возможно дублирование информации
// об издателях в результирующем наборе данных.
// Это происходит потому, что у одного издателя может быть несколько книг.
// В таких случаях информация об издателе (название и URL-адрес)
// будет повторяться для каждой книги этого издателя.

// Объединение таблиц является мощным инструментом в реляционных базах данных,
// который позволяет связывать данные из разных таблиц
// и получать более полную и осмысленную информацию.

// Это позволяет эффективно хранить данные в нормализованной форме (разделенными по таблицам)
// и при необходимости объединять их для получения желаемого результата.

// Преимущество соединения таблиц заключается в том,
// что при этом удается избежать нежелательного дублирования данных.

// Например, в простейшей структуре баз данных таблица "Books"
// может содержать столбцы с названием и адресом веб-сайта издательства.
// Но в таком случае данные будут дублироваться уже не только в результате запроса,
// но и в самой базе данных.

// При изменении адреса веб-сайта придется также изменить эти данные во всех записях в базе данных.
// При выполнении столь трудоемкой задачи могут легко возникнуть, ошибки.

// В реляционной модели данные распределяются среди нескольких таблиц таким образом,
// чтобы они не дублировались без особой надобности.

// Например, адрес веб-сайта каждого издательства хранится в единственном экземпляре
// в таблице с данными об издательствах.
// При необходимости данные из разных таблиц нетрудно соединить, в результате запроса.

// На рис. 5.3 и 5.4 показано графическое инструментальное средство,
// предназначенное для просмотра и связывания таблиц.
// Многие поставщики программного обеспечения предлагают разнообразные диалоговые инструментальные средства
// для создания запросов путем манипулирования столбцами и ввода данных в готовые формы.

// Они называются инструментальными средствами составления "запросов по образцу" (QBE) (query by example).
// А при использовании SQL запрос создается в текстовом виде в строгом соответствии
// с синтаксисом этого языка, как показано ниже:
    SELECT Books.Title Books.Publisher_Id, Books.Price, Publishers.Name, Publishers.URL
    FROM Books, Publishers
    WHERE Books.Publisher_Id = Publisher.Publisher_Id

// Здесь описываются основные способы создания подобных запросов базы данных.
// Читатели, знакомые с SQL, могут пропустить этот материал.

// Ключевые слова SQL принято вводить прописными буквами,
// хотя это правило не является обязательным.

// SELECT - оператор, может применяться в самых разных целях,
// в т.ч. для выбора всех элементов из таблицы Books по следующему запросу:
    SELECT * FROM Books;

// Предложение FROM обязательно указывается в каждом операторе SELECT.
// В этом предложении базе данных сообщается о тех таблицах,
// в которых требуется выполнить поиск данных.

// В операторе SELECT можно указать любые требующиеся столбцы следующим образом:
    SELECT ISBN, Price, Title
    FROM Books;

// Выбор строк можно ограничить с помощью условия, указываемого в предложении WHERE:
    SELECT ISBN, Price, Title
    FROM Books
    WHERE Price <= 29.95

// Для сравнения в SQL используются операции:
//  = и <>      // нужно использовать в SQL
//  == или !=   // не нужно использовать в SQL
как при программировании на Java.

// Некоторые поставщики баз данных используют операцию "!=" для обозначения сравнения,
// но такое обозначение не соответствует стандарту SQL, поэтому пользоваться ей не рекомендуется.

// В предложении WHERE может присутствовать операция LIKE
// для сопоставления с заданным шаблоном.
// Но вместо символов подстановки:
// "*"
// "?"
// В SQL также употребляются знаки:
// "%" - обозначает любое количество символов
// "_" - обозначает один символ

// Задача:
// Запрос на выборку книг, в названиях которых отсутствует такое слово, как UNIX или Linux:
    SELECT ISBN, Price, Title
    FROM Books
    WHERE Title NOT LIKE '%n_x';

// В запросах базы данных символьные строки заключаются в одиночные, а не в двойные кавычки.
// Одиночная кавычка в символьной строке обозначается парой одиночных кавычек,
// как в приведенном ниже примере запроса на поиск всех книг,
// в названиях которых содержится одиночная кавычка.
    SELECT Title
    FROM Books
    WHERE Title LIKE '%''%'

// Чтобы выбрать данные из нескольких таблиц, их нужно перечислить в следующем порядке:
    SELECT * FROM Books, Publishers

// Без предложения WHERE такой запрос не представляет большого интереса,
// поскольку по нему получаются все сочетания строк из обеих таблиц.
// В данном случае:
// таблица Books      - содержит 20 строк
// таблица Publishers - содержит 8 строк

// -> результат выполнения такого запроса будет содержать 20 х 8 строк
// с большим количеством дублирующихся данных.

// Задача:
// Требуется найти только те книги, которые выпущены издательствами,
// перечисленными в таблице Publishers.
// Для обнаружения такого соответствия книг издательствам
// можно составить приведенный ниже запрос:
    SELECT * FROM Books, Publishers
    WHERE Books.Publishers_Id = Publishers.Publishers_Id

// Результат выполнения этого запроса содержит 20 строк,
// т.е. по одной строке на каждую книгу,
// поскольку на каждую книгу в таблице Publishers приходится лишь одно издательство.

// Если в запросе указано несколько таблиц,
// то в двух разных местах может упоминаться одно и то же имя столбца,
// как в показанном выше примере
// столбец Publisher_Id из таблицы Books и аналогичный столбец
// Publisher Id из таблицы Publishers.

// Во избежание неоднозначной интерпретации имен столбцов
// их следует предварять префиксом с именем таблицы:
// Books.Publisher_Id.

// Языковыми средствами SQL можно пользоваться и для изменения информации в базе данных.
// Задача:
// Требуется снизить на 5 долларов текущую цену всех книг,
// в названиях которых содержится подстрока "С++".
// С этой целью можно составить следующий запрос:
    UPDATE Books
    SET Price = Price - 5.00
    WHERE Title LIKE '%C++%'

// Для удаления всех книг по С++ понадобится оператор DELETE,
// как показано в приведенном ниже примере запроса.
    DELETE FROM Books
    WHERE Title LIKE '%C++%'

// В языке SQL предусмотрены также встроенные функции для:
// - вычисления средних значений,
// - поиска максимальных и минимальных значений в столбце
// - и многое другое.

// INSERT - оператор для ввода новых данных в таблицу:
    INSERT INTO Books
    VALUES ('А Guide to the SQL Standard', '0-201-96426-0', '0201', 47.95)

// Для ввода каждой строки в таблицу приходится выполнять отдельный оператор INSERT.
// Но прежде чем составлять запросы, изменять и вводить данные,
// необходимо предоставить место для их хранения, т.е. создать таблицу.

// CREATE TABLE - оператор для создания новой таблицы.

// В CREATE TABLE указывается имя и тип данных каждого столбца:
    CREATE TABLE Books
    (
        Title CHAR(60),
        ISBN CHAR(13),
        Publisher_Id CHAR(6),
        Price DECIMAL(10,2)
    )

// В табл. 5.5 перечислены наиболее распространенные типы данных в SQL.

// Дополнительные предложения и операции, задающие ключи и ограничения,
// употребляемые в операторе CREATE TABLE, здесь не рассматриваются.

// Таблица 5.5. Типы данных SQL
// |------------------------------|------------------------------------------------------------------|
// | Типы данных                  |                           Описание                               |
// |------------------------------|------------------------------------------------------------------|
// | INTEGER или INT              | Обычно 32-разрядное целое значение                               |
// | SМALLINT                     | Обычно 16-разрядное целое значение                               |
// | NUМERIC(m, n), DECIМAL(m, n) | Десятичное числовое значение с фиксированной точкой,             |
// | или DEC (m, n)               | содержащее "m" цифр, в том числе "n" знаков после точки          |
// | FLOAT (n)                    | Числовое значение с плавающей точкой и точностью до "n" знаков   |
// | REAL                         | Обычно 32-разрядное числовое значение с плавающей точкой         |
// | DOUВLE                       | Обычно 64-разрядное числовое значение с плавающей точкой         |
// | CНARACTER (n) или СНАR (n)   | Строка фиксированной длины "n" символов                          |
// | VARCНAR(n)                   | Строка неременной длины максимум "n" символов                    |
// | BOOLEAN                      | Логическое значение                                              |
// | DATE                         | Календарная дата (зависит от реализации)                         |
// | ТIМЕ                         | Время (зависит от реализации)                                    |
// | ТIМЕSТАМР                    | Дата и время (зависят от реал1вации)                             |
// | BLOB                         | Большой двоичный объект                                          |
// | CLOB                         | Большой символьный объект                                        |
// |------------------------------|------------------------------------------------------------------|


// page 296
// 5.3 Конфигурирование JDBC (JDBC Configuration)

// Для работы с базой данных потребуется система управления базой данных (СУБД),
// для которой в прикладном интерфейсе JDBC имеется подходящий драйвер.

// Среди имеющихся СУБД можно выбрать следующие:
// - IВМ DB2
// - Microsoft SQL Server
// - MySQL
// - Oracle
// - PostgreSQL

// Далее необходимо создать экспериментальную базу данных, например, под названием COREJAVA.

// Задача:
// 1. Создайть новую базу данных самостоятельно
// или
// 2. Попросите сделать это администратора баз данных и наделить вас правами на:
// - создание таблиц
// - обновление таблиц
// - удаление таблиц

// Если не приходилось раньше устанавливать базу данных с архитектурой "клиент-сервер",
// то процесс ее установки, конечно, покажется вам очень сложным,
// а обнаружить причину возможной неудачи будет совсем не просто.

// -> рекомендуется обратиться к услугам опытных специалистов.

// Если отсутствует опыт работы с базами данных,
// рекомендуется установить сначала базу данных Apache Derby,
// доступную для загрузки по адресу:
//  http://db.apache.org/derby

// Чтобы запустить базу данных Apache Derby, выполним следующие шаги:

// 1. Убедитеся, что установлена Java Development Kit (JDK), так как Apache Derby написана на Java.

// 2. Загружаем дистрибутив Apache Derby с официального сайта:
//    https://db.apache.org/derby/downloads/index.html
//    т.к. мы используем Java 17...
//    файл: db-derby-10.16.1.1-bin.zip
// 3. Распаковываем загруженный архив в удобное для вас место.

// 4. Открыть командную строку или терминал и перейдите в каталог:
//    - lib
//    где находится файл derbyrun.jar, внутри распакованного дистрибутива Derby.

// 5. Чтобы запустить сервер Derby в сетевом режиме, выполните команду:
        command: java -jar derbyrun.jar server start

//    Эта команда запустит сервер Derby и позволит подключаться к нему по сети.

// 6. Чтобы создать и подключиться к базе данных Derby, выполните команду:
        command: java -jar derbyrun.jar ij
//    Эта команда запустит интерактивную оболочку Derby (ij),
//    где можно выполнять SQL-запросы и управлять базой данных.

//    В оболочке ij можно создать новую базу данных, используя команду
        command: CONNECT 'jdbc:derby:mydb;create=true';
//    Эта команда создаст базу данных:
//    - mydb
//    и подключится к ней.

//    Если база данных уже существует, она просто подключится к ней.

// 7. Теперь можно выполнять SQL-запросы и работать с базой данных через оболочку ij.

// 8. Чтобы выйти из оболочки ij, введите:
        command: exit

// Это основные шаги для запуска и начала работы с базой данных Apache Derby.
// Derby также предоставляет возможность встраивать базу данных.

// Дополнительно:
// Чтобы подключиться к уже созданной базе данных Apache Derby, выполните следующие шаги:

// 1. Убедитесь, что сервер Apache Derby запущен.
// 2. Если сервер не запущен, выполните следующую команду в терминале:
        command: java -jar derbyrun.jar server start
// 3. В своем Java-приложении добавьте зависимость Apache Derby (например, derby.jar) в classpath.

// 4. Установите соединение с базой данных с помощью URL-адреса подключения в формате:
        command: jdbc:derby://localhost:1527/имя_базы_данных
//    имя_базы_данных - фактическое имя вашей базы данных Derby.

// 5. Пример кода для подключения:
        String url = "jdbc:derby://localhost:1527/MyDatabase";
        Connection conn = DriverManager.getConnection(url);

// 6. Если вы используете аутентификацию, укажите:
//    - имя пользователя
//    - пароль
//    при установлении соединения:
        String url = "jdbc:derby://localhost:1527/MyDatabase";
        String username = "your_username";
        String password = "your_password";
        Connection conn = DriverManager.getConnection(url, username, password);

// 7. После успешного подключения можно выполнять SQL-запросы
//    и взаимодействовать с базой данных, используя объект:
//    - Connection conn

// 8. Когда закончите работу с базой данных, не забудьте закрыть соединение:
        conn.close();
//    Обратите внимание, что URL-адрес подключения предполагает,
//    что сервер Derby работает на локальном компьютере (localhost) и использует порт по умолчанию (1527).

// 9. Если сервер работает на другом хосте или порту,
//    нужно соответствующим образом изменить URL-адрес подключения.

//10. Убедиться, что указанная база данных существует и доступна.
//    Если база данных не найдена, будет получено исключение типа:
//    - SQLException


// page 297
// 5.3.1 URL баз данных (Database URLs)

//  Для подключения к базе данных необходимо указать ряд характерных для нее параметров.
// К их числу могут относиться:
// - имена хостов
// - номера портов
// - имена баз данных

// В прикладном интерфейсе JDBC используется синтаксис описания источника данных,
// подобный обычным URL.

// Примеры такого синтаксиса:
    jdbc:derby://localhost:1527/COREJAVA;create=true
    jdbc:postgresql:COREJAVA

// Эти URL определяют в JDBC базы данных Derby и PostgreSQL по имени COREJAVA.
// Общая синтаксическая форма записи URL в JDBC:
    jdbc:подчиненный_протокол:другие_сведения
// 1. подчиненный_ протокол - специальный драйвер для соединения с базой данных,
// 2. другие_сведения - формат, который зависит от применяемого подчиненного протокола.

// По поводу выбора конкретного формата
// следует обращаться к документации на применяемую базу данных.


// page 297
// 5.3.2 Архивные JAR-файлы драйверов (Driver JAR Files)

// Нужно получить архивный JАR-файл, в котором находится драйвер для выбранной базы данных.

// Если пользуется база данных Derby, то понадобится файл derbyclient.jar.
// Если же это другая база данных, придется найти для нее подходящий драйвер.

// Драйверы для базы данных PostgreSQL доступны для загрузки по адресу:
// https://jdbc.postgresql.org

// При запуске программы, обращающейся к базе данных,
// в командной строке следует указать архивный JАR-файл драйвера после параметра -classpath.

// Для компиляции самой программы архивный JАR-файл драйвера не требуется.

// Для запуска подобных программ из командной строки
// можно воспользоваться приведенной ниже командой.

// "." - знак обозначающий текущий каталог в Windows.
// Он отделяется от местонахождения архивного JАR-файла драйвера точкой с запятой.

    command: java -classpath nуть_к_файлу_драйвера:. имя_программы

// В IntelliJ IDEA можно настроить конфигурацию запуска (Run Configuration) для вашей программы,
// чтобы указать путь к драйверу базы данных.

// Шаги, которые нужно выполнить:

// 1. Откройте ваш проект в IntelliJ IDEA

// 2. В правом верхнем углу найдите выпадающий список конфигураций запуска (рядом с зеленой кнопкой "Run")
//    и нажмите "Edit Configurations".

// 3. В открывшемся окне нажмите на "+" (плюс) в левом верхнем углу
//    и выберите "Application" из выпадающего списка.

// 4. Дайте конфигурации запуска имя. Например:
//    "MyDatabaseApp"

// 5. В поле "Main class" укажите полное имя класса вашей программы,
//    содержащего метод main. Например:
//    com.example.MyDatabaseApp

// 6. В поле "VM options" введите параметр -classpath со значением,
//    указывающим путь к JAR-файлу драйвера. Например:
      command: -classpath /path/to/driver/postgresql.jar

// 7. Замените "/path/to/driver/postgresql.jar" на фактический путь к вашему JAR-файлу драйвера.

// 8. В поле "Working directory" укажите путь к папке с вашим проектом.
//    Обычно это корневая папка проекта.

// 9. Нажмите "Apply" и затем "OK", чтобы сохранить конфигурацию запуска.

// Теперь можно запустить вашу программу, используя созданную конфигурацию запуска.
// Для этого выберите "MyDatabaseApp" (или другое указанное вами имя)
// из выпадающего списка конфигураций и нажмите зеленую кнопку "Run".

// Если путь к вашему JAR-файлу драйвера, (к примеру PostgreSQL) следующий:
//      C:\Program Files\Java\jdbc\drivers\postgresql-42.4.0.jar

// В поле "VM options" конфигурации запуска в IntelliJ IDEA нужно указать:
    command:-classpath "C:\Program Files\Java\jdbc\drivers\postgresql-42.4.0.jar"

// Важные моменты:
// 1. Путь указывается в двойных кавычках, так как он содержит пробелы.
// 2. Слеши "/" заменены на обратные слеши "\", так как это путь в Windows.
// 3. Не нужно добавлять точку "." в конце, так как IntelliJ IDEA автоматически включает путь
// к классам вашего проекта в classpath.

// Конфигурация запуска в IntelliJ IDEA должна выглядеть примерно так:

// Name:                MyDatabaseApp
// Main class:          com.example.MyDatabaseApp (замените на фактическое имя вашего класса)
// VM options:          -classpath "C:\Program Files\Java\jdbc\drivers\postgresql-42.4.0.jar"
// Working directory:   /path/to/your/project (путь к корневой папке вашего проекта)

// После сохранения этой конфигурации можно запустить программу,
// используя драйвер PostgreSQL, выбрав "MyDatabaseApp"
// из выпадающего списка конфигураций и нажав зеленую кнопку "Run".


// page 297
// 5.3.3 Запуск базы данных (Starting the Database)

// Прежде чем подключиться к серверу базы данных, его нужно запустить.
// Подробности этого процесса зависят от конкретной базы данных.

// Для запуска базы данных "Derby" выполните следующие действия:

// 1. Открыть командную оболочку (терминал) и перейти в каталог, в котором находятся файлы базы данных.

// 2. Найдите архивный файл:
//    - "derbyrun.jar"
//    В одних версиях JDK он может находиться в каталоге jdk/db/lib,
//    в других - в отдельном установочном каталоге JavaDB.

//    Каталог, содержащий папку с архивным файлом:
//    - "lib/derbyrun.jar"
//    будет обозначается здесь и далее как "derby".

// 3. Выполните следующую команду:
        command: java -jar derby/lib/derbyrun.jar server start
// 4. Еще раз проверьте, работает ли база данных должным образом.
//    Создайте файл ij.properties, введя в него следующие строки:
//        ij.driver=org.apache.derby.jdbc.ClientDriver
//        ij.protocol=jdbc:derby://localhost:1527/
//        ij.database=COREJAVA;create=true

// 5. Запустите в другой копии командной оболочки диалоговое инструментальное средство
//    для написания сценариев базы данных Derby (оно называется ij), выполнив следующую команду:
        command: java -jar derby/lib/derbyrun.jar ij -р ij.properties

// 6. Теперь можно выдать команды SQL, например, следующие:
//    CREATE TABLE Greetings(Message CHAR(20));
//    INSERT INTO Greetings VALUES ('Hello, World!');
//    SELECT * fROM Greetings;
//    DROP TABLE Greetings;

// 7. Каждая команда должна завершаться точкой с запятой.
//    Чтобы выйти из режима ввода команд SQL, введите команду:
//    EXIT;

// 8. Завершив работу с базой данных, остановите ее сервер,
//    выполнив следующую команду:
        command: java -jar derby/lib/derbyrun.jar server shutdown

// Если вы польуетесь, другой базой данных, нужно найти в документации на нее
// сведения о запуске и остановке сервера базы данных,
// а также о том, как подключаться к нему и выполнять команды SQL.


// page 298
// 5.3.4 Регистрация класса драйвера (Registering the Driver Class)

// Многие архивные JАR-файлы прикладного интерфейса JDBC
// например, драйвер базы данных Apache Derby автоматически регистрируют класс драйвера.

// В этом случае вы можете пропустить этап ручной регистрации,
// рассматриваемый в этом разделе.

// Архивный JАR-файл может автоматически зарегистрировать класс драйвера,
// если он содержит файл:
// META-INF/services/java.sql.Driver

// Чтобы убедиться в этом, можно распаковать архивный JАR-файл драйвера.

// Если архивный JАR-файл драйвера не поддерживает автоматическую регистрацию,
// придется выяснить имена классов драйверов JDBC,
// используемых поставщиком базы данных.

// Типичными именами классов драйверов являются следующие:
// - org.apache.derby.jdbc.ClientDriver
// - org.postgresql.Driver

// Зарегистрировать драйвер с помощью класса DriverManager можно двумя способами:
// 1. Загрузить класс драйвера в программу на Java,
//    как показано в приведенной ниже строке кода, где выполняется статический инициализатор,
//    который и осуществляет регистрацию загружаемого драйвера.
        Class.forName("org.postgresql.Driver"); // принудительная загрузка класс драйвера

// 2. Задать свойство jdbc.drivers, которое можно указать
//    в качестве аргумента непосредственно в командной строке:
        java -Djdbc.drivers=org.postgresql.Driver имя_програнны

// Можно установить системное свойство в своей прикладной программе, сделав следующий вызов:
    System.setProperty("jdbc.drivers", "org.postgresql.Driver");

// При необходимости можно указать несколько разных драйверов, разделив их двоеточием:
    org.postgresql.Driver:org.apache.derby.jdbc.ClientDriver