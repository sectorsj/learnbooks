// For notes
https://horstmann.com/corejava/index.html

// Предисловие                                                      - 13
// Глава 1. Потоки данных                                           - 19
// Глава 2. Ввод и вывод                                            - 71
// Глава 3. XML                                                     - 163
// Глава 4. Работа в сети                                           - 235
// Глава 5. Работа с базами данных                                  - 287
// Глава 6. Прикладной интерфейс API даты и времени                 - 353
// Глава 7. Интернационализация                                     - 377
// Глава 8. Написание сценариев, компиляция и обработка аннотаций   - 435
// Глава 9. Модульная система на платформе Java                     - 493
// Глава 10. Безопасность                                           - 521
// Глава 11. Расширенные средства Swing и графика                   - 601
// Глава 12. Платформенно-ориентированные методы                    - 787
// Предметный указатель                                             - 849

// Глава 1 Библиотека потоков данных в Java,
//           придающая современные черты обработке данных благодаря тому,
//           что программисту достаточно указать, что именно ему требуется,
//           не вдаваясь в подробности, как получить желаемый результат.
//           Такой подход позволяет уделить в библиотеке потоков данных
//           основное внимание оптимальной эволюционной стратегии,
//           которая дает особые преимущества при оптимизации параллельных вычислений.

// Глава 2 Организация ввода-вывода. В языке Java весь ввод-вывод
//         осуществляется через так называемые потоки ввода-вывода
//         (не путать с потоками данных, рассматриваемыми в главе 1).
//         Позволяют единообразно обмениваться данными между различными источниками,
//         включая файлы, сетевые соединения и блоки памяти.
//         Приводится подробное описание классов чтения и записи в потоки ввода-вывода,
//         упрощающие обработку данных в Юникоде.
//         Рассматривается внутренний механизм сериализации объектов,
//         который делает простым и удобным сохранение и загрузку объектов.
//         Обсуждаются регулярные выражения, а также особенности манипулирования файлами и путями к ним.
//         Будут представлены усовершенствования системы ввода-вывода в последних версиях Java.

// Глава 3 XML. Каким образом осуществляется синтаксический анализ ХМL-файлов,
//         формируется ХМL-разметка и выполняются ХSL-преобразования.
//         Демонстрируется разметка компоновки Swing-фopмы в формате XML.
//         Рассматривается прикладной интерфейс API XPath,
//         значительно упрощающий поиск мелких подробностей в больших объемах данных формата XML.

// Глава 4 Прикладной интерфейс API для работы в сети.
//         В языке Java чрезвычайно просто решаются сложные задачи сетевого программирования.
//         Как устанавливаются сетевые соединения с серверами,
//         реализуются собственные серверы и организуется связь по сетевому протоколу HTTP.
//         Новый HTTP-клиент.

// Глава 5 Программирование баз данных.
//         Основное внимание уделяется JDBC - прикладному интерфейсу
//         для организации доступа к базам данных из приложений на Java,
//         который позволяет прикладным программам на Java
//         устанавливать связь с реляционными базами данных.
//         Полезные программы для выполнения рутинных операций с настоящими базами данных,
//         с применением только самых основных средств интерфейса JDBC.
//         Краткие сведения об интерфейсе JNDI (Java Naming and Directory Interface)
//         - интерфейс именования и каталогов Java
//         и протоколе LDAP (Lightweight Directory Access Protocol)
//         упрощенный протокол доступа к каталогам).

// Глава 6 Как преодолевать трудности организации календарей и оперирования часовыми поясами,
//         используя новую библиотеку даты и времени.
//         Ранее в библиотеках Java были предприняты
//         две безуспешные попытки организовать обработку даты и времени.
//         Третья попытка была успешно предпринята в версии Java 8.

// Глава 7 Вопросы интернационализации, важность которой, будет со временем только возрастать.
//         Java относится к тем немногочисленным языкам программирования,
//         где с самого начала предусматривалась возможность обработки данных в Юникоде,
//         но поддержка интернационализации в Java этим не ограничивается.
//         Интернационализация прикладных программ на Java
//         позволяет сделать их независимыми не только от платформы, но и от страны применения.
//         Как написать прикладную программу
//         для расчета времени выхода на пенсию с выбором английского, немецкого или китайского языка.

// Глава 8 Три разные методики обработки исходного кода.
//         Прикладные интерфейсы API для сценариев и компилятора дают возможность
//         вызывать в программе на Java код, написанный на каком-нибудь языке сценариев,
//         например JavaScript или Groovy, и компилировать, его в код Java.
//         Аннотации позволяют вводить в программу на Java произвольную информацию
//         (иногда еще называемую метаданными).
//         Каким образом обработчики аннотаций собирают аннотации на уровне источника
//         и на уровне файлов классов и как с помощью аннотаций оказывается воздействие
//         на поведение классов во время выполнения.
//         Аннотации выгодно использовать вместе с подходящими инструментальными средствами,
//         и материал этой главы поможет читателю научиться выбирать
//         именно те средства обработки аннотаций,
//         которые в наибольшей степени отвечают его потребностям.

// Глава 9 Модульная система на платформе java, внедренная в версии Java 9
//         для того, чтобы способствовать нормальной эволюции самой платформы и базовых библиотек Java.
//         Эта модульная система обеспечивает инкапсуляцию пакетов
//         и предоставляет механизм для описания требований к модулям.
//         Свойства модулей, на основании которых можно решить,
//         стоит ли применять модули в ваших приложениях.
//         Даже если решите не применять их, все равно должны знать новые правила модуляризации,
//         чтобы взаимодействовать с платформой Java и другими библиотеками, имеющими модульную организацию.

// Глава 10 Модель безопасности Java.
//          Платформа Java с самого начала разрабатывалась с учетом безопасности.
//          Объясняется, что именно позволяет ей обеспечивать безопасность.
//          Демонстрируется, как создавать свои собственные загрузчики классов
//          и диспетчеры защиты для специальных приложений.
//          Прикладной интерфейс API для безопасности,
//          который позволяет оснащать приложения важными средствами
//          вроде механизма цифровых подписей сообщений и кода,
//          а также авторизации, аутентификации и шифрования.
//          Примеров, в которых применяются такие алгоритмы шифрования, как AES и RSA.

// Глава 11 Весь материал по библиотеке Swing, не вошедший в первый том данной книги.
//          Описание важных и сложных компонентов деревьев и таблиц.
//          Прикладной интерфейс Java 2D API
//          для воспроизведения реалистичных графических изображений и спецэффектов.
//          Функциональные средства для формирования изображений на сервере.

// Глава 12 Платформенно-ориентированные методы, которые позволяют вызывать функции,
//          специально написанные для конкретной платформы, например Microsoft Windows.
//          Очевидно, что данное языковое средство является спорным,
//          ведь применение платформенно-ориентированных методов
//          сводит на нет все межплатформенные преимущества java.
//          Серьезно занимающийся разработкой на Java приложений для конкретных платформ,
//          должен знать и уметь пользоваться платформенно-ориентированными средствами.
//          Ведь иногда возникают ситуации, когда требуется обращаться к
//          прикладному интерфейсу API операционной системы целевой платформы
//          для взаимодействия с устройствами или службами,
//          которые не поддерживаются на платформе Java.
//          Организация доступа из программы на Java к прикладному интерфейсу API
//          системного реестра Windows.

----------------------------------------------------------------------------------------------------




// page 287
// 5 Глава: Работа с базами данных (Database Programming)

// 5.1  Структура JDBC (The Design of JDBC)
// 5.2  Язык SQL (The Structured Query Language)
// 5.3  Конфигурирование JDBC (JDBC Configuration)
// 5.4  Работа с операторами JDBC (Working with JDBC Statements)
// 5.5  Выполнение запросов (Query Execution)
// 5.6  Прокручиваемые и обновляемые результирующие наборы (Scrollable and Updatable Result Sets)
// 5.7  Наборы строк (Row Sets)
// 5.8  Метаданные (Metadata)
// 5.9  Транзакции (Transactions)
//      Расширенные типы данных SQL
// 5.10 Управление подключением к базам данных в веб- и корпоративных приложениях
//      (Connection Management in Web and Enterprise Applications)


// page 288
// 5.1 Структура JDBC (The Design of JDBC)

// Создатели Java с самого начала осознавали потенциальные преимущества данного языка
// для работы с базами данных.
// С 1995 года они начали работать над расширением стандартной библиотеки Java
// для организации доступа к базам данных средствами SQL.

// Сначала они попробовали создать такие расширения Java,
// которые позволили бы осуществлять доступ
// к произвольной базе данных только средствами Java,
// но очень скоро убедились в бесперспективности такого подхода,
// т.к. для доступа к базам данных применялись самые разные протоколы.

// Поставщики программного обеспечения баз данных
// были весьма заинтересованы в разработке на Java стандартного сетевого протокола
// для доступа к базам данных, при условии,
// что за основу будет принят их собственный сетевой протокол.

// В конечном счете:
// - поставщики баз данных
// - инструментальных средств для доступа к ним
// сошлись на том, что лучше предоставить прикладной интерфейс API только на Java
// для доступа к базам данных средствами SQL, а также диспетчер драйверов,
// который позволил бы подключать к базам драйверы независимых производителей.

// Такой подход позволял поставщикам баз данных создавать собственные драйверы,
// которые подключались бы с помощью данного диспетчера.

// Предполагалось, что это будет простой механизм регистрации сторонних драйверов.

// Подобная организация прикладного интерфейса JDBC
// основана на весьма удачной модели интерфейса ODBC,
// разработанного в корпорации Microsoft.

// В основу интерфейсов JDBC и ODBC положен общий принцип:
// программы, написанные в соответствии с требованиями прикладного интерфейса API,
// способны взаимодействовать с диспетчером драйверов JDBC,
// который, использует подключаемые драйверы для обращения к базе данных.

// Это означает, что для работы с базами данных в прикладных программах
// достаточно пользоваться средствами JDBC API.


// page 288
// 5.1.1 Типы драйверов JDBC (JDBC Driver Types)

// Каждый драйвер JDBC относится к одному из перечисленных типов:

// Драйвер:
// Тип 1: Преобразует интерфейс JDBC в ODBC.
//        Для взаимодействия с базой данных использует драйвер ODBC.
//        Один такой драйвер был включен в первые версии Java под названием мост JDBC/ODBC.
//        Но для его применения требуется установить и настроить соответствующим образом драйвер ODBC.
//        В первом выпуске JDBC этот мост предполагалось использовать только для тестирования,
//        а не для применения в рабочих программах.
//        В настоящее время уже имеется достаточное количество более удачных драйверов,
//        поэтому пользоваться мостом JDBC/ODBC не рекомендуется.

// Тип 2: Написан частично на Java и отчасти использует платформенно-ориентированный код
//        для взаимодействия с клиентским прикладным интерфейсом API базы данных.
//        Для применения такого драйвера, помимо библиотеки Java,
//        на стороне клиента необходимо установить код, специфический для конкретной платформы.

// Тип 3: Разрабатывается только на основе клиентской библиотеки Java,
//        в которой используется независимый от базы данных протокол передачи запросов базы данных на сервер.
//        Этот протокол приводит запросы базы данных в соответствие с характерным для нее протоколом.
//        Развертывание прикладных программ значительно упрощается благодаря тому,
//        что код, зависящий от конкретной платформы, находится только на сервере.

// Тип 4: Представляет собой библиотеку, написанную только на Java,
//        для приведения запросов JDBC в соответствие с протоколом конкретной базы данных.

// Спецификация прикладного интерфейса JDBC доступна для загрузки по адресу:
// https://jcp.org/en/jsr/detail?id=221

// Большинство поставщиков баз данных предоставляют драйверы 3 или 4 типа.
// Целый ряд сторонних производителей специализируется на создании драйверов,
// которые позволяют добиться более полного соответствия принятым стандартам,
// поддерживают большее количество платформ,
// обладают более высокой производительностью или надежностью, чем драйверы,
// предлагаемые поставщиками баз данных.

// Основные цели прикладного интерфейса JDBC:
// 1. Разработчики пишут программы на Java, пользуясь для доступа к базам данных
//    стандартными средствами языка SQL или его специализированными расширениями,
//    следуя только соглашениям, принятым в Java.

// 2. Поставщики баз данных и инструментальных средств к ним
//    предоставляют драйверы только низкого уровня.
//    Это дает им возможность оптимизировать драйверы под свою конкретную продукцию.


// page 290
// 5.1.2 Типичные примеры применения JDBC (Typical Uses of JDBC)

// Согласно традиционной модели "клиент-сервер" графический пользовательский интерфейс (ГПИ)
// реализуется на стороне клиента, а базы данных располагается на стороне сервера (рис. 5.1)
// (resources/_290/pic_5_1.JPG)

// В этом случае драйвер JDBC развертывается на стороне клиента.

// В настоящее время существует тенденция по переходу:
// от архитектуры "клиент-сервер"
// к трехуровневой модели
//  или
// n-уровневой модели

// В трехуровневой модели:
// клиент не формирует обращения к базе данных.
// Он обращается к средствам промежуточного уровня на сервере,
// который, выполняет запросы к базе данных.

// Трехуровневая модель, обладает преимуществами.
// Она отделяет:
// 1. визуальное представление (на клиентском компьютере)
// 2. бизнес-логику (на промежуточном уровне)
// 3. исходных данных (хранящихся в базе данных).

// -> Становится возможным доступ к тем же самым данным
// по одинаковым бизнес-правилам со стороны разнотипных клиентов,
// в том числе:
//  - прикладных программ на java
//  - веб-браузеров
//  - приложений для мобильных устройств

// Взаимодействие между клиентом и промежуточным уровнем
// может быть реализовано по сетевому протоколу НТТР.

// JDBC - прикладной интерфейс, который служит для управления взаимодействием между:
// - промежуточным уровнем
// - серверной базой данных

// На рис. 5.2 (resources/_290/pic_5_2.JPG)
// схематически показана основная архитектура трехуровневой модели.


