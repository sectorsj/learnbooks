// For notes
https://horstmann.com/corejava/index.html

// page 239
var list = new ArrayList<Integer>();
list.add(3);            ->      list.add(Integer.valueOf(3));       // автоупаковка
int n = list.get(i);    ->      int n = list.get(i).intValue();     // автораспаковка

// метод, изменяющий свои числовые параметры,
// с использованием контейнерного типа - intHolder
public static void triple (intHolder x) {
    x.value++;      // успешная модификация локальной переменной
}

// page 242
// методы с переменным числом параметров

public class PrintStream {
    public PrintStream printf(String fmt, Object ... args) {       // Object ...   ->   Object[]
        return format(fmt, args);
    }

    System.out.printf("%d %s", n, "widgets");   ->  System.out.printf("%d %s", new Object[] { new Integer(n), "widgets"} );
}

public static double max (double... values) {
    double largest = Double.MIN_VALUE;
    for (double v : values){
        if (v > largest) {
            largest = v;
        }
    }
    return largest;
}

double m = mах(З.1, 40.4, -5);   ->  new double[] { 3.1, 40.4, -5 }

// page 243
// Классы перечислений

public enum Size {
    SMALL,
    MEDIUM,
    LARGE,
    EXTRA_LARGE
};
// В классы Enum можно добавить конструкторы, методы и поля


public enum Size{
    SMALL("S"),
    MEDIUM("M"),
    LARGE("L"),
    EXTRA_LARGE("XL"),

    private String abbreviation;

    private Size(String abbreviation){
        this.abbreviation = abbreviation;
    }

    public String getAbbreviation() {
        return abbreviation;
    }
}
Size s = (Size) Enum.valueOf(Size.class, "SMALL");  // s будет присвоено значение Size.SМALL
Size[] values = Size.values();  // Size.SMALL, Size.MEDIUM, Size.LARGE,Size.EXTRA_LARGE

// page 245
// 5.7 Рефлексия
задачи для рефлексии:
    • анализировать возможности классов в процессе выполнения программы;
    • проверять объекты при выполнении программы;
      например, с помощью рефлексии можно реализовать метод toString(),
      совместимый со всеми классами;
    • реализовывать обобщенный код для работы с массивами;
    • применять объекты типа Method, которые работают аналогично указателям на функции в языках, подобных С++.

// Класс Class
Employee e;
Class cl = e.getClass();
System.out.println(e.getClass().getName() + ": " + e.getName()); -> Employee: Harry Hacker

var generator = new Random();
Class cl = generator.getClass();
String name = cl.getName(); // в переменной name устанавливает строковое значение "java.util.Date"

String className = "java.util.Date";
Class cl = Class.forName(className);

Class cl1 = Date.class; // если произведен импорт пакета java.util.*;
Class cl2 = int.class;  // тип int - это не класс, но, несмотря на это, int.class - это объект типа Class.
Class сlЗ = Double[].class;

Employee.class => Class<Employee>

var className = "java.util.Random"; // или любое другое имя класса с конструктором без аргументов
Class cl = Class.forName(className);
Object obj = cl.getConstructor().newInstance(); // получение экземпляра класса "Random"

// page 249
// 5.7.2 Обработка исключений
public static void doSomethingWithClass(String name) throws ReflectiveOperationException {
    Class cl = Class.forName(name); // может сгенерировать исключение сделать что-нибудь с переменной cl
}

// 5.7.3 Ресурсы
// Примеры:
• Файлы изображения и звука
• Текстовые файлы, содержащие строки сообщений и метки экранных кнопок.

Для компиляции листинга 5.13 (ResourceTest)
1. нужно создать архивный JАR-файл
2. запустить его на выполнение, выполнив следующие команды:
    javac resource/ResourceTest.java
    jar cvfe ResourceTest.jar resources.ResourceTest\ resources/*.class resources/*.qif resources/data/*.txt corejava/*.txt
    java -jar ResourceTest.jar

В итоге получилось так:

Структура JAR-файла:
\ResourceTest.jar
    \corejava
        \title.txt
    \META-INF
        \MANIFEST.MF
    \data
        \about.txt
    \ru
        \sectorsj
            \_251_res
                \ResourceTest.class
    \about.gif

package ru.sectorsj._251_res;

import javax.swing.*;
import java.io.*;
import java.net.*;
import java.nio.charset.*;

public class ResTest {
    public static void main(String[] args) throws IOException {
        Class cl = ResTest.class;
        URL aboutURL = cl.getResource("/about.gif");
        var icon = new ImageIcon(aboutURL);

        InputStream stream = cl.getResourceAsStream("/data/about.txt");
        var about = new String(stream.readAllBytes(), "UTF-8");

        InputStream stream2 = cl.getResourceAsStream("/corejava/title.txt");
        var title = new String(stream2.readAllBytes(), StandardCharsets.UTF_8).trim();

        JOptionPane.showMessageDialog(null,
                about,
                title,
                JOptionPane.INFORMATION_MESSAGE,
                icon);
    }
}

jar cvfe .\ru\sectorsj\_251_res\ResourceTest.jar ru.sectorsj._251_res.ResTest
ru/sectorsj/_251_res/ResTest.class
-C D:\filesEvgeniy\projects\mycoding\java\learnbooks\hortsmann_vol1\src\main\resources\_251 corejava
-C D:\filesEvgeniy\projects\mycoding\java\learnbooks\hortsmann_vol1\src\main\resources\_251 about.gif
-C D:\filesEvgeniy\projects\mycoding\java\learnbooks\hortsmann_vol1\src\main\resources\_251 data

*добавил папки, а не конечные файлы.

// page 263
// 5.7.6.

var а= new Employee[100];
...
// массив заполнен
a = Arrays.copyOf(a, 2 * a.length);

// бесполезно!!!
public static Object[] badCopyOf(Object[J а, int newLength) {
    var newArray = new Object[newLength];
    System.arraycopy(a, 0, newArray, 0, Math.min(a.length, newLength));
    return newArray;
}

Для этого потребуются методы класса Array из пакета java.lang.reflect
и особенно метод newInstance()

// так можно
Object newArray = Array.newInstance(componentType, newLength);

Для того чтобы определить тип элементов нового массива, необходимо:
1. Определить, какому именно классу принадлежит объект "а".
2. Убедиться в том, что он действительно является массивом.
3. Воспользоваться методом getComponentType() из класса Class
    (определен лишь для объектов типа Class, представляющих массивы),
    чтобы получить требуемый тип массива.

public static Object goodCopyOf(Object а, int newLength) {
    Class cl = a.getClass();
    if (!cl.isArray()) return null;
    Class componentType = cl.getComponentType();
    int length = Array.getLength(a);
    Object newArray = Array.newInstance(componentType, newLength);
    System.arraycopy(a, 0, newArray, 0, Math.min(length, newLength) );
    return newArray;
}

// page 266
// 5.7.7 Вызов произвольных методов и конструкторов

Object invoke(Object obj, Object ... args)

String n = (String) m1.invoke(harry);
double s = (Double) m2.invoke(harry);

// Как получить объект типа Method?
Method getMethod(String name, Class ... parameterTypes)

Method m1 = Employee.class.getMethod("getName");
Method m2 = Employee.class.getMethod("raiseSalary", double.class);

// для конструкторов
Class cl = Random.class;    // // или любой другой класс с конструктором, принимающим параметр типа long
Constructor cons = cl.getConstructor(long.class);
Object obj = cons.newInstance(45L);

public static native double java.lang.Math.sqrt(double)
 1.0000  |       1.0000
 2.0000  |       1.4142
 3.0000  |       1.7321
 4.0000  |       2.0000
 5.0000  |       2.2361
 6.0000  |       2.4495
 7.0000  |       2.6458
 8.0000  |       2.8284
 9.0000  |       3.0000
10.0000  |       3.1623

double dx = (to - from) / (n - 1);
for (double x = from; x <= to; x +=dx) {
    double y = (Double) f.invoke(null, x);          // т.к. вызывается статический метод, 1й параметр - null
    System.out.printf("%10.4f | %10.4f%n", x, y);   // где f - это объект типа Method/
}
Math.class.getMethod("sqrt", double.class)















