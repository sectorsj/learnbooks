// For notes
https://horstmann.com/corejava/index.html

// page 239
var list = new ArrayList<Integer>();
list.add(3);            ->      list.add(Integer.valueOf(3));       // автоупаковка
int n = list.get(i);    ->      int n = list.get(i).intValue();     // автораспаковка

// метод, изменяющий свои числовые параметры,
// с использованием контейнерного типа - intHolder
public static void triple (intHolder x) {
    x.value++;      // успешная модификация локальной переменной
}

// page 242
// методы с переменным числом параметров

public class PrintStream {
    public PrintStream printf(String fmt, Object ... args) {       // Object ...   ->   Object[]
        return format(fmt, args);
    }

    System.out.printf("%d %s", n, "widgets");   ->  System.out.printf("%d %s", new Object[] { new Integer(n), "widgets"} );
}

public static double max (double... values) {
    double largest = Double.MIN_VALUE;
    for (double v : values){
        if (v > largest) {
            largest = v;
        }
    }
    return largest;
}

double m = mах(З.1, 40.4, -5);   ->  new double[] { 3.1, 40.4, -5 }

// page 243
// Классы перечислений

public enum Size {
    SMALL,
    MEDIUM,
    LARGE,
    EXTRA_LARGE
};
// В классы Enum можно добавить конструкторы, методы и поля


public enum Size{
    SMALL("S"),
    MEDIUM("M"),
    LARGE("L"),
    EXTRA_LARGE("XL"),

    private String abbreviation;

    private Size(String abbreviation){
        this.abbreviation = abbreviation;
    }

    public String getAbbreviation() {
        return abbreviation;
    }
}
Size s = (Size) Enum.valueOf(Size.class, "SMALL");  // s будет присвоено значение Size.SМALL
Size[] values = Size.values();  // Size.SMALL, Size.MEDIUM, Size.LARGE,Size.EXTRA_LARGE

// page 245
// 5.7 Рефлексия
задачи для рефлексии:
    • анализировать возможности классов в процессе выполнения программы;
    • проверять объекты при выполнении программы;
      например, с помощью рефлексии можно реализовать метод toString(),
      совместимый со всеми классами;
    • реализовывать обобщенный код для работы с массивами;
    • применять объекты типа Method, которые работают аналогично указателям на функции в языках, подобных С++.

// Класс Class
Employee e;
Class cl = e.getClass();
System.out.println(e.getClass().getName() + ": " + e.getName()); -> Employee: Harry Hacker

var generator = new Random();
Class cl = generator.getClass();
String name = cl.getName(); // в переменной name устанавливает строковое значение "java.util.Date"

String className = "java.util.Date";
Class cl = Class.forName(className);

Class cl1 = Date.class; // если произведен импорт пакета java.util.*;
Class cl2 = int.class;  // тип int - это не класс, но, несмотря на это, int.class - это объект типа Class.
Class сlЗ = Double[].class;

Employee.class => Class<Employee>

var className = "java.util.Random"; // или любое другое имя класса с конструктором без аргументов
Class cl = Class.forName(className);
Object obj = cl.getConstructor().newInstance(); // получение экземпляра класса "Random"

// page 249
// 5.7.2 Обработка исключений
public static void doSomethingWithClass(String name) throws ReflectiveOperationException {
    Class cl = Class.forName(name); // может сгенерировать исключение сделать что-нибудь с переменной cl
}

// 5.7.3 Ресурсы
// Примеры:
• Файлы изображения и звука
• Текстовые файлы, содержащие строки сообщений и метки экранных кнопок.

Для компиляции листинга 5.13 (ResourceTest)
1. нужно создать архивный JАR-файл
2. запустить его на выполнение, выполнив следующие команды:
    javac resource/ResourceTest.java
    jar cvfe ResourceTest.jar resources.ResourceTest\ resources/*.class resources/*.qif resources/data/*.txt corejava/*.txt
    java -jar ResourceTest.jar

В итоге получилось так:

Структура JAR-файла:
\ResourceTest.jar
    \corejava
        \title.txt
    \META-INF
        \MANIFEST.MF
    \data
        \about.txt
    \ru
        \sectorsj
            \_251_res
                \ResourceTest.class
    \about.gif

package ru.sectorsj._251_res;

import javax.swing.*;
import java.io.*;
import java.net.*;
import java.nio.charset.*;

public class ResTest {
    public static void main(String[] args) throws IOException {
        Class cl = ResTest.class;
        URL aboutURL = cl.getResource("/about.gif");
        var icon = new ImageIcon(aboutURL);

        InputStream stream = cl.getResourceAsStream("/data/about.txt");
        var about = new String(stream.readAllBytes(), "UTF-8");

        InputStream stream2 = cl.getResourceAsStream("/corejava/title.txt");
        var title = new String(stream2.readAllBytes(), StandardCharsets.UTF_8).trim();

        JOptionPane.showMessageDialog(null,
                about,
                title,
                JOptionPane.INFORMATION_MESSAGE,
                icon);
    }
}

jar cvfe .\ru\sectorsj\_251_res\ResourceTest.jar ru.sectorsj._251_res.ResTest
ru/sectorsj/_251_res/ResTest.class
-C D:\filesEvgeniy\projects\mycoding\java\learnbooks\hortsmann_vol1\src\main\resources\_251 corejava
-C D:\filesEvgeniy\projects\mycoding\java\learnbooks\hortsmann_vol1\src\main\resources\_251 about.gif
-C D:\filesEvgeniy\projects\mycoding\java\learnbooks\hortsmann_vol1\src\main\resources\_251 data

*добавил папки, а не конечные файлы.

// page 263
// 5.7.6.

var а= new Employee[100];
...
// массив заполнен
a = Arrays.copyOf(a, 2 * a.length);

// бесполезно!!!
public static Object[] badCopyOf(Object[J а, int newLength) {
    var newArray = new Object[newLength];
    System.arraycopy(a, 0, newArray, 0, Math.min(a.length, newLength));
    return newArray;
}

Для этого потребуются методы класса Array из пакета java.lang.reflect
и особенно метод newInstance()

// так можно
Object newArray = Array.newInstance(componentType, newLength);

Для того чтобы определить тип элементов нового массива, необходимо:
1. Определить, какому именно классу принадлежит объект "а".
2. Убедиться в том, что он действительно является массивом.
3. Воспользоваться методом getComponentType() из класса Class
    (определен лишь для объектов типа Class, представляющих массивы),
    чтобы получить требуемый тип массива.

public static Object goodCopyOf(Object а, int newLength) {
    Class cl = a.getClass();
    if (!cl.isArray()) return null;
    Class componentType = cl.getComponentType();
    int length = Array.getLength(a);
    Object newArray = Array.newInstance(componentType, newLength);
    System.arraycopy(a, 0, newArray, 0, Math.min(length, newLength) );
    return newArray;
}

// page 266
// 5.7.7 Вызов произвольных методов и конструкторов

Object invoke(Object obj, Object ... args)

String n = (String) m1.invoke(harry);
double s = (Double) m2.invoke(harry);

// Как получить объект типа Method?
Method getMethod(String name, Class ... parameterTypes)

Method m1 = Employee.class.getMethod("getName");
Method m2 = Employee.class.getMethod("raiseSalary", double.class);

// для конструкторов
Class cl = Random.class;    // или любой другой класс с конструктором, принимающим параметр типа long
Constructor cons = cl.getConstructor(long.class);
Object obj = cons.newInstance(45L);

public static native double java.lang.Math.sqrt(double)
 1.0000  |       1.0000
 2.0000  |       1.4142
 3.0000  |       1.7321
 4.0000  |       2.0000
 5.0000  |       2.2361
 6.0000  |       2.4495
 7.0000  |       2.6458
 8.0000  |       2.8284
 9.0000  |       3.0000
10.0000  |       3.1623

double dx = (to - from) / (n - 1);
for (double x = from; x <= to; x +=dx) {
    double y = (Double) f.invoke(null, x);          // т.к. вызывается статический метод, 1й параметр - null
    System.out.printf("%10.4f | %10.4f%n", x, y);   // где f - это объект типа Method/
}
Math.class.getMethod("sqrt", double.class)

// page 270
// 5.8 Рекомендации по применению наследования


Резюме
1. размещайте общие операции и поля в суперклассе
2. Стараться не пользоваться защищенными (protected) полями
3. Использовать наследование для моделирования отношений - "является"
4. Не пользоваться наследованием, если не все методы имеет смысл сделать наследуемыми
5. Не изменять предполагаемое поведение метода при его переопределении
6. Пользоваться принципом полиморфизма, а не данными о типе
7. Не злоупотреблять механизмом рефлексии

// 273
// interfaces | lambdas | inner classes | service loaders | proxies

// 6.1 Интерфейсы
// 6.1.1 Понятие интерфейса

// до java 5
public interface Comparable {
    int compareTo(Object other);
}
// после java 5
public interface Comparable<T> {
    int compareTo(T other); //этот параметр относится к обобщенному типу Т
}

Итак, если Comparable<Employee> ->  int compareTo(Employee other);


class Employee implements ComparaЫe<Employee> {
    public int compareTo(Employee other) {
        return DouЫe.compare(salary, other.salary);
    }
    ...
}

// page 289
// 6.1.8 Интерфейс Comparable

public interface Comparator<T> {
    int compare(T first, Т second);
}

// создаем компаратор для сравнения строк по их длине
class LengthComparator implements Comparator<String>{
    public int compare(String first, String second) {
        return first.length() - second.length();
    }
}

var comp = new LengthComparator();
if (comp.compare(words[i], words(j]) > 0) ...

String[] friends = { "Peter", "Paul", "Mary" };
Arrays.sort(friends, new LengthComparator());

// page 290
// 6.1.9 Клонирование объектов

var original = new Employee("Невил Долгопупс", 50000);
Employee copy = original;
copy.raiseSalary(10);   // упс, оригинал тоже изменился!

Employee copy = original.clone();
copy.raiseSalary(10);   // хорошо, теперь оригинал не изменился!

Метод clone() - является защищенным (protected)

Чтобы применить метод clone(), нужно принять следующее решение:
Вариант 1. Достаточно ли метода clone(), предоставляемого по умолчанию?
Вариант 2. Можно ли доработать предоставляемый по умолчанию метод clone() таким образом,
   чтобы вызывать его для изменяемых объектов?
Вариант 3. Следует ли вообще отказаться от применения метода clone()?

Если хотите использовать Вариант 1 или Вариант2, то нужно:
1. Реализовать интерфейс Cloneable.
2. Переопределить метод clone() с модификатором доступа public.

Интерфейс Cloneable - маркерный интерфейс, т.е. не имеет ни одного метода.
Его задача, разрешить выполнение операции instanceof
для проверки типа следующим образом:

if (obj instanceof Cloneable) ...

Для реализации метода clone() по умолчанию(неполное копирование), нужно:
1. реализовать интерфейс Cloneable,
2. переопределить метод clone() как открытый (public)
3. сделать вызов super.clone()

class Employee implements Cloneable {
    // сделать метод открытым, изменить возвращаемый тип
    public Employee clone() throws CloneNotSupportedException {
        return (Employee) super.clone();
    }
    ...
}

// пример реализации метода clone(), выполняющего полное копирование
class Employee implements Cloneable{
    ...

    public Employee clone() throws CloneNotSupportedException{
        // вызов метода Object.clone()
        Employee cloned = (Employee) super.clone();

        // клонировать изменяемые поля
        cloned.hireDay = (Date) hireDay.clone();

        return cloned
    }
}

// пример метода clone() в массивах,
// но он открытый (public), а не защищенный (protected)
int[] luckyNumbers = {2, 3, 5, 7, 11, 13};
int[] cloned = (int[]) luckyNumbers.clone();
cloned[5] = 12;     // не изменяет элемент массива luckyNumbers[5]

// page 296
// 6.2 Лямбда выражения
// 6.2.1 Причины для употребления лямбда-выражений

class Worker implements ActionListener {
    public void actionPerformed(ActionEvent event){
        // сделать что-то
    }
}

class LengthComparator implements Comparator<String> {
    public int compare(String first, String second) {
        return first.length() - second.length();
    }
}
...
Arrays.sort(strings, new LengthComparator());



// 6.2.2 Синтаксис лямбда-выражений
first.length() - second.length()
->
(String first, String second) -> first.length() - second.length()

// -> λfirst.λsecond.first.length() - second.length()

// если есть параметры:
(String first, String second) -> {
    if (first.length() < second.length()) return -1;
    else if (first.length() > second.length()) return 1;
    else return 0;
}

// при отсутствии параметров:
() -> {
    for (int i = 100; i >= 0; i--)
        System.out.println(i);
}

// Можно опустить типы параметров лямбда выражений, т.к.
// результат вычисления лямбда-выражения присваивается компаратору символьных строк.
// (first, second) тоже самое, что и "(String first, String second)"

Comparator<String> comp = (first, second) ->
    first.length() - second.length();

// Если у метода имеется единственный параметр выводимого типа,
// то можно опустить круглые скобки
// вместо (event) -> ...
// или (ActionListener event) -> ...

ActionListener listener = event ->
    System.out.println("Время " + Instant.ofEpochMilli(event.getWhen()));

// Результат вычисления лямбда-выражений вообще не указывается.
// Данное выражение может быть использовано там,
// где ожидается результат типа int
(String first, String second) ->
    first.length() - second.length()


// Недопустимо, чтобы значение возвращалось в одних ветвях лямбда-выражения,
// но не возвращалось в других его ветвях.
(int х) -> (if (х >= 0) return 1;)      // Ошибка!


// page 300
// 6.2.3 Функциональные интерфейсы


Чтобы продемонстрировать преобразование в функциональный интерфейс,
рассмотрим снова метод Arrays.sort().
В качестве второго параметра ему требуется экземпляр типа Comparator - интерфейса с единственным методом.

Вместо него достаточно предоставить лямбда-выражение следующим образом:
Arrays.sort(words, (first, second) -> first.length() - second.length() );
Подспудно метод Arrays.sort() принимает объект некоторого класса,
реализующего интерфейс Comparator.
В результате вызова метода compare() для этого объекта выполняется тело лямбда-выражения.
Управление такими объектами и классами полностью зависит от конкретной реализации
и может быть намного более эффективным, чем применение традиционных внутренних классов.
Поэтому лямбда-выражение лучше всего рассматривать как функцию, а не объект,
приняв к сведению, что оно может быть передано функциональному интерфейсу.

В стандартной библиотеке Java предоставляется целый ряд
весьма универсальных функциональных интерфейсов,
входящих в пакет java.util.function

BiFunction<String, String, Integer> copm
    = (first, second) -> first.length() - second.length();

public interface Predicate<T> {
    boolean test(T t);
    // Дополнительные методы по умолчанию и статические методы
}

// removeIf() - из класса ArrayList, с параметром типа Predicate
list.removeIf(e -> e == null);

// Supplier<T>
public interface Supplier<T>{
    T get();
}

LocalDate hireDay = Objects.requireNonNullOrElse(day, new LocalDate(1970, 1, 1));
->
LocalDate hireDay = Objects.requireNonNullOrElseGet(day,
    () -> new LocalDate(1970, 1, 1));


// page 302
// 6.2.4 Ссылки на методы

var timer = new Timer(1000, event -> System.out.println(event));
->
var timer = new Timer(1000, System.out::println);

Arrays.sort(strings, String::compareToignoreCase)

Разновидности ссылок на методы в лямбда выражениях:
1 Объект:: МетодЭкземпляра
2  Класс:: МетодЭкземпляра
3  Класс:: СтатическийМетод

|       Ссылка на метод        |    Равнозначное лямбда-выражение      |                       Примечания                      |
|------------------------------|---------------------------------------|-------------------------------------------------------|
| System.out::println          |   x -> System.out.println(x)          |   ссылка на метод равнозначна лямбда выражению,       |
|                              |                                       |   параметры которого передаются методу                |
| String::compareToignoreCase  |  (х, у) -> х.compareToignoreCase (у)  |   первый параметр ссылки на метод становится          |
|                              |                                       |   неявным параметром метода                           |
| separator::equals            |   x -> separator.equals(x)            |   Это выражение-метод с заданным объектом             |
|                              |                                       |   экземпляра. Параметр лямбда-выражения               |
|                              |                                       |   передается как явный параметр метода                |
| String::trim                 |   x -> x.trim()                       |   Это выражение-метод с заданным классом и методом    |
|                              |                                       |   экземпляра. Параметр лямбда-выражения становится    |
|                              |                                       |   неявным параметром                                  |
| String::concat               |   (x, y) -> x.concat(y)               |   Здесь вызывается метод экземпляра, но на этот раз   |
|                              |                                       |   с явным параметром. Как и прежде, первый параметр   |
|                              |                                       |   лямбда-выражения становится неявным параметром, а   |
|                              |                                       |   остальные параметры передаются методу               |
| Integer::valueOf             |   x -> Integer::valueOf(x)            |   Это выражение-метод с заданным статическим методом. |
|                              |                                       |   Параметр лямбда-выражения передается этому          |
|                              |                                       |   статическому методу                                 |
| Integer::sum                 |   (x, y) -> Integer::sum(x, y)        |   Это еще один пример вызова статического метода,     |
|                              |                                       |   но на этот раз с двумя параметрами. Оба параметра   |
|                              |                                       |   лямбда-выражения передаются статическому методу.    |
|                              |                                       |   В частости, метод Integer.sun() создается, чтобы    |
|                              |                                       |   служить в качестве ссылки на метод. В качестве      |
|                              |                                       |   альтернативы можно было бы просто составить         |
|                              |                                       |   лямбда-выражение (x, y) -> x + y                    |
| Integer:new                  |   x -> new Integer(x)                 |   Это ссылка на конструктор (6.2.5). Параметры        |
|                              |                                       |   лямбда-выражения передаются конструктору            |
| Integer[]::new               |   n -> new Integer[n]                 |   Это ссылка на конструктор массива (6.2.5) Параметр  |
|                              |                                       |   лямбда-выражения определяет длину массива           |
|------------------------------|---------------------------------------|-------------------------------------------------------|

Objects.isNull(obj) => Predicate =>
list.removeIf(Objects::isNull);     // эту строку легче читать
list.removeIf(e -> e == null);      // чем эту

this::equals        x -> this.equals(x);
super::equals       x -> super.equals(x);

 Ссылка super является целевой и вызывает вариант заданного метода экземпляра из суперкласса.

// Пример
class Greeter {
    public void greet(ActionEvent event) {
        System.out.println("Hello, the time is" + Instant.ofEpochMilli(event.getWhen()))
    }
}

class RepeatedGreeter extends Greeter {
    public void greet(ActionEvent event) {
        var timer = new Timer(1000, super::greet);
        timer.start();
    }
}

// page 305
// 6.2.5 Ссылки на конструкторы

Ссылки на конструкторы действуют таким же образом, как и ссылки на методы,
за исключением того, что вместо имени метода указывается операция new.

ArrayList<String> names = ...;
Stream<Person> stream = names.stream().map(Person::new);
List<Person> people = stream.collect(Collectors.toList());

int[]::new  => x -> new int[x]

Object[] people = steam.toArray();      // допустим требуется создать массив из объектов типа Person
->
Object[] people = steam.toArray(Person[]::new);































